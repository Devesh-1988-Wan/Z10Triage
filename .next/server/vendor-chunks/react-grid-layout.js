/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-grid-layout";
exports.ids = ["vendor-chunks/react-grid-layout"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-grid-layout/build/GridItem.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-grid-layout/build/GridItem.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _reactDom = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\nvar _reactDraggable = __webpack_require__(/*! react-draggable */ \"(ssr)/./node_modules/react-draggable/build/cjs/cjs.js\");\nvar _reactResizable = __webpack_require__(/*! react-resizable */ \"(ssr)/./node_modules/react-resizable/index.js\");\nvar _utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-grid-layout/build/utils.js\");\nvar _calculateUtils = __webpack_require__(/*! ./calculateUtils */ \"(ssr)/./node_modules/react-grid-layout/build/calculateUtils.js\");\nvar _ReactGridLayoutPropTypes = __webpack_require__(/*! ./ReactGridLayoutPropTypes */ \"(ssr)/./node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js\");\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/*:: import type { Element as ReactElement, Node as ReactNode } from \"react\";*/\n/*:: import type {\n  ReactDraggableCallbackData,\n  GridDragEvent,\n  GridResizeEvent,\n  DroppingPosition,\n  Position,\n  ResizeHandleAxis\n} from \"./utils\";*/\n/*:: import type { PositionParams } from \"./calculateUtils\";*/\n/*:: import type { ResizeHandle, ReactRef } from \"./ReactGridLayoutPropTypes\";*/\n/*:: type PartialPosition = { top: number, left: number };*/\n/*:: type GridItemCallback<Data: GridDragEvent | GridResizeEvent> = (\n  i: string,\n  w: number,\n  h: number,\n  Data\n) => void;*/\n/*:: type ResizeCallbackData = {\n  node: HTMLElement,\n  size: Position,\n  handle: ResizeHandleAxis\n};*/\n/*:: type GridItemResizeCallback = (\n  e: Event,\n  data: ResizeCallbackData,\n  position: Position\n) => void;*/\n/*:: type State = {\n  resizing: ?{ top: number, left: number, width: number, height: number },\n  dragging: ?{ top: number, left: number },\n  className: string\n};*/\n/*:: type Props = {\n  children: ReactElement<any>,\n  cols: number,\n  containerWidth: number,\n  margin: [number, number],\n  containerPadding: [number, number],\n  rowHeight: number,\n  maxRows: number,\n  isDraggable: boolean,\n  isResizable: boolean,\n  isBounded: boolean,\n  static?: boolean,\n  useCSSTransforms?: boolean,\n  usePercentages?: boolean,\n  transformScale: number,\n  droppingPosition?: DroppingPosition,\n\n  className: string,\n  style?: Object,\n  // Draggability\n  cancel: string,\n  handle: string,\n\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n\n  minW: number,\n  maxW: number,\n  minH: number,\n  maxH: number,\n  i: string,\n\n  resizeHandles?: ResizeHandleAxis[],\n  resizeHandle?: ResizeHandle,\n\n  onDrag?: GridItemCallback<GridDragEvent>,\n  onDragStart?: GridItemCallback<GridDragEvent>,\n  onDragStop?: GridItemCallback<GridDragEvent>,\n  onResize?: GridItemCallback<GridResizeEvent>,\n  onResizeStart?: GridItemCallback<GridResizeEvent>,\n  onResizeStop?: GridItemCallback<GridResizeEvent>\n};*/\n/*:: type DefaultProps = {\n  className: string,\n  cancel: string,\n  handle: string,\n  minH: number,\n  minW: number,\n  maxH: number,\n  maxW: number,\n  transformScale: number\n};*/\n/**\n * An individual item within a ReactGridLayout.\n */\nclass GridItem extends _react.default.Component /*:: <Props, State>*/{\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", {\n      resizing: null,\n      dragging: null,\n      className: \"\"\n    });\n    _defineProperty(this, \"elementRef\", /*#__PURE__*/_react.default.createRef());\n    /**\n     * onDragStart event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     */\n    _defineProperty(this, \"onDragStart\", (e, _ref) => {\n      let {\n        node\n      } = _ref;\n      const {\n        onDragStart,\n        transformScale\n      } = this.props;\n      if (!onDragStart) return;\n      const newPosition /*: PartialPosition*/ = {\n        top: 0,\n        left: 0\n      };\n\n      // TODO: this wont work on nested parents\n      const {\n        offsetParent\n      } = node;\n      if (!offsetParent) return;\n      const parentRect = offsetParent.getBoundingClientRect();\n      const clientRect = node.getBoundingClientRect();\n      const cLeft = clientRect.left / transformScale;\n      const pLeft = parentRect.left / transformScale;\n      const cTop = clientRect.top / transformScale;\n      const pTop = parentRect.top / transformScale;\n      newPosition.left = cLeft - pLeft + offsetParent.scrollLeft;\n      newPosition.top = cTop - pTop + offsetParent.scrollTop;\n      this.setState({\n        dragging: newPosition\n      });\n\n      // Call callback with this data\n      const {\n        x,\n        y\n      } = (0, _calculateUtils.calcXY)(this.getPositionParams(), newPosition.top, newPosition.left, this.props.w, this.props.h);\n      return onDragStart.call(this, this.props.i, x, y, {\n        e,\n        node,\n        newPosition\n      });\n    });\n    /**\n     * onDrag event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     * @param  {boolean} dontFlush    if true, will not call flushSync\n     */\n    _defineProperty(this, \"onDrag\", (e, _ref2, dontFlush) => {\n      let {\n        node,\n        deltaX,\n        deltaY\n      } = _ref2;\n      const {\n        onDrag\n      } = this.props;\n      if (!onDrag) return;\n      if (!this.state.dragging) {\n        throw new Error(\"onDrag called before onDragStart.\");\n      }\n      let top = this.state.dragging.top + deltaY;\n      let left = this.state.dragging.left + deltaX;\n      const {\n        isBounded,\n        i,\n        w,\n        h,\n        containerWidth\n      } = this.props;\n      const positionParams = this.getPositionParams();\n\n      // Boundary calculations; keeps items within the grid\n      if (isBounded) {\n        const {\n          offsetParent\n        } = node;\n        if (offsetParent) {\n          const {\n            margin,\n            rowHeight\n          } = this.props;\n          const bottomBoundary = offsetParent.clientHeight - (0, _calculateUtils.calcGridItemWHPx)(h, rowHeight, margin[1]);\n          top = (0, _calculateUtils.clamp)(top, 0, bottomBoundary);\n          const colWidth = (0, _calculateUtils.calcGridColWidth)(positionParams);\n          const rightBoundary = containerWidth - (0, _calculateUtils.calcGridItemWHPx)(w, colWidth, margin[0]);\n          left = (0, _calculateUtils.clamp)(left, 0, rightBoundary);\n        }\n      }\n      const newPosition /*: PartialPosition*/ = {\n        top,\n        left\n      };\n\n      // dontFlush is set if we're calling from inside\n      if (dontFlush) {\n        this.setState({\n          dragging: newPosition\n        });\n      } else {\n        (0, _reactDom.flushSync)(() => {\n          this.setState({\n            dragging: newPosition\n          });\n        });\n      }\n\n      // Call callback with this data\n      const {\n        x,\n        y\n      } = (0, _calculateUtils.calcXY)(positionParams, top, left, w, h);\n      return onDrag.call(this, i, x, y, {\n        e,\n        node,\n        newPosition\n      });\n    });\n    /**\n     * onDragStop event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     */\n    _defineProperty(this, \"onDragStop\", (e, _ref3) => {\n      let {\n        node\n      } = _ref3;\n      const {\n        onDragStop\n      } = this.props;\n      if (!onDragStop) return;\n      if (!this.state.dragging) {\n        throw new Error(\"onDragEnd called before onDragStart.\");\n      }\n      const {\n        w,\n        h,\n        i\n      } = this.props;\n      const {\n        left,\n        top\n      } = this.state.dragging;\n      const newPosition /*: PartialPosition*/ = {\n        top,\n        left\n      };\n      this.setState({\n        dragging: null\n      });\n      const {\n        x,\n        y\n      } = (0, _calculateUtils.calcXY)(this.getPositionParams(), top, left, w, h);\n      return onDragStop.call(this, i, x, y, {\n        e,\n        node,\n        newPosition\n      });\n    });\n    /**\n     * onResizeStop event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node and size information\n     */\n    _defineProperty(this, \"onResizeStop\", (e, callbackData, position) => this.onResizeHandler(e, callbackData, position, \"onResizeStop\"));\n    // onResizeStart event handler\n    _defineProperty(this, \"onResizeStart\", (e, callbackData, position) => this.onResizeHandler(e, callbackData, position, \"onResizeStart\"));\n    // onResize event handler\n    _defineProperty(this, \"onResize\", (e, callbackData, position) => this.onResizeHandler(e, callbackData, position, \"onResize\"));\n  }\n  shouldComponentUpdate(nextProps /*: Props*/, nextState /*: State*/) /*: boolean*/{\n    // We can't deeply compare children. If the developer memoizes them, we can\n    // use this optimization.\n    if (this.props.children !== nextProps.children) return true;\n    if (this.props.droppingPosition !== nextProps.droppingPosition) return true;\n    // TODO memoize these calculations so they don't take so long?\n    const oldPosition = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(this.props), this.props.x, this.props.y, this.props.w, this.props.h, this.state);\n    const newPosition = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(nextProps), nextProps.x, nextProps.y, nextProps.w, nextProps.h, nextState);\n    return !(0, _utils.fastPositionEqual)(oldPosition, newPosition) || this.props.useCSSTransforms !== nextProps.useCSSTransforms;\n  }\n  componentDidMount() {\n    this.moveDroppingItem({});\n  }\n  componentDidUpdate(prevProps /*: Props*/) {\n    this.moveDroppingItem(prevProps);\n  }\n\n  // When a droppingPosition is present, this means we should fire a move event, as if we had moved\n  // this element by `x, y` pixels.\n  moveDroppingItem(prevProps /*: Props*/) {\n    const {\n      droppingPosition\n    } = this.props;\n    if (!droppingPosition) return;\n    const node = this.elementRef.current;\n    // Can't find DOM node (are we unmounted?)\n    if (!node) return;\n    const prevDroppingPosition = prevProps.droppingPosition || {\n      left: 0,\n      top: 0\n    };\n    const {\n      dragging\n    } = this.state;\n    const shouldDrag = dragging && droppingPosition.left !== prevDroppingPosition.left || droppingPosition.top !== prevDroppingPosition.top;\n    if (!dragging) {\n      this.onDragStart(droppingPosition.e, {\n        node,\n        deltaX: droppingPosition.left,\n        deltaY: droppingPosition.top\n      });\n    } else if (shouldDrag) {\n      const deltaX = droppingPosition.left - dragging.left;\n      const deltaY = droppingPosition.top - dragging.top;\n      this.onDrag(droppingPosition.e, {\n        node,\n        deltaX,\n        deltaY\n      }, true // dontFLush: avoid flushSync to temper warnings\n      );\n    }\n  }\n  getPositionParams() /*: PositionParams*/{\n    let props /*: Props*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n    return {\n      cols: props.cols,\n      containerPadding: props.containerPadding,\n      containerWidth: props.containerWidth,\n      margin: props.margin,\n      maxRows: props.maxRows,\n      rowHeight: props.rowHeight\n    };\n  }\n\n  /**\n   * This is where we set the grid item's absolute placement. It gets a little tricky because we want to do it\n   * well when server rendering, and the only way to do that properly is to use percentage width/left because\n   * we don't know exactly what the browser viewport is.\n   * Unfortunately, CSS Transforms, which are great for performance, break in this instance because a percentage\n   * left is relative to the item itself, not its container! So we cannot use them on the server rendering pass.\n   *\n   * @param  {Object} pos Position object with width, height, left, top.\n   * @return {Object}     Style object.\n   */\n  createStyle(pos /*: Position*/) /*: { [key: string]: ?string }*/{\n    const {\n      usePercentages,\n      containerWidth,\n      useCSSTransforms\n    } = this.props;\n    let style;\n    // CSS Transforms support (default)\n    if (useCSSTransforms) {\n      style = (0, _utils.setTransform)(pos);\n    } else {\n      // top,left (slow)\n      style = (0, _utils.setTopLeft)(pos);\n\n      // This is used for server rendering.\n      if (usePercentages) {\n        style.left = (0, _utils.perc)(pos.left / containerWidth);\n        style.width = (0, _utils.perc)(pos.width / containerWidth);\n      }\n    }\n    return style;\n  }\n\n  /**\n   * Mix a Draggable instance into a child.\n   * @param  {Element} child    Child element.\n   * @return {Element}          Child wrapped in Draggable.\n   */\n  mixinDraggable(child /*: ReactElement<any>*/, isDraggable /*: boolean*/) /*: ReactElement<any>*/{\n    return /*#__PURE__*/_react.default.createElement(_reactDraggable.DraggableCore, {\n      disabled: !isDraggable,\n      onStart: this.onDragStart,\n      onDrag: this.onDrag,\n      onStop: this.onDragStop,\n      handle: this.props.handle,\n      cancel: \".react-resizable-handle\" + (this.props.cancel ? \",\" + this.props.cancel : \"\"),\n      scale: this.props.transformScale,\n      nodeRef: this.elementRef\n    }, child);\n  }\n\n  /**\n   * Utility function to setup callback handler definitions for\n   * similarily structured resize events.\n   */\n  curryResizeHandler(position /*: Position*/, handler /*: Function*/) /*: Function*/{\n    return (e /*: Event*/, data /*: ResizeCallbackData*/) => /*: Function*/handler(e, data, position);\n  }\n\n  /**\n   * Mix a Resizable instance into a child.\n   * @param  {Element} child    Child element.\n   * @param  {Object} position  Position object (pixel values)\n   * @return {Element}          Child wrapped in Resizable.\n   */\n  mixinResizable(child /*: ReactElement<any>*/, position /*: Position*/, isResizable /*: boolean*/) /*: ReactElement<any>*/{\n    const {\n      cols,\n      minW,\n      minH,\n      maxW,\n      maxH,\n      transformScale,\n      resizeHandles,\n      resizeHandle\n    } = this.props;\n    const positionParams = this.getPositionParams();\n\n    // This is the max possible width - doesn't go to infinity because of the width of the window\n    const maxWidth = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, cols, 0).width;\n\n    // Calculate min/max constraints using our min & maxes\n    const mins = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, minW, minH);\n    const maxes = (0, _calculateUtils.calcGridItemPosition)(positionParams, 0, 0, maxW, maxH);\n    const minConstraints = [mins.width, mins.height];\n    const maxConstraints = [Math.min(maxes.width, maxWidth), Math.min(maxes.height, Infinity)];\n    return /*#__PURE__*/_react.default.createElement(_reactResizable.Resizable\n    // These are opts for the resize handle itself\n    , {\n      draggableOpts: {\n        disabled: !isResizable\n      },\n      className: isResizable ? undefined : \"react-resizable-hide\",\n      width: position.width,\n      height: position.height,\n      minConstraints: minConstraints,\n      maxConstraints: maxConstraints,\n      onResizeStop: this.curryResizeHandler(position, this.onResizeStop),\n      onResizeStart: this.curryResizeHandler(position, this.onResizeStart),\n      onResize: this.curryResizeHandler(position, this.onResize),\n      transformScale: transformScale,\n      resizeHandles: resizeHandles,\n      handle: resizeHandle\n    }, child);\n  }\n  /**\n   * Wrapper around resize events to provide more useful data.\n   */\n  onResizeHandler(e /*: Event*/, _ref4 /*:: */,\n  // 'size' is updated position\n  position /*: Position*/,\n  // existing position\n  handlerName /*: string*/) /*: void*/{\n    let {\n      node,\n      size,\n      handle\n    } /*: ResizeCallbackData*/ = _ref4 /*: ResizeCallbackData*/;\n    const handler = this.props[handlerName];\n    if (!handler) return;\n    const {\n      x,\n      y,\n      i,\n      maxH,\n      minH,\n      containerWidth\n    } = this.props;\n    const {\n      minW,\n      maxW\n    } = this.props;\n\n    // Clamping of dimensions based on resize direction\n    let updatedSize = size;\n    if (node) {\n      updatedSize = (0, _utils.resizeItemInDirection)(handle, position, size, containerWidth);\n      (0, _reactDom.flushSync)(() => {\n        this.setState({\n          resizing: handlerName === \"onResizeStop\" ? null : updatedSize\n        });\n      });\n    }\n\n    // Get new XY based on pixel size\n    let {\n      w,\n      h\n    } = (0, _calculateUtils.calcWH)(this.getPositionParams(), updatedSize.width, updatedSize.height, x, y, handle);\n\n    // Min/max capping.\n    // minW should be at least 1 (TODO propTypes validation?)\n    w = (0, _calculateUtils.clamp)(w, Math.max(minW, 1), maxW);\n    h = (0, _calculateUtils.clamp)(h, minH, maxH);\n    handler.call(this, i, w, h, {\n      e,\n      node,\n      size: updatedSize,\n      handle\n    });\n  }\n  render() /*: ReactNode*/{\n    const {\n      x,\n      y,\n      w,\n      h,\n      isDraggable,\n      isResizable,\n      droppingPosition,\n      useCSSTransforms\n    } = this.props;\n    const pos = (0, _calculateUtils.calcGridItemPosition)(this.getPositionParams(), x, y, w, h, this.state);\n    const child = _react.default.Children.only(this.props.children);\n\n    // Create the child element. We clone the existing element but modify its className and style.\n    let newChild = /*#__PURE__*/_react.default.cloneElement(child, {\n      ref: this.elementRef,\n      className: (0, _clsx.default)(\"react-grid-item\", child.props.className, this.props.className, {\n        static: this.props.static,\n        resizing: Boolean(this.state.resizing),\n        \"react-draggable\": isDraggable,\n        \"react-draggable-dragging\": Boolean(this.state.dragging),\n        dropping: Boolean(droppingPosition),\n        cssTransforms: useCSSTransforms\n      }),\n      // We can set the width and height on the child, but unfortunately we can't set the position.\n      style: {\n        ...this.props.style,\n        ...child.props.style,\n        ...this.createStyle(pos)\n      }\n    });\n\n    // Resizable support. This is usually on but the user can toggle it off.\n    newChild = this.mixinResizable(newChild, pos, isResizable);\n\n    // Draggable support. This is always on, except for with placeholders.\n    newChild = this.mixinDraggable(newChild, isDraggable);\n    return newChild;\n  }\n}\nexports[\"default\"] = GridItem;\n_defineProperty(GridItem, \"propTypes\", {\n  // Children must be only a single element\n  children: _propTypes.default.element,\n  // General grid attributes\n  cols: _propTypes.default.number.isRequired,\n  containerWidth: _propTypes.default.number.isRequired,\n  rowHeight: _propTypes.default.number.isRequired,\n  margin: _propTypes.default.array.isRequired,\n  maxRows: _propTypes.default.number.isRequired,\n  containerPadding: _propTypes.default.array.isRequired,\n  // These are all in grid units\n  x: _propTypes.default.number.isRequired,\n  y: _propTypes.default.number.isRequired,\n  w: _propTypes.default.number.isRequired,\n  h: _propTypes.default.number.isRequired,\n  // All optional\n  minW: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"minWidth not Number\");\n    if (value > props.w || value > props.maxW) return new Error(\"minWidth larger than item width/maxWidth\");\n  },\n  maxW: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"maxWidth not Number\");\n    if (value < props.w || value < props.minW) return new Error(\"maxWidth smaller than item width/minWidth\");\n  },\n  minH: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"minHeight not Number\");\n    if (value > props.h || value > props.maxH) return new Error(\"minHeight larger than item height/maxHeight\");\n  },\n  maxH: function (props /*: Props*/, propName /*: string*/) {\n    const value = props[propName];\n    if (typeof value !== \"number\") return new Error(\"maxHeight not Number\");\n    if (value < props.h || value < props.minH) return new Error(\"maxHeight smaller than item height/minHeight\");\n  },\n  // ID is nice to have for callbacks\n  i: _propTypes.default.string.isRequired,\n  // Resize handle options\n  resizeHandles: _ReactGridLayoutPropTypes.resizeHandleAxesType,\n  resizeHandle: _ReactGridLayoutPropTypes.resizeHandleType,\n  // Functions\n  onDragStop: _propTypes.default.func,\n  onDragStart: _propTypes.default.func,\n  onDrag: _propTypes.default.func,\n  onResizeStop: _propTypes.default.func,\n  onResizeStart: _propTypes.default.func,\n  onResize: _propTypes.default.func,\n  // Flags\n  isDraggable: _propTypes.default.bool.isRequired,\n  isResizable: _propTypes.default.bool.isRequired,\n  isBounded: _propTypes.default.bool.isRequired,\n  static: _propTypes.default.bool,\n  // Use CSS transforms instead of top/left\n  useCSSTransforms: _propTypes.default.bool.isRequired,\n  transformScale: _propTypes.default.number,\n  // Others\n  className: _propTypes.default.string,\n  // Selector for draggable handle\n  handle: _propTypes.default.string,\n  // Selector for draggable cancel (see react-draggable)\n  cancel: _propTypes.default.string,\n  // Current position of a dropping element\n  droppingPosition: _propTypes.default.shape({\n    e: _propTypes.default.object.isRequired,\n    left: _propTypes.default.number.isRequired,\n    top: _propTypes.default.number.isRequired\n  })\n});\n_defineProperty(GridItem, \"defaultProps\", {\n  className: \"\",\n  cancel: \"\",\n  handle: \"\",\n  minH: 1,\n  minW: 1,\n  maxH: Infinity,\n  maxW: Infinity,\n  transformScale: 1\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvR3JpZEl0ZW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixvQ0FBb0MsbUJBQU8sQ0FBQyx3R0FBTztBQUNuRCxnQkFBZ0IsbUJBQU8sQ0FBQyxnSEFBVztBQUNuQyx3Q0FBd0MsbUJBQU8sQ0FBQyw0REFBWTtBQUM1RCxzQkFBc0IsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDL0Msc0JBQXNCLG1CQUFPLENBQUMsc0VBQWlCO0FBQy9DLGFBQWEsbUJBQU8sQ0FBQyxzRUFBUztBQUM5QixzQkFBc0IsbUJBQU8sQ0FBQyx3RkFBa0I7QUFDaEQsZ0NBQWdDLG1CQUFPLENBQUMsNEdBQTRCO0FBQ3BFLG1DQUFtQyxtQkFBTyxDQUFDLG9EQUFNO0FBQ2pELHFDQUFxQyxpQ0FBaUM7QUFDdEUsb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsMENBQTBDLCtCQUErQixvQkFBb0IsbUNBQW1DLG9DQUFvQyx1RUFBdUU7QUFDelEsbUJBQW1CLDZDQUE2QyxhQUFhO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxlQUFlO0FBQ2pCLG1CQUFtQixpQkFBaUIsd0JBQXdCO0FBQzVELG1CQUFtQix5QkFBeUIsa0NBQWtDO0FBQzlFLDhCQUE4Qiw0QkFBNEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGVBQWUsMERBQTBEO0FBQ3pFLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxZQUFZO0FBQzFCO0FBQ0Esd0NBQXdDLHdCQUF3QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3oxMHRyaWFnZS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvR3JpZEl0ZW0uanM/NDE0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZShcInJlYWN0LWRvbVwiKTtcbnZhciBfcHJvcFR5cGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicHJvcC10eXBlc1wiKSk7XG52YXIgX3JlYWN0RHJhZ2dhYmxlID0gcmVxdWlyZShcInJlYWN0LWRyYWdnYWJsZVwiKTtcbnZhciBfcmVhY3RSZXNpemFibGUgPSByZXF1aXJlKFwicmVhY3QtcmVzaXphYmxlXCIpO1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIF9jYWxjdWxhdGVVdGlscyA9IHJlcXVpcmUoXCIuL2NhbGN1bGF0ZVV0aWxzXCIpO1xudmFyIF9SZWFjdEdyaWRMYXlvdXRQcm9wVHlwZXMgPSByZXF1aXJlKFwiLi9SZWFjdEdyaWRMYXlvdXRQcm9wVHlwZXNcIik7XG52YXIgX2Nsc3ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjbHN4XCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH07IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7IHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3JdID0gdCwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbi8qOjogaW1wb3J0IHR5cGUgeyBFbGVtZW50IGFzIFJlYWN0RWxlbWVudCwgTm9kZSBhcyBSZWFjdE5vZGUgfSBmcm9tIFwicmVhY3RcIjsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7XG4gIFJlYWN0RHJhZ2dhYmxlQ2FsbGJhY2tEYXRhLFxuICBHcmlkRHJhZ0V2ZW50LFxuICBHcmlkUmVzaXplRXZlbnQsXG4gIERyb3BwaW5nUG9zaXRpb24sXG4gIFBvc2l0aW9uLFxuICBSZXNpemVIYW5kbGVBeGlzXG59IGZyb20gXCIuL3V0aWxzXCI7Ki9cbi8qOjogaW1wb3J0IHR5cGUgeyBQb3NpdGlvblBhcmFtcyB9IGZyb20gXCIuL2NhbGN1bGF0ZVV0aWxzXCI7Ki9cbi8qOjogaW1wb3J0IHR5cGUgeyBSZXNpemVIYW5kbGUsIFJlYWN0UmVmIH0gZnJvbSBcIi4vUmVhY3RHcmlkTGF5b3V0UHJvcFR5cGVzXCI7Ki9cbi8qOjogdHlwZSBQYXJ0aWFsUG9zaXRpb24gPSB7IHRvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIgfTsqL1xuLyo6OiB0eXBlIEdyaWRJdGVtQ2FsbGJhY2s8RGF0YTogR3JpZERyYWdFdmVudCB8IEdyaWRSZXNpemVFdmVudD4gPSAoXG4gIGk6IHN0cmluZyxcbiAgdzogbnVtYmVyLFxuICBoOiBudW1iZXIsXG4gIERhdGFcbikgPT4gdm9pZDsqL1xuLyo6OiB0eXBlIFJlc2l6ZUNhbGxiYWNrRGF0YSA9IHtcbiAgbm9kZTogSFRNTEVsZW1lbnQsXG4gIHNpemU6IFBvc2l0aW9uLFxuICBoYW5kbGU6IFJlc2l6ZUhhbmRsZUF4aXNcbn07Ki9cbi8qOjogdHlwZSBHcmlkSXRlbVJlc2l6ZUNhbGxiYWNrID0gKFxuICBlOiBFdmVudCxcbiAgZGF0YTogUmVzaXplQ2FsbGJhY2tEYXRhLFxuICBwb3NpdGlvbjogUG9zaXRpb25cbikgPT4gdm9pZDsqL1xuLyo6OiB0eXBlIFN0YXRlID0ge1xuICByZXNpemluZzogP3sgdG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfSxcbiAgZHJhZ2dpbmc6ID97IHRvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIgfSxcbiAgY2xhc3NOYW1lOiBzdHJpbmdcbn07Ki9cbi8qOjogdHlwZSBQcm9wcyA9IHtcbiAgY2hpbGRyZW46IFJlYWN0RWxlbWVudDxhbnk+LFxuICBjb2xzOiBudW1iZXIsXG4gIGNvbnRhaW5lcldpZHRoOiBudW1iZXIsXG4gIG1hcmdpbjogW251bWJlciwgbnVtYmVyXSxcbiAgY29udGFpbmVyUGFkZGluZzogW251bWJlciwgbnVtYmVyXSxcbiAgcm93SGVpZ2h0OiBudW1iZXIsXG4gIG1heFJvd3M6IG51bWJlcixcbiAgaXNEcmFnZ2FibGU6IGJvb2xlYW4sXG4gIGlzUmVzaXphYmxlOiBib29sZWFuLFxuICBpc0JvdW5kZWQ6IGJvb2xlYW4sXG4gIHN0YXRpYz86IGJvb2xlYW4sXG4gIHVzZUNTU1RyYW5zZm9ybXM/OiBib29sZWFuLFxuICB1c2VQZXJjZW50YWdlcz86IGJvb2xlYW4sXG4gIHRyYW5zZm9ybVNjYWxlOiBudW1iZXIsXG4gIGRyb3BwaW5nUG9zaXRpb24/OiBEcm9wcGluZ1Bvc2l0aW9uLFxuXG4gIGNsYXNzTmFtZTogc3RyaW5nLFxuICBzdHlsZT86IE9iamVjdCxcbiAgLy8gRHJhZ2dhYmlsaXR5XG4gIGNhbmNlbDogc3RyaW5nLFxuICBoYW5kbGU6IHN0cmluZyxcblxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlcixcbiAgdzogbnVtYmVyLFxuICBoOiBudW1iZXIsXG5cbiAgbWluVzogbnVtYmVyLFxuICBtYXhXOiBudW1iZXIsXG4gIG1pbkg6IG51bWJlcixcbiAgbWF4SDogbnVtYmVyLFxuICBpOiBzdHJpbmcsXG5cbiAgcmVzaXplSGFuZGxlcz86IFJlc2l6ZUhhbmRsZUF4aXNbXSxcbiAgcmVzaXplSGFuZGxlPzogUmVzaXplSGFuZGxlLFxuXG4gIG9uRHJhZz86IEdyaWRJdGVtQ2FsbGJhY2s8R3JpZERyYWdFdmVudD4sXG4gIG9uRHJhZ1N0YXJ0PzogR3JpZEl0ZW1DYWxsYmFjazxHcmlkRHJhZ0V2ZW50PixcbiAgb25EcmFnU3RvcD86IEdyaWRJdGVtQ2FsbGJhY2s8R3JpZERyYWdFdmVudD4sXG4gIG9uUmVzaXplPzogR3JpZEl0ZW1DYWxsYmFjazxHcmlkUmVzaXplRXZlbnQ+LFxuICBvblJlc2l6ZVN0YXJ0PzogR3JpZEl0ZW1DYWxsYmFjazxHcmlkUmVzaXplRXZlbnQ+LFxuICBvblJlc2l6ZVN0b3A/OiBHcmlkSXRlbUNhbGxiYWNrPEdyaWRSZXNpemVFdmVudD5cbn07Ki9cbi8qOjogdHlwZSBEZWZhdWx0UHJvcHMgPSB7XG4gIGNsYXNzTmFtZTogc3RyaW5nLFxuICBjYW5jZWw6IHN0cmluZyxcbiAgaGFuZGxlOiBzdHJpbmcsXG4gIG1pbkg6IG51bWJlcixcbiAgbWluVzogbnVtYmVyLFxuICBtYXhIOiBudW1iZXIsXG4gIG1heFc6IG51bWJlcixcbiAgdHJhbnNmb3JtU2NhbGU6IG51bWJlclxufTsqL1xuLyoqXG4gKiBBbiBpbmRpdmlkdWFsIGl0ZW0gd2l0aGluIGEgUmVhY3RHcmlkTGF5b3V0LlxuICovXG5jbGFzcyBHcmlkSXRlbSBleHRlbmRzIF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCAvKjo6IDxQcm9wcywgU3RhdGU+Ki97XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwge1xuICAgICAgcmVzaXppbmc6IG51bGwsXG4gICAgICBkcmFnZ2luZzogbnVsbCxcbiAgICAgIGNsYXNzTmFtZTogXCJcIlxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVsZW1lbnRSZWZcIiwgLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZVJlZigpKTtcbiAgICAvKipcbiAgICAgKiBvbkRyYWdTdGFydCBldmVudCBoYW5kbGVyXG4gICAgICogQHBhcmFtICB7RXZlbnR9ICBlICAgICAgICAgICAgIGV2ZW50IGRhdGFcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGNhbGxiYWNrRGF0YSAgYW4gb2JqZWN0IHdpdGggbm9kZSwgZGVsdGEgYW5kIHBvc2l0aW9uIGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25EcmFnU3RhcnRcIiwgKGUsIF9yZWYpID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIG5vZGVcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvbkRyYWdTdGFydCxcbiAgICAgICAgdHJhbnNmb3JtU2NhbGVcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgaWYgKCFvbkRyYWdTdGFydCkgcmV0dXJuO1xuICAgICAgY29uc3QgbmV3UG9zaXRpb24gLyo6IFBhcnRpYWxQb3NpdGlvbiovID0ge1xuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDBcbiAgICAgIH07XG5cbiAgICAgIC8vIFRPRE86IHRoaXMgd29udCB3b3JrIG9uIG5lc3RlZCBwYXJlbnRzXG4gICAgICBjb25zdCB7XG4gICAgICAgIG9mZnNldFBhcmVudFxuICAgICAgfSA9IG5vZGU7XG4gICAgICBpZiAoIW9mZnNldFBhcmVudCkgcmV0dXJuO1xuICAgICAgY29uc3QgcGFyZW50UmVjdCA9IG9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGNsaWVudFJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY0xlZnQgPSBjbGllbnRSZWN0LmxlZnQgLyB0cmFuc2Zvcm1TY2FsZTtcbiAgICAgIGNvbnN0IHBMZWZ0ID0gcGFyZW50UmVjdC5sZWZ0IC8gdHJhbnNmb3JtU2NhbGU7XG4gICAgICBjb25zdCBjVG9wID0gY2xpZW50UmVjdC50b3AgLyB0cmFuc2Zvcm1TY2FsZTtcbiAgICAgIGNvbnN0IHBUb3AgPSBwYXJlbnRSZWN0LnRvcCAvIHRyYW5zZm9ybVNjYWxlO1xuICAgICAgbmV3UG9zaXRpb24ubGVmdCA9IGNMZWZ0IC0gcExlZnQgKyBvZmZzZXRQYXJlbnQuc2Nyb2xsTGVmdDtcbiAgICAgIG5ld1Bvc2l0aW9uLnRvcCA9IGNUb3AgLSBwVG9wICsgb2Zmc2V0UGFyZW50LnNjcm9sbFRvcDtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBkcmFnZ2luZzogbmV3UG9zaXRpb25cbiAgICAgIH0pO1xuXG4gICAgICAvLyBDYWxsIGNhbGxiYWNrIHdpdGggdGhpcyBkYXRhXG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNhbGNYWSkodGhpcy5nZXRQb3NpdGlvblBhcmFtcygpLCBuZXdQb3NpdGlvbi50b3AsIG5ld1Bvc2l0aW9uLmxlZnQsIHRoaXMucHJvcHMudywgdGhpcy5wcm9wcy5oKTtcbiAgICAgIHJldHVybiBvbkRyYWdTdGFydC5jYWxsKHRoaXMsIHRoaXMucHJvcHMuaSwgeCwgeSwge1xuICAgICAgICBlLFxuICAgICAgICBub2RlLFxuICAgICAgICBuZXdQb3NpdGlvblxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogb25EcmFnIGV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0gIHtFdmVudH0gIGUgICAgICAgICAgICAgZXZlbnQgZGF0YVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gY2FsbGJhY2tEYXRhICBhbiBvYmplY3Qgd2l0aCBub2RlLCBkZWx0YSBhbmQgcG9zaXRpb24gaW5mb3JtYXRpb25cbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSBkb250Rmx1c2ggICAgaWYgdHJ1ZSwgd2lsbCBub3QgY2FsbCBmbHVzaFN5bmNcbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkRyYWdcIiwgKGUsIF9yZWYyLCBkb250Rmx1c2gpID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIGRlbHRhWCxcbiAgICAgICAgZGVsdGFZXG4gICAgICB9ID0gX3JlZjI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uRHJhZ1xuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAoIW9uRHJhZykgcmV0dXJuO1xuICAgICAgaWYgKCF0aGlzLnN0YXRlLmRyYWdnaW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9uRHJhZyBjYWxsZWQgYmVmb3JlIG9uRHJhZ1N0YXJ0LlwiKTtcbiAgICAgIH1cbiAgICAgIGxldCB0b3AgPSB0aGlzLnN0YXRlLmRyYWdnaW5nLnRvcCArIGRlbHRhWTtcbiAgICAgIGxldCBsZWZ0ID0gdGhpcy5zdGF0ZS5kcmFnZ2luZy5sZWZ0ICsgZGVsdGFYO1xuICAgICAgY29uc3Qge1xuICAgICAgICBpc0JvdW5kZWQsXG4gICAgICAgIGksXG4gICAgICAgIHcsXG4gICAgICAgIGgsXG4gICAgICAgIGNvbnRhaW5lcldpZHRoXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IHBvc2l0aW9uUGFyYW1zID0gdGhpcy5nZXRQb3NpdGlvblBhcmFtcygpO1xuXG4gICAgICAvLyBCb3VuZGFyeSBjYWxjdWxhdGlvbnM7IGtlZXBzIGl0ZW1zIHdpdGhpbiB0aGUgZ3JpZFxuICAgICAgaWYgKGlzQm91bmRlZCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgb2Zmc2V0UGFyZW50XG4gICAgICAgIH0gPSBub2RlO1xuICAgICAgICBpZiAob2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgbWFyZ2luLFxuICAgICAgICAgICAgcm93SGVpZ2h0XG4gICAgICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgY29uc3QgYm90dG9tQm91bmRhcnkgPSBvZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IC0gKDAsIF9jYWxjdWxhdGVVdGlscy5jYWxjR3JpZEl0ZW1XSFB4KShoLCByb3dIZWlnaHQsIG1hcmdpblsxXSk7XG4gICAgICAgICAgdG9wID0gKDAsIF9jYWxjdWxhdGVVdGlscy5jbGFtcCkodG9wLCAwLCBib3R0b21Cb3VuZGFyeSk7XG4gICAgICAgICAgY29uc3QgY29sV2lkdGggPSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNhbGNHcmlkQ29sV2lkdGgpKHBvc2l0aW9uUGFyYW1zKTtcbiAgICAgICAgICBjb25zdCByaWdodEJvdW5kYXJ5ID0gY29udGFpbmVyV2lkdGggLSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNhbGNHcmlkSXRlbVdIUHgpKHcsIGNvbFdpZHRoLCBtYXJnaW5bMF0pO1xuICAgICAgICAgIGxlZnQgPSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNsYW1wKShsZWZ0LCAwLCByaWdodEJvdW5kYXJ5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbmV3UG9zaXRpb24gLyo6IFBhcnRpYWxQb3NpdGlvbiovID0ge1xuICAgICAgICB0b3AsXG4gICAgICAgIGxlZnRcbiAgICAgIH07XG5cbiAgICAgIC8vIGRvbnRGbHVzaCBpcyBzZXQgaWYgd2UncmUgY2FsbGluZyBmcm9tIGluc2lkZVxuICAgICAgaWYgKGRvbnRGbHVzaCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBkcmFnZ2luZzogbmV3UG9zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoMCwgX3JlYWN0RG9tLmZsdXNoU3luYykoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgZHJhZ2dpbmc6IG5ld1Bvc2l0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBDYWxsIGNhbGxiYWNrIHdpdGggdGhpcyBkYXRhXG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNhbGNYWSkocG9zaXRpb25QYXJhbXMsIHRvcCwgbGVmdCwgdywgaCk7XG4gICAgICByZXR1cm4gb25EcmFnLmNhbGwodGhpcywgaSwgeCwgeSwge1xuICAgICAgICBlLFxuICAgICAgICBub2RlLFxuICAgICAgICBuZXdQb3NpdGlvblxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogb25EcmFnU3RvcCBldmVudCBoYW5kbGVyXG4gICAgICogQHBhcmFtICB7RXZlbnR9ICBlICAgICAgICAgICAgIGV2ZW50IGRhdGFcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGNhbGxiYWNrRGF0YSAgYW4gb2JqZWN0IHdpdGggbm9kZSwgZGVsdGEgYW5kIHBvc2l0aW9uIGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25EcmFnU3RvcFwiLCAoZSwgX3JlZjMpID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIG5vZGVcbiAgICAgIH0gPSBfcmVmMztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb25EcmFnU3RvcFxuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAoIW9uRHJhZ1N0b3ApIHJldHVybjtcbiAgICAgIGlmICghdGhpcy5zdGF0ZS5kcmFnZ2luZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvbkRyYWdFbmQgY2FsbGVkIGJlZm9yZSBvbkRyYWdTdGFydC5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIHcsXG4gICAgICAgIGgsXG4gICAgICAgIGlcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBsZWZ0LFxuICAgICAgICB0b3BcbiAgICAgIH0gPSB0aGlzLnN0YXRlLmRyYWdnaW5nO1xuICAgICAgY29uc3QgbmV3UG9zaXRpb24gLyo6IFBhcnRpYWxQb3NpdGlvbiovID0ge1xuICAgICAgICB0b3AsXG4gICAgICAgIGxlZnRcbiAgICAgIH07XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgZHJhZ2dpbmc6IG51bGxcbiAgICAgIH0pO1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gKDAsIF9jYWxjdWxhdGVVdGlscy5jYWxjWFkpKHRoaXMuZ2V0UG9zaXRpb25QYXJhbXMoKSwgdG9wLCBsZWZ0LCB3LCBoKTtcbiAgICAgIHJldHVybiBvbkRyYWdTdG9wLmNhbGwodGhpcywgaSwgeCwgeSwge1xuICAgICAgICBlLFxuICAgICAgICBub2RlLFxuICAgICAgICBuZXdQb3NpdGlvblxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogb25SZXNpemVTdG9wIGV2ZW50IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0gIHtFdmVudH0gIGUgICAgICAgICAgICAgZXZlbnQgZGF0YVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gY2FsbGJhY2tEYXRhICBhbiBvYmplY3Qgd2l0aCBub2RlIGFuZCBzaXplIGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25SZXNpemVTdG9wXCIsIChlLCBjYWxsYmFja0RhdGEsIHBvc2l0aW9uKSA9PiB0aGlzLm9uUmVzaXplSGFuZGxlcihlLCBjYWxsYmFja0RhdGEsIHBvc2l0aW9uLCBcIm9uUmVzaXplU3RvcFwiKSk7XG4gICAgLy8gb25SZXNpemVTdGFydCBldmVudCBoYW5kbGVyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25SZXNpemVTdGFydFwiLCAoZSwgY2FsbGJhY2tEYXRhLCBwb3NpdGlvbikgPT4gdGhpcy5vblJlc2l6ZUhhbmRsZXIoZSwgY2FsbGJhY2tEYXRhLCBwb3NpdGlvbiwgXCJvblJlc2l6ZVN0YXJ0XCIpKTtcbiAgICAvLyBvblJlc2l6ZSBldmVudCBoYW5kbGVyXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25SZXNpemVcIiwgKGUsIGNhbGxiYWNrRGF0YSwgcG9zaXRpb24pID0+IHRoaXMub25SZXNpemVIYW5kbGVyKGUsIGNhbGxiYWNrRGF0YSwgcG9zaXRpb24sIFwib25SZXNpemVcIikpO1xuICB9XG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMgLyo6IFByb3BzKi8sIG5leHRTdGF0ZSAvKjogU3RhdGUqLykgLyo6IGJvb2xlYW4qL3tcbiAgICAvLyBXZSBjYW4ndCBkZWVwbHkgY29tcGFyZSBjaGlsZHJlbi4gSWYgdGhlIGRldmVsb3BlciBtZW1vaXplcyB0aGVtLCB3ZSBjYW5cbiAgICAvLyB1c2UgdGhpcyBvcHRpbWl6YXRpb24uXG4gICAgaWYgKHRoaXMucHJvcHMuY2hpbGRyZW4gIT09IG5leHRQcm9wcy5jaGlsZHJlbikgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMucHJvcHMuZHJvcHBpbmdQb3NpdGlvbiAhPT0gbmV4dFByb3BzLmRyb3BwaW5nUG9zaXRpb24pIHJldHVybiB0cnVlO1xuICAgIC8vIFRPRE8gbWVtb2l6ZSB0aGVzZSBjYWxjdWxhdGlvbnMgc28gdGhleSBkb24ndCB0YWtlIHNvIGxvbmc/XG4gICAgY29uc3Qgb2xkUG9zaXRpb24gPSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNhbGNHcmlkSXRlbVBvc2l0aW9uKSh0aGlzLmdldFBvc2l0aW9uUGFyYW1zKHRoaXMucHJvcHMpLCB0aGlzLnByb3BzLngsIHRoaXMucHJvcHMueSwgdGhpcy5wcm9wcy53LCB0aGlzLnByb3BzLmgsIHRoaXMuc3RhdGUpO1xuICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gKDAsIF9jYWxjdWxhdGVVdGlscy5jYWxjR3JpZEl0ZW1Qb3NpdGlvbikodGhpcy5nZXRQb3NpdGlvblBhcmFtcyhuZXh0UHJvcHMpLCBuZXh0UHJvcHMueCwgbmV4dFByb3BzLnksIG5leHRQcm9wcy53LCBuZXh0UHJvcHMuaCwgbmV4dFN0YXRlKTtcbiAgICByZXR1cm4gISgwLCBfdXRpbHMuZmFzdFBvc2l0aW9uRXF1YWwpKG9sZFBvc2l0aW9uLCBuZXdQb3NpdGlvbikgfHwgdGhpcy5wcm9wcy51c2VDU1NUcmFuc2Zvcm1zICE9PSBuZXh0UHJvcHMudXNlQ1NTVHJhbnNmb3JtcztcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLm1vdmVEcm9wcGluZ0l0ZW0oe30pO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMgLyo6IFByb3BzKi8pIHtcbiAgICB0aGlzLm1vdmVEcm9wcGluZ0l0ZW0ocHJldlByb3BzKTtcbiAgfVxuXG4gIC8vIFdoZW4gYSBkcm9wcGluZ1Bvc2l0aW9uIGlzIHByZXNlbnQsIHRoaXMgbWVhbnMgd2Ugc2hvdWxkIGZpcmUgYSBtb3ZlIGV2ZW50LCBhcyBpZiB3ZSBoYWQgbW92ZWRcbiAgLy8gdGhpcyBlbGVtZW50IGJ5IGB4LCB5YCBwaXhlbHMuXG4gIG1vdmVEcm9wcGluZ0l0ZW0ocHJldlByb3BzIC8qOiBQcm9wcyovKSB7XG4gICAgY29uc3Qge1xuICAgICAgZHJvcHBpbmdQb3NpdGlvblxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmICghZHJvcHBpbmdQb3NpdGlvbikgcmV0dXJuO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmVsZW1lbnRSZWYuY3VycmVudDtcbiAgICAvLyBDYW4ndCBmaW5kIERPTSBub2RlIChhcmUgd2UgdW5tb3VudGVkPylcbiAgICBpZiAoIW5vZGUpIHJldHVybjtcbiAgICBjb25zdCBwcmV2RHJvcHBpbmdQb3NpdGlvbiA9IHByZXZQcm9wcy5kcm9wcGluZ1Bvc2l0aW9uIHx8IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIGRyYWdnaW5nXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qgc2hvdWxkRHJhZyA9IGRyYWdnaW5nICYmIGRyb3BwaW5nUG9zaXRpb24ubGVmdCAhPT0gcHJldkRyb3BwaW5nUG9zaXRpb24ubGVmdCB8fCBkcm9wcGluZ1Bvc2l0aW9uLnRvcCAhPT0gcHJldkRyb3BwaW5nUG9zaXRpb24udG9wO1xuICAgIGlmICghZHJhZ2dpbmcpIHtcbiAgICAgIHRoaXMub25EcmFnU3RhcnQoZHJvcHBpbmdQb3NpdGlvbi5lLCB7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIGRlbHRhWDogZHJvcHBpbmdQb3NpdGlvbi5sZWZ0LFxuICAgICAgICBkZWx0YVk6IGRyb3BwaW5nUG9zaXRpb24udG9wXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHNob3VsZERyYWcpIHtcbiAgICAgIGNvbnN0IGRlbHRhWCA9IGRyb3BwaW5nUG9zaXRpb24ubGVmdCAtIGRyYWdnaW5nLmxlZnQ7XG4gICAgICBjb25zdCBkZWx0YVkgPSBkcm9wcGluZ1Bvc2l0aW9uLnRvcCAtIGRyYWdnaW5nLnRvcDtcbiAgICAgIHRoaXMub25EcmFnKGRyb3BwaW5nUG9zaXRpb24uZSwge1xuICAgICAgICBub2RlLFxuICAgICAgICBkZWx0YVgsXG4gICAgICAgIGRlbHRhWVxuICAgICAgfSwgdHJ1ZSAvLyBkb250Rkx1c2g6IGF2b2lkIGZsdXNoU3luYyB0byB0ZW1wZXIgd2FybmluZ3NcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGdldFBvc2l0aW9uUGFyYW1zKCkgLyo6IFBvc2l0aW9uUGFyYW1zKi97XG4gICAgbGV0IHByb3BzIC8qOiBQcm9wcyovID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLnByb3BzO1xuICAgIHJldHVybiB7XG4gICAgICBjb2xzOiBwcm9wcy5jb2xzLFxuICAgICAgY29udGFpbmVyUGFkZGluZzogcHJvcHMuY29udGFpbmVyUGFkZGluZyxcbiAgICAgIGNvbnRhaW5lcldpZHRoOiBwcm9wcy5jb250YWluZXJXaWR0aCxcbiAgICAgIG1hcmdpbjogcHJvcHMubWFyZ2luLFxuICAgICAgbWF4Um93czogcHJvcHMubWF4Um93cyxcbiAgICAgIHJvd0hlaWdodDogcHJvcHMucm93SGVpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHdoZXJlIHdlIHNldCB0aGUgZ3JpZCBpdGVtJ3MgYWJzb2x1dGUgcGxhY2VtZW50LiBJdCBnZXRzIGEgbGl0dGxlIHRyaWNreSBiZWNhdXNlIHdlIHdhbnQgdG8gZG8gaXRcbiAgICogd2VsbCB3aGVuIHNlcnZlciByZW5kZXJpbmcsIGFuZCB0aGUgb25seSB3YXkgdG8gZG8gdGhhdCBwcm9wZXJseSBpcyB0byB1c2UgcGVyY2VudGFnZSB3aWR0aC9sZWZ0IGJlY2F1c2VcbiAgICogd2UgZG9uJ3Qga25vdyBleGFjdGx5IHdoYXQgdGhlIGJyb3dzZXIgdmlld3BvcnQgaXMuXG4gICAqIFVuZm9ydHVuYXRlbHksIENTUyBUcmFuc2Zvcm1zLCB3aGljaCBhcmUgZ3JlYXQgZm9yIHBlcmZvcm1hbmNlLCBicmVhayBpbiB0aGlzIGluc3RhbmNlIGJlY2F1c2UgYSBwZXJjZW50YWdlXG4gICAqIGxlZnQgaXMgcmVsYXRpdmUgdG8gdGhlIGl0ZW0gaXRzZWxmLCBub3QgaXRzIGNvbnRhaW5lciEgU28gd2UgY2Fubm90IHVzZSB0aGVtIG9uIHRoZSBzZXJ2ZXIgcmVuZGVyaW5nIHBhc3MuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gcG9zIFBvc2l0aW9uIG9iamVjdCB3aXRoIHdpZHRoLCBoZWlnaHQsIGxlZnQsIHRvcC5cbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgU3R5bGUgb2JqZWN0LlxuICAgKi9cbiAgY3JlYXRlU3R5bGUocG9zIC8qOiBQb3NpdGlvbiovKSAvKjogeyBba2V5OiBzdHJpbmddOiA/c3RyaW5nIH0qL3tcbiAgICBjb25zdCB7XG4gICAgICB1c2VQZXJjZW50YWdlcyxcbiAgICAgIGNvbnRhaW5lcldpZHRoLFxuICAgICAgdXNlQ1NTVHJhbnNmb3Jtc1xuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGxldCBzdHlsZTtcbiAgICAvLyBDU1MgVHJhbnNmb3JtcyBzdXBwb3J0IChkZWZhdWx0KVxuICAgIGlmICh1c2VDU1NUcmFuc2Zvcm1zKSB7XG4gICAgICBzdHlsZSA9ICgwLCBfdXRpbHMuc2V0VHJhbnNmb3JtKShwb3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0b3AsbGVmdCAoc2xvdylcbiAgICAgIHN0eWxlID0gKDAsIF91dGlscy5zZXRUb3BMZWZ0KShwb3MpO1xuXG4gICAgICAvLyBUaGlzIGlzIHVzZWQgZm9yIHNlcnZlciByZW5kZXJpbmcuXG4gICAgICBpZiAodXNlUGVyY2VudGFnZXMpIHtcbiAgICAgICAgc3R5bGUubGVmdCA9ICgwLCBfdXRpbHMucGVyYykocG9zLmxlZnQgLyBjb250YWluZXJXaWR0aCk7XG4gICAgICAgIHN0eWxlLndpZHRoID0gKDAsIF91dGlscy5wZXJjKShwb3Mud2lkdGggLyBjb250YWluZXJXaWR0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNaXggYSBEcmFnZ2FibGUgaW5zdGFuY2UgaW50byBhIGNoaWxkLlxuICAgKiBAcGFyYW0gIHtFbGVtZW50fSBjaGlsZCAgICBDaGlsZCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSAgICAgICAgICBDaGlsZCB3cmFwcGVkIGluIERyYWdnYWJsZS5cbiAgICovXG4gIG1peGluRHJhZ2dhYmxlKGNoaWxkIC8qOiBSZWFjdEVsZW1lbnQ8YW55PiovLCBpc0RyYWdnYWJsZSAvKjogYm9vbGVhbiovKSAvKjogUmVhY3RFbGVtZW50PGFueT4qL3tcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0RHJhZ2dhYmxlLkRyYWdnYWJsZUNvcmUsIHtcbiAgICAgIGRpc2FibGVkOiAhaXNEcmFnZ2FibGUsXG4gICAgICBvblN0YXJ0OiB0aGlzLm9uRHJhZ1N0YXJ0LFxuICAgICAgb25EcmFnOiB0aGlzLm9uRHJhZyxcbiAgICAgIG9uU3RvcDogdGhpcy5vbkRyYWdTdG9wLFxuICAgICAgaGFuZGxlOiB0aGlzLnByb3BzLmhhbmRsZSxcbiAgICAgIGNhbmNlbDogXCIucmVhY3QtcmVzaXphYmxlLWhhbmRsZVwiICsgKHRoaXMucHJvcHMuY2FuY2VsID8gXCIsXCIgKyB0aGlzLnByb3BzLmNhbmNlbCA6IFwiXCIpLFxuICAgICAgc2NhbGU6IHRoaXMucHJvcHMudHJhbnNmb3JtU2NhbGUsXG4gICAgICBub2RlUmVmOiB0aGlzLmVsZW1lbnRSZWZcbiAgICB9LCBjaGlsZCk7XG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0eSBmdW5jdGlvbiB0byBzZXR1cCBjYWxsYmFjayBoYW5kbGVyIGRlZmluaXRpb25zIGZvclxuICAgKiBzaW1pbGFyaWx5IHN0cnVjdHVyZWQgcmVzaXplIGV2ZW50cy5cbiAgICovXG4gIGN1cnJ5UmVzaXplSGFuZGxlcihwb3NpdGlvbiAvKjogUG9zaXRpb24qLywgaGFuZGxlciAvKjogRnVuY3Rpb24qLykgLyo6IEZ1bmN0aW9uKi97XG4gICAgcmV0dXJuIChlIC8qOiBFdmVudCovLCBkYXRhIC8qOiBSZXNpemVDYWxsYmFja0RhdGEqLykgPT4gLyo6IEZ1bmN0aW9uKi9oYW5kbGVyKGUsIGRhdGEsIHBvc2l0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNaXggYSBSZXNpemFibGUgaW5zdGFuY2UgaW50byBhIGNoaWxkLlxuICAgKiBAcGFyYW0gIHtFbGVtZW50fSBjaGlsZCAgICBDaGlsZCBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHBvc2l0aW9uICBQb3NpdGlvbiBvYmplY3QgKHBpeGVsIHZhbHVlcylcbiAgICogQHJldHVybiB7RWxlbWVudH0gICAgICAgICAgQ2hpbGQgd3JhcHBlZCBpbiBSZXNpemFibGUuXG4gICAqL1xuICBtaXhpblJlc2l6YWJsZShjaGlsZCAvKjogUmVhY3RFbGVtZW50PGFueT4qLywgcG9zaXRpb24gLyo6IFBvc2l0aW9uKi8sIGlzUmVzaXphYmxlIC8qOiBib29sZWFuKi8pIC8qOiBSZWFjdEVsZW1lbnQ8YW55Piove1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbHMsXG4gICAgICBtaW5XLFxuICAgICAgbWluSCxcbiAgICAgIG1heFcsXG4gICAgICBtYXhILFxuICAgICAgdHJhbnNmb3JtU2NhbGUsXG4gICAgICByZXNpemVIYW5kbGVzLFxuICAgICAgcmVzaXplSGFuZGxlXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgcG9zaXRpb25QYXJhbXMgPSB0aGlzLmdldFBvc2l0aW9uUGFyYW1zKCk7XG5cbiAgICAvLyBUaGlzIGlzIHRoZSBtYXggcG9zc2libGUgd2lkdGggLSBkb2Vzbid0IGdvIHRvIGluZmluaXR5IGJlY2F1c2Ugb2YgdGhlIHdpZHRoIG9mIHRoZSB3aW5kb3dcbiAgICBjb25zdCBtYXhXaWR0aCA9ICgwLCBfY2FsY3VsYXRlVXRpbHMuY2FsY0dyaWRJdGVtUG9zaXRpb24pKHBvc2l0aW9uUGFyYW1zLCAwLCAwLCBjb2xzLCAwKS53aWR0aDtcblxuICAgIC8vIENhbGN1bGF0ZSBtaW4vbWF4IGNvbnN0cmFpbnRzIHVzaW5nIG91ciBtaW4gJiBtYXhlc1xuICAgIGNvbnN0IG1pbnMgPSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNhbGNHcmlkSXRlbVBvc2l0aW9uKShwb3NpdGlvblBhcmFtcywgMCwgMCwgbWluVywgbWluSCk7XG4gICAgY29uc3QgbWF4ZXMgPSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNhbGNHcmlkSXRlbVBvc2l0aW9uKShwb3NpdGlvblBhcmFtcywgMCwgMCwgbWF4VywgbWF4SCk7XG4gICAgY29uc3QgbWluQ29uc3RyYWludHMgPSBbbWlucy53aWR0aCwgbWlucy5oZWlnaHRdO1xuICAgIGNvbnN0IG1heENvbnN0cmFpbnRzID0gW01hdGgubWluKG1heGVzLndpZHRoLCBtYXhXaWR0aCksIE1hdGgubWluKG1heGVzLmhlaWdodCwgSW5maW5pdHkpXTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0UmVzaXphYmxlLlJlc2l6YWJsZVxuICAgIC8vIFRoZXNlIGFyZSBvcHRzIGZvciB0aGUgcmVzaXplIGhhbmRsZSBpdHNlbGZcbiAgICAsIHtcbiAgICAgIGRyYWdnYWJsZU9wdHM6IHtcbiAgICAgICAgZGlzYWJsZWQ6ICFpc1Jlc2l6YWJsZVxuICAgICAgfSxcbiAgICAgIGNsYXNzTmFtZTogaXNSZXNpemFibGUgPyB1bmRlZmluZWQgOiBcInJlYWN0LXJlc2l6YWJsZS1oaWRlXCIsXG4gICAgICB3aWR0aDogcG9zaXRpb24ud2lkdGgsXG4gICAgICBoZWlnaHQ6IHBvc2l0aW9uLmhlaWdodCxcbiAgICAgIG1pbkNvbnN0cmFpbnRzOiBtaW5Db25zdHJhaW50cyxcbiAgICAgIG1heENvbnN0cmFpbnRzOiBtYXhDb25zdHJhaW50cyxcbiAgICAgIG9uUmVzaXplU3RvcDogdGhpcy5jdXJyeVJlc2l6ZUhhbmRsZXIocG9zaXRpb24sIHRoaXMub25SZXNpemVTdG9wKSxcbiAgICAgIG9uUmVzaXplU3RhcnQ6IHRoaXMuY3VycnlSZXNpemVIYW5kbGVyKHBvc2l0aW9uLCB0aGlzLm9uUmVzaXplU3RhcnQpLFxuICAgICAgb25SZXNpemU6IHRoaXMuY3VycnlSZXNpemVIYW5kbGVyKHBvc2l0aW9uLCB0aGlzLm9uUmVzaXplKSxcbiAgICAgIHRyYW5zZm9ybVNjYWxlOiB0cmFuc2Zvcm1TY2FsZSxcbiAgICAgIHJlc2l6ZUhhbmRsZXM6IHJlc2l6ZUhhbmRsZXMsXG4gICAgICBoYW5kbGU6IHJlc2l6ZUhhbmRsZVxuICAgIH0sIGNoaWxkKTtcbiAgfVxuICAvKipcbiAgICogV3JhcHBlciBhcm91bmQgcmVzaXplIGV2ZW50cyB0byBwcm92aWRlIG1vcmUgdXNlZnVsIGRhdGEuXG4gICAqL1xuICBvblJlc2l6ZUhhbmRsZXIoZSAvKjogRXZlbnQqLywgX3JlZjQgLyo6OiAqLyxcbiAgLy8gJ3NpemUnIGlzIHVwZGF0ZWQgcG9zaXRpb25cbiAgcG9zaXRpb24gLyo6IFBvc2l0aW9uKi8sXG4gIC8vIGV4aXN0aW5nIHBvc2l0aW9uXG4gIGhhbmRsZXJOYW1lIC8qOiBzdHJpbmcqLykgLyo6IHZvaWQqL3tcbiAgICBsZXQge1xuICAgICAgbm9kZSxcbiAgICAgIHNpemUsXG4gICAgICBoYW5kbGVcbiAgICB9IC8qOiBSZXNpemVDYWxsYmFja0RhdGEqLyA9IF9yZWY0IC8qOiBSZXNpemVDYWxsYmFja0RhdGEqLztcbiAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5wcm9wc1toYW5kbGVyTmFtZV07XG4gICAgaWYgKCFoYW5kbGVyKSByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBpLFxuICAgICAgbWF4SCxcbiAgICAgIG1pbkgsXG4gICAgICBjb250YWluZXJXaWR0aFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHtcbiAgICAgIG1pblcsXG4gICAgICBtYXhXXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBDbGFtcGluZyBvZiBkaW1lbnNpb25zIGJhc2VkIG9uIHJlc2l6ZSBkaXJlY3Rpb25cbiAgICBsZXQgdXBkYXRlZFNpemUgPSBzaXplO1xuICAgIGlmIChub2RlKSB7XG4gICAgICB1cGRhdGVkU2l6ZSA9ICgwLCBfdXRpbHMucmVzaXplSXRlbUluRGlyZWN0aW9uKShoYW5kbGUsIHBvc2l0aW9uLCBzaXplLCBjb250YWluZXJXaWR0aCk7XG4gICAgICAoMCwgX3JlYWN0RG9tLmZsdXNoU3luYykoKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICByZXNpemluZzogaGFuZGxlck5hbWUgPT09IFwib25SZXNpemVTdG9wXCIgPyBudWxsIDogdXBkYXRlZFNpemVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBHZXQgbmV3IFhZIGJhc2VkIG9uIHBpeGVsIHNpemVcbiAgICBsZXQge1xuICAgICAgdyxcbiAgICAgIGhcbiAgICB9ID0gKDAsIF9jYWxjdWxhdGVVdGlscy5jYWxjV0gpKHRoaXMuZ2V0UG9zaXRpb25QYXJhbXMoKSwgdXBkYXRlZFNpemUud2lkdGgsIHVwZGF0ZWRTaXplLmhlaWdodCwgeCwgeSwgaGFuZGxlKTtcblxuICAgIC8vIE1pbi9tYXggY2FwcGluZy5cbiAgICAvLyBtaW5XIHNob3VsZCBiZSBhdCBsZWFzdCAxIChUT0RPIHByb3BUeXBlcyB2YWxpZGF0aW9uPylcbiAgICB3ID0gKDAsIF9jYWxjdWxhdGVVdGlscy5jbGFtcCkodywgTWF0aC5tYXgobWluVywgMSksIG1heFcpO1xuICAgIGggPSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNsYW1wKShoLCBtaW5ILCBtYXhIKTtcbiAgICBoYW5kbGVyLmNhbGwodGhpcywgaSwgdywgaCwge1xuICAgICAgZSxcbiAgICAgIG5vZGUsXG4gICAgICBzaXplOiB1cGRhdGVkU2l6ZSxcbiAgICAgIGhhbmRsZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIC8qOiBSZWFjdE5vZGUqL3tcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHcsXG4gICAgICBoLFxuICAgICAgaXNEcmFnZ2FibGUsXG4gICAgICBpc1Jlc2l6YWJsZSxcbiAgICAgIGRyb3BwaW5nUG9zaXRpb24sXG4gICAgICB1c2VDU1NUcmFuc2Zvcm1zXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgcG9zID0gKDAsIF9jYWxjdWxhdGVVdGlscy5jYWxjR3JpZEl0ZW1Qb3NpdGlvbikodGhpcy5nZXRQb3NpdGlvblBhcmFtcygpLCB4LCB5LCB3LCBoLCB0aGlzLnN0YXRlKTtcbiAgICBjb25zdCBjaGlsZCA9IF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbik7XG5cbiAgICAvLyBDcmVhdGUgdGhlIGNoaWxkIGVsZW1lbnQuIFdlIGNsb25lIHRoZSBleGlzdGluZyBlbGVtZW50IGJ1dCBtb2RpZnkgaXRzIGNsYXNzTmFtZSBhbmQgc3R5bGUuXG4gICAgbGV0IG5ld0NoaWxkID0gLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgcmVmOiB0aGlzLmVsZW1lbnRSZWYsXG4gICAgICBjbGFzc05hbWU6ICgwLCBfY2xzeC5kZWZhdWx0KShcInJlYWN0LWdyaWQtaXRlbVwiLCBjaGlsZC5wcm9wcy5jbGFzc05hbWUsIHRoaXMucHJvcHMuY2xhc3NOYW1lLCB7XG4gICAgICAgIHN0YXRpYzogdGhpcy5wcm9wcy5zdGF0aWMsXG4gICAgICAgIHJlc2l6aW5nOiBCb29sZWFuKHRoaXMuc3RhdGUucmVzaXppbmcpLFxuICAgICAgICBcInJlYWN0LWRyYWdnYWJsZVwiOiBpc0RyYWdnYWJsZSxcbiAgICAgICAgXCJyZWFjdC1kcmFnZ2FibGUtZHJhZ2dpbmdcIjogQm9vbGVhbih0aGlzLnN0YXRlLmRyYWdnaW5nKSxcbiAgICAgICAgZHJvcHBpbmc6IEJvb2xlYW4oZHJvcHBpbmdQb3NpdGlvbiksXG4gICAgICAgIGNzc1RyYW5zZm9ybXM6IHVzZUNTU1RyYW5zZm9ybXNcbiAgICAgIH0pLFxuICAgICAgLy8gV2UgY2FuIHNldCB0aGUgd2lkdGggYW5kIGhlaWdodCBvbiB0aGUgY2hpbGQsIGJ1dCB1bmZvcnR1bmF0ZWx5IHdlIGNhbid0IHNldCB0aGUgcG9zaXRpb24uXG4gICAgICBzdHlsZToge1xuICAgICAgICAuLi50aGlzLnByb3BzLnN0eWxlLFxuICAgICAgICAuLi5jaGlsZC5wcm9wcy5zdHlsZSxcbiAgICAgICAgLi4udGhpcy5jcmVhdGVTdHlsZShwb3MpXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBSZXNpemFibGUgc3VwcG9ydC4gVGhpcyBpcyB1c3VhbGx5IG9uIGJ1dCB0aGUgdXNlciBjYW4gdG9nZ2xlIGl0IG9mZi5cbiAgICBuZXdDaGlsZCA9IHRoaXMubWl4aW5SZXNpemFibGUobmV3Q2hpbGQsIHBvcywgaXNSZXNpemFibGUpO1xuXG4gICAgLy8gRHJhZ2dhYmxlIHN1cHBvcnQuIFRoaXMgaXMgYWx3YXlzIG9uLCBleGNlcHQgZm9yIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgIG5ld0NoaWxkID0gdGhpcy5taXhpbkRyYWdnYWJsZShuZXdDaGlsZCwgaXNEcmFnZ2FibGUpO1xuICAgIHJldHVybiBuZXdDaGlsZDtcbiAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gR3JpZEl0ZW07XG5fZGVmaW5lUHJvcGVydHkoR3JpZEl0ZW0sIFwicHJvcFR5cGVzXCIsIHtcbiAgLy8gQ2hpbGRyZW4gbXVzdCBiZSBvbmx5IGEgc2luZ2xlIGVsZW1lbnRcbiAgY2hpbGRyZW46IF9wcm9wVHlwZXMuZGVmYXVsdC5lbGVtZW50LFxuICAvLyBHZW5lcmFsIGdyaWQgYXR0cmlidXRlc1xuICBjb2xzOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGNvbnRhaW5lcldpZHRoOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLmlzUmVxdWlyZWQsXG4gIHJvd0hlaWdodDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlci5pc1JlcXVpcmVkLFxuICBtYXJnaW46IF9wcm9wVHlwZXMuZGVmYXVsdC5hcnJheS5pc1JlcXVpcmVkLFxuICBtYXhSb3dzOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGNvbnRhaW5lclBhZGRpbmc6IF9wcm9wVHlwZXMuZGVmYXVsdC5hcnJheS5pc1JlcXVpcmVkLFxuICAvLyBUaGVzZSBhcmUgYWxsIGluIGdyaWQgdW5pdHNcbiAgeDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlci5pc1JlcXVpcmVkLFxuICB5OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLmlzUmVxdWlyZWQsXG4gIHc6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIuaXNSZXF1aXJlZCxcbiAgaDogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlci5pc1JlcXVpcmVkLFxuICAvLyBBbGwgb3B0aW9uYWxcbiAgbWluVzogZnVuY3Rpb24gKHByb3BzIC8qOiBQcm9wcyovLCBwcm9wTmFtZSAvKjogc3RyaW5nKi8pIHtcbiAgICBjb25zdCB2YWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSByZXR1cm4gbmV3IEVycm9yKFwibWluV2lkdGggbm90IE51bWJlclwiKTtcbiAgICBpZiAodmFsdWUgPiBwcm9wcy53IHx8IHZhbHVlID4gcHJvcHMubWF4VykgcmV0dXJuIG5ldyBFcnJvcihcIm1pbldpZHRoIGxhcmdlciB0aGFuIGl0ZW0gd2lkdGgvbWF4V2lkdGhcIik7XG4gIH0sXG4gIG1heFc6IGZ1bmN0aW9uIChwcm9wcyAvKjogUHJvcHMqLywgcHJvcE5hbWUgLyo6IHN0cmluZyovKSB7XG4gICAgY29uc3QgdmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikgcmV0dXJuIG5ldyBFcnJvcihcIm1heFdpZHRoIG5vdCBOdW1iZXJcIik7XG4gICAgaWYgKHZhbHVlIDwgcHJvcHMudyB8fCB2YWx1ZSA8IHByb3BzLm1pblcpIHJldHVybiBuZXcgRXJyb3IoXCJtYXhXaWR0aCBzbWFsbGVyIHRoYW4gaXRlbSB3aWR0aC9taW5XaWR0aFwiKTtcbiAgfSxcbiAgbWluSDogZnVuY3Rpb24gKHByb3BzIC8qOiBQcm9wcyovLCBwcm9wTmFtZSAvKjogc3RyaW5nKi8pIHtcbiAgICBjb25zdCB2YWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSByZXR1cm4gbmV3IEVycm9yKFwibWluSGVpZ2h0IG5vdCBOdW1iZXJcIik7XG4gICAgaWYgKHZhbHVlID4gcHJvcHMuaCB8fCB2YWx1ZSA+IHByb3BzLm1heEgpIHJldHVybiBuZXcgRXJyb3IoXCJtaW5IZWlnaHQgbGFyZ2VyIHRoYW4gaXRlbSBoZWlnaHQvbWF4SGVpZ2h0XCIpO1xuICB9LFxuICBtYXhIOiBmdW5jdGlvbiAocHJvcHMgLyo6IFByb3BzKi8sIHByb3BOYW1lIC8qOiBzdHJpbmcqLykge1xuICAgIGNvbnN0IHZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHJldHVybiBuZXcgRXJyb3IoXCJtYXhIZWlnaHQgbm90IE51bWJlclwiKTtcbiAgICBpZiAodmFsdWUgPCBwcm9wcy5oIHx8IHZhbHVlIDwgcHJvcHMubWluSCkgcmV0dXJuIG5ldyBFcnJvcihcIm1heEhlaWdodCBzbWFsbGVyIHRoYW4gaXRlbSBoZWlnaHQvbWluSGVpZ2h0XCIpO1xuICB9LFxuICAvLyBJRCBpcyBuaWNlIHRvIGhhdmUgZm9yIGNhbGxiYWNrc1xuICBpOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLmlzUmVxdWlyZWQsXG4gIC8vIFJlc2l6ZSBoYW5kbGUgb3B0aW9uc1xuICByZXNpemVIYW5kbGVzOiBfUmVhY3RHcmlkTGF5b3V0UHJvcFR5cGVzLnJlc2l6ZUhhbmRsZUF4ZXNUeXBlLFxuICByZXNpemVIYW5kbGU6IF9SZWFjdEdyaWRMYXlvdXRQcm9wVHlwZXMucmVzaXplSGFuZGxlVHlwZSxcbiAgLy8gRnVuY3Rpb25zXG4gIG9uRHJhZ1N0b3A6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICBvbkRyYWdTdGFydDogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIG9uRHJhZzogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIG9uUmVzaXplU3RvcDogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIG9uUmVzaXplU3RhcnQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICBvblJlc2l6ZTogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8vIEZsYWdzXG4gIGlzRHJhZ2dhYmxlOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbC5pc1JlcXVpcmVkLFxuICBpc1Jlc2l6YWJsZTogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wuaXNSZXF1aXJlZCxcbiAgaXNCb3VuZGVkOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbC5pc1JlcXVpcmVkLFxuICBzdGF0aWM6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICAvLyBVc2UgQ1NTIHRyYW5zZm9ybXMgaW5zdGVhZCBvZiB0b3AvbGVmdFxuICB1c2VDU1NUcmFuc2Zvcm1zOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbC5pc1JlcXVpcmVkLFxuICB0cmFuc2Zvcm1TY2FsZTogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcixcbiAgLy8gT3RoZXJzXG4gIGNsYXNzTmFtZTogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgLy8gU2VsZWN0b3IgZm9yIGRyYWdnYWJsZSBoYW5kbGVcbiAgaGFuZGxlOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICAvLyBTZWxlY3RvciBmb3IgZHJhZ2dhYmxlIGNhbmNlbCAoc2VlIHJlYWN0LWRyYWdnYWJsZSlcbiAgY2FuY2VsOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICAvLyBDdXJyZW50IHBvc2l0aW9uIG9mIGEgZHJvcHBpbmcgZWxlbWVudFxuICBkcm9wcGluZ1Bvc2l0aW9uOiBfcHJvcFR5cGVzLmRlZmF1bHQuc2hhcGUoe1xuICAgIGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5vYmplY3QuaXNSZXF1aXJlZCxcbiAgICBsZWZ0OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgdG9wOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLmlzUmVxdWlyZWRcbiAgfSlcbn0pO1xuX2RlZmluZVByb3BlcnR5KEdyaWRJdGVtLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gIGNsYXNzTmFtZTogXCJcIixcbiAgY2FuY2VsOiBcIlwiLFxuICBoYW5kbGU6IFwiXCIsXG4gIG1pbkg6IDEsXG4gIG1pblc6IDEsXG4gIG1heEg6IEluZmluaXR5LFxuICBtYXhXOiBJbmZpbml0eSxcbiAgdHJhbnNmb3JtU2NhbGU6IDFcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/GridItem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/ReactGridLayout.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-grid-layout/build/ReactGridLayout.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _fastEquals = __webpack_require__(/*! fast-equals */ \"(ssr)/./node_modules/fast-equals/dist/fast-equals.esm.js\");\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.js\"));\nvar _utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-grid-layout/build/utils.js\");\nvar _calculateUtils = __webpack_require__(/*! ./calculateUtils */ \"(ssr)/./node_modules/react-grid-layout/build/calculateUtils.js\");\nvar _GridItem = _interopRequireDefault(__webpack_require__(/*! ./GridItem */ \"(ssr)/./node_modules/react-grid-layout/build/GridItem.js\"));\nvar _ReactGridLayoutPropTypes = _interopRequireDefault(__webpack_require__(/*! ./ReactGridLayoutPropTypes */ \"(ssr)/./node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) \"default\" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/*:: import type {\n  ChildrenArray as ReactChildrenArray,\n  Element as ReactElement\n} from \"react\";*/\n/*:: import type {\n  CompactType,\n  GridResizeEvent,\n  GridDragEvent,\n  DragOverEvent,\n  Layout,\n  DroppingPosition,\n  LayoutItem\n} from \"./utils\";*/\n// Types\n/*:: import type { PositionParams } from \"./calculateUtils\";*/\n/*:: type State = {\n  activeDrag: ?LayoutItem,\n  layout: Layout,\n  mounted: boolean,\n  oldDragItem: ?LayoutItem,\n  oldLayout: ?Layout,\n  oldResizeItem: ?LayoutItem,\n  resizing: boolean,\n  droppingDOMNode: ?ReactElement<any>,\n  droppingPosition?: DroppingPosition,\n  // Mirrored props\n  children: ReactChildrenArray<ReactElement<any>>,\n  compactType?: CompactType,\n  propsLayout?: Layout\n};*/\n/*:: import type { Props, DefaultProps } from \"./ReactGridLayoutPropTypes\";*/\n// End Types\nconst layoutClassName = \"react-grid-layout\";\nlet isFirefox = false;\n// Try...catch will protect from navigator not existing (e.g. node) or a bad implementation of navigator\ntry {\n  isFirefox = /firefox/i.test(navigator.userAgent);\n} catch (e) {\n  /* Ignore */\n}\n\n/**\n * A reactive, fluid grid layout with draggable, resizable components.\n */\n\nclass ReactGridLayout extends React.Component /*:: <Props, State>*/{\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", {\n      activeDrag: null,\n      layout: (0, _utils.synchronizeLayoutWithChildren)(this.props.layout, this.props.children, this.props.cols,\n      // Legacy support for verticalCompact: false\n      (0, _utils.compactType)(this.props), this.props.allowOverlap),\n      mounted: false,\n      oldDragItem: null,\n      oldLayout: null,\n      oldResizeItem: null,\n      resizing: false,\n      droppingDOMNode: null,\n      children: []\n    });\n    _defineProperty(this, \"dragEnterCounter\", 0);\n    /**\n     * When dragging starts\n     * @param {String} i Id of the child\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    _defineProperty(this, \"onDragStart\", (i /*: string*/, x /*: number*/, y /*: number*/, _ref /*:: */) => {\n      let {\n        e,\n        node\n      } /*: GridDragEvent*/ = _ref /*: GridDragEvent*/;\n      const {\n        layout\n      } = this.state;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n\n      // Create placeholder (display only)\n      const placeholder = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        placeholder: true,\n        i: i\n      };\n      this.setState({\n        oldDragItem: (0, _utils.cloneLayoutItem)(l),\n        oldLayout: layout,\n        activeDrag: placeholder\n      });\n      return this.props.onDragStart(layout, l, l, null, e, node);\n    });\n    /**\n     * Each drag movement create a new dragelement and move the element to the dragged location\n     * @param {String} i Id of the child\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    _defineProperty(this, \"onDrag\", (i, x, y, _ref2) => {\n      let {\n        e,\n        node\n      } = _ref2;\n      const {\n        oldDragItem\n      } = this.state;\n      let {\n        layout\n      } = this.state;\n      const {\n        cols,\n        allowOverlap,\n        preventCollision\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n\n      // Create placeholder (display only)\n      const placeholder = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        placeholder: true,\n        i: i\n      };\n\n      // Move the element to the dragged location.\n      const isUserAction = true;\n      layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);\n      this.props.onDrag(layout, oldDragItem, l, placeholder, e, node);\n      this.setState({\n        layout: allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols),\n        activeDrag: placeholder\n      });\n    });\n    /**\n     * When dragging stops, figure out which position the element is closest to and update its x and y.\n     * @param  {String} i Index of the child.\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    _defineProperty(this, \"onDragStop\", (i, x, y, _ref3) => {\n      let {\n        e,\n        node\n      } = _ref3;\n      if (!this.state.activeDrag) return;\n      const {\n        oldDragItem\n      } = this.state;\n      let {\n        layout\n      } = this.state;\n      const {\n        cols,\n        preventCollision,\n        allowOverlap\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n\n      // Move the element here\n      const isUserAction = true;\n      layout = (0, _utils.moveElement)(layout, l, x, y, isUserAction, preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);\n\n      // Set state\n      const newLayout = allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols);\n      this.props.onDragStop(newLayout, oldDragItem, l, null, e, node);\n      const {\n        oldLayout\n      } = this.state;\n      this.setState({\n        activeDrag: null,\n        layout: newLayout,\n        oldDragItem: null,\n        oldLayout: null\n      });\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    });\n    _defineProperty(this, \"onResizeStart\", (i, w, h, _ref4) => {\n      let {\n        e,\n        node\n      } = _ref4;\n      const {\n        layout\n      } = this.state;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n      if (!l) return;\n      this.setState({\n        oldResizeItem: (0, _utils.cloneLayoutItem)(l),\n        oldLayout: this.state.layout,\n        resizing: true\n      });\n      this.props.onResizeStart(layout, l, l, null, e, node);\n    });\n    _defineProperty(this, \"onResize\", (i, w, h, _ref5) => {\n      let {\n        e,\n        node,\n        size,\n        handle\n      } = _ref5;\n      const {\n        oldResizeItem\n      } = this.state;\n      const {\n        layout\n      } = this.state;\n      const {\n        cols,\n        preventCollision,\n        allowOverlap\n      } = this.props;\n      let shouldMoveItem = false;\n      let finalLayout;\n      let x;\n      let y;\n      const [newLayout, l] = (0, _utils.withLayoutItem)(layout, i, l => {\n        let hasCollisions;\n        x = l.x;\n        y = l.y;\n        if ([\"sw\", \"w\", \"nw\", \"n\", \"ne\"].indexOf(handle) !== -1) {\n          if ([\"sw\", \"nw\", \"w\"].indexOf(handle) !== -1) {\n            x = l.x + (l.w - w);\n            w = l.x !== x && x < 0 ? l.w : w;\n            x = x < 0 ? 0 : x;\n          }\n          if ([\"ne\", \"n\", \"nw\"].indexOf(handle) !== -1) {\n            y = l.y + (l.h - h);\n            h = l.y !== y && y < 0 ? l.h : h;\n            y = y < 0 ? 0 : y;\n          }\n          shouldMoveItem = true;\n        }\n\n        // Something like quad tree should be used\n        // to find collisions faster\n        if (preventCollision && !allowOverlap) {\n          const collisions = (0, _utils.getAllCollisions)(layout, {\n            ...l,\n            w,\n            h,\n            x,\n            y\n          }).filter(layoutItem => layoutItem.i !== l.i);\n          hasCollisions = collisions.length > 0;\n\n          // If we're colliding, we need adjust the placeholder.\n          if (hasCollisions) {\n            // Reset layoutItem dimensions if there were collisions\n            y = l.y;\n            h = l.h;\n            x = l.x;\n            w = l.w;\n            shouldMoveItem = false;\n          }\n        }\n        l.w = w;\n        l.h = h;\n        return l;\n      });\n\n      // Shouldn't ever happen, but typechecking makes it necessary\n      if (!l) return;\n      finalLayout = newLayout;\n      if (shouldMoveItem) {\n        // Move the element to the new position.\n        const isUserAction = true;\n        finalLayout = (0, _utils.moveElement)(newLayout, l, x, y, isUserAction, this.props.preventCollision, (0, _utils.compactType)(this.props), cols, allowOverlap);\n      }\n\n      // Create placeholder element (display only)\n      const placeholder = {\n        w: l.w,\n        h: l.h,\n        x: l.x,\n        y: l.y,\n        static: true,\n        i: i\n      };\n      this.props.onResize(finalLayout, oldResizeItem, l, placeholder, e, node);\n\n      // Re-compact the newLayout and set the drag placeholder.\n      this.setState({\n        layout: allowOverlap ? finalLayout : (0, _utils.compact)(finalLayout, (0, _utils.compactType)(this.props), cols),\n        activeDrag: placeholder\n      });\n    });\n    _defineProperty(this, \"onResizeStop\", (i, w, h, _ref6) => {\n      let {\n        e,\n        node\n      } = _ref6;\n      const {\n        layout,\n        oldResizeItem\n      } = this.state;\n      const {\n        cols,\n        allowOverlap\n      } = this.props;\n      const l = (0, _utils.getLayoutItem)(layout, i);\n\n      // Set state\n      const newLayout = allowOverlap ? layout : (0, _utils.compact)(layout, (0, _utils.compactType)(this.props), cols);\n      this.props.onResizeStop(newLayout, oldResizeItem, l, null, e, node);\n      const {\n        oldLayout\n      } = this.state;\n      this.setState({\n        activeDrag: null,\n        layout: newLayout,\n        oldResizeItem: null,\n        oldLayout: null,\n        resizing: false\n      });\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    });\n    // Called while dragging an element. Part of browser native drag/drop API.\n    // Native event target might be the layout itself, or an element within the layout.\n    _defineProperty(this, \"onDragOver\", e => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n\n      // we should ignore events from layout's children in Firefox\n      // to avoid unpredictable jumping of a dropping placeholder\n      // FIXME remove this hack\n      if (isFirefox &&\n      // $FlowIgnore can't figure this out\n      !e.nativeEvent.target?.classList.contains(layoutClassName)) {\n        return false;\n      }\n      const {\n        droppingItem,\n        onDropDragOver,\n        margin,\n        cols,\n        rowHeight,\n        maxRows,\n        width,\n        containerPadding,\n        transformScale\n      } = this.props;\n      // Allow user to customize the dropping item or short-circuit the drop based on the results\n      // of the `onDragOver(e: Event)` callback.\n      const onDragOverResult = onDropDragOver?.(e);\n      if (onDragOverResult === false) {\n        if (this.state.droppingDOMNode) {\n          this.removeDroppingPlaceholder();\n        }\n        return false;\n      }\n      const finalDroppingItem = {\n        ...droppingItem,\n        ...onDragOverResult\n      };\n      const {\n        layout\n      } = this.state;\n\n      // $FlowIgnore missing def\n      const gridRect = e.currentTarget.getBoundingClientRect(); // The grid's position in the viewport\n\n      // Calculate the mouse position relative to the grid\n      const layerX = e.clientX - gridRect.left;\n      const layerY = e.clientY - gridRect.top;\n      const droppingPosition = {\n        left: layerX / transformScale,\n        top: layerY / transformScale,\n        e\n      };\n      if (!this.state.droppingDOMNode) {\n        const positionParams /*: PositionParams*/ = {\n          cols,\n          margin,\n          maxRows,\n          rowHeight,\n          containerWidth: width,\n          containerPadding: containerPadding || margin\n        };\n        const calculatedPosition = (0, _calculateUtils.calcXY)(positionParams, layerY, layerX, finalDroppingItem.w, finalDroppingItem.h);\n        this.setState({\n          droppingDOMNode: /*#__PURE__*/React.createElement(\"div\", {\n            key: finalDroppingItem.i\n          }),\n          droppingPosition,\n          layout: [...layout, {\n            ...finalDroppingItem,\n            x: calculatedPosition.x,\n            y: calculatedPosition.y,\n            static: false,\n            isDraggable: true\n          }]\n        });\n      } else if (this.state.droppingPosition) {\n        const {\n          left,\n          top\n        } = this.state.droppingPosition;\n        const shouldUpdatePosition = left != layerX || top != layerY;\n        if (shouldUpdatePosition) {\n          this.setState({\n            droppingPosition\n          });\n        }\n      }\n    });\n    _defineProperty(this, \"removeDroppingPlaceholder\", () => {\n      const {\n        droppingItem,\n        cols\n      } = this.props;\n      const {\n        layout\n      } = this.state;\n      const newLayout = (0, _utils.compact)(layout.filter(l => l.i !== droppingItem.i), (0, _utils.compactType)(this.props), cols, this.props.allowOverlap);\n      this.setState({\n        layout: newLayout,\n        droppingDOMNode: null,\n        activeDrag: null,\n        droppingPosition: undefined\n      });\n    });\n    _defineProperty(this, \"onDragLeave\", e => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n      this.dragEnterCounter--;\n\n      // onDragLeave can be triggered on each layout's child.\n      // But we know that count of dragEnter and dragLeave events\n      // will be balanced after leaving the layout's container\n      // so we can increase and decrease count of dragEnter and\n      // when it'll be equal to 0 we'll remove the placeholder\n      if (this.dragEnterCounter === 0) {\n        this.removeDroppingPlaceholder();\n      }\n    });\n    _defineProperty(this, \"onDragEnter\", e => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n      this.dragEnterCounter++;\n    });\n    _defineProperty(this, \"onDrop\", (e /*: Event*/) => {\n      e.preventDefault(); // Prevent any browser native action\n      e.stopPropagation();\n      const {\n        droppingItem\n      } = this.props;\n      const {\n        layout\n      } = this.state;\n      const item = layout.find(l => l.i === droppingItem.i);\n\n      // reset dragEnter counter on drop\n      this.dragEnterCounter = 0;\n      this.removeDroppingPlaceholder();\n      this.props.onDrop(layout, item, e);\n    });\n  }\n  componentDidMount() {\n    this.setState({\n      mounted: true\n    });\n    // Possibly call back with layout on mount. This should be done after correcting the layout width\n    // to ensure we don't rerender with the wrong width.\n    this.onLayoutMaybeChanged(this.state.layout, this.props.layout);\n  }\n  static getDerivedStateFromProps(nextProps /*: Props*/, prevState /*: State*/) /*: $Shape<State> | null*/{\n    let newLayoutBase;\n    if (prevState.activeDrag) {\n      return null;\n    }\n\n    // Legacy support for compactType\n    // Allow parent to set layout directly.\n    if (!(0, _fastEquals.deepEqual)(nextProps.layout, prevState.propsLayout) || nextProps.compactType !== prevState.compactType) {\n      newLayoutBase = nextProps.layout;\n    } else if (!(0, _utils.childrenEqual)(nextProps.children, prevState.children)) {\n      // If children change, also regenerate the layout. Use our state\n      // as the base in case because it may be more up to date than\n      // what is in props.\n      newLayoutBase = prevState.layout;\n    }\n\n    // We need to regenerate the layout.\n    if (newLayoutBase) {\n      const newLayout = (0, _utils.synchronizeLayoutWithChildren)(newLayoutBase, nextProps.children, nextProps.cols, (0, _utils.compactType)(nextProps), nextProps.allowOverlap);\n      return {\n        layout: newLayout,\n        // We need to save these props to state for using\n        // getDerivedStateFromProps instead of componentDidMount (in which we would get extra rerender)\n        compactType: nextProps.compactType,\n        children: nextProps.children,\n        propsLayout: nextProps.layout\n      };\n    }\n    return null;\n  }\n  shouldComponentUpdate(nextProps /*: Props*/, nextState /*: State*/) /*: boolean*/{\n    return (\n      // NOTE: this is almost always unequal. Therefore the only way to get better performance\n      // from SCU is if the user intentionally memoizes children. If they do, and they can\n      // handle changes properly, performance will increase.\n      this.props.children !== nextProps.children || !(0, _utils.fastRGLPropsEqual)(this.props, nextProps, _fastEquals.deepEqual) || this.state.activeDrag !== nextState.activeDrag || this.state.mounted !== nextState.mounted || this.state.droppingPosition !== nextState.droppingPosition\n    );\n  }\n  componentDidUpdate(prevProps /*: Props*/, prevState /*: State*/) {\n    if (!this.state.activeDrag) {\n      const newLayout = this.state.layout;\n      const oldLayout = prevState.layout;\n      this.onLayoutMaybeChanged(newLayout, oldLayout);\n    }\n  }\n\n  /**\n   * Calculates a pixel value for the container.\n   * @return {String} Container height in pixels.\n   */\n  containerHeight() /*: ?string*/{\n    if (!this.props.autoSize) return;\n    const nbRow = (0, _utils.bottom)(this.state.layout);\n    const containerPaddingY = this.props.containerPadding ? this.props.containerPadding[1] : this.props.margin[1];\n    return nbRow * this.props.rowHeight + (nbRow - 1) * this.props.margin[1] + containerPaddingY * 2 + \"px\";\n  }\n  onLayoutMaybeChanged(newLayout /*: Layout*/, oldLayout /*: ?Layout*/) {\n    if (!oldLayout) oldLayout = this.state.layout;\n    if (!(0, _fastEquals.deepEqual)(oldLayout, newLayout)) {\n      this.props.onLayoutChange(newLayout);\n    }\n  }\n  /**\n   * Create a placeholder object.\n   * @return {Element} Placeholder div.\n   */\n  placeholder() /*: ?ReactElement<any>*/{\n    const {\n      activeDrag\n    } = this.state;\n    if (!activeDrag) return null;\n    const {\n      width,\n      cols,\n      margin,\n      containerPadding,\n      rowHeight,\n      maxRows,\n      useCSSTransforms,\n      transformScale\n    } = this.props;\n\n    // {...this.state.activeDrag} is pretty slow, actually\n    return /*#__PURE__*/React.createElement(_GridItem.default, {\n      w: activeDrag.w,\n      h: activeDrag.h,\n      x: activeDrag.x,\n      y: activeDrag.y,\n      i: activeDrag.i,\n      className: `react-grid-placeholder ${this.state.resizing ? \"placeholder-resizing\" : \"\"}`,\n      containerWidth: width,\n      cols: cols,\n      margin: margin,\n      containerPadding: containerPadding || margin,\n      maxRows: maxRows,\n      rowHeight: rowHeight,\n      isDraggable: false,\n      isResizable: false,\n      isBounded: false,\n      useCSSTransforms: useCSSTransforms,\n      transformScale: transformScale\n    }, /*#__PURE__*/React.createElement(\"div\", null));\n  }\n\n  /**\n   * Given a grid item, set its style attributes & surround in a <Draggable>.\n   * @param  {Element} child React element.\n   * @return {Element}       Element wrapped in draggable and properly placed.\n   */\n  processGridItem(child /*: ReactElement<any>*/, isDroppingItem /*: boolean*/) /*: ?ReactElement<any>*/{\n    if (!child || !child.key) return;\n    const l = (0, _utils.getLayoutItem)(this.state.layout, String(child.key));\n    if (!l) return null;\n    const {\n      width,\n      cols,\n      margin,\n      containerPadding,\n      rowHeight,\n      maxRows,\n      isDraggable,\n      isResizable,\n      isBounded,\n      useCSSTransforms,\n      transformScale,\n      draggableCancel,\n      draggableHandle,\n      resizeHandles,\n      resizeHandle\n    } = this.props;\n    const {\n      mounted,\n      droppingPosition\n    } = this.state;\n\n    // Determine user manipulations possible.\n    // If an item is static, it can't be manipulated by default.\n    // Any properties defined directly on the grid item will take precedence.\n    const draggable = typeof l.isDraggable === \"boolean\" ? l.isDraggable : !l.static && isDraggable;\n    const resizable = typeof l.isResizable === \"boolean\" ? l.isResizable : !l.static && isResizable;\n    const resizeHandlesOptions = l.resizeHandles || resizeHandles;\n\n    // isBounded set on child if set on parent, and child is not explicitly false\n    const bounded = draggable && isBounded && l.isBounded !== false;\n    return /*#__PURE__*/React.createElement(_GridItem.default, {\n      containerWidth: width,\n      cols: cols,\n      margin: margin,\n      containerPadding: containerPadding || margin,\n      maxRows: maxRows,\n      rowHeight: rowHeight,\n      cancel: draggableCancel,\n      handle: draggableHandle,\n      onDragStop: this.onDragStop,\n      onDragStart: this.onDragStart,\n      onDrag: this.onDrag,\n      onResizeStart: this.onResizeStart,\n      onResize: this.onResize,\n      onResizeStop: this.onResizeStop,\n      isDraggable: draggable,\n      isResizable: resizable,\n      isBounded: bounded,\n      useCSSTransforms: useCSSTransforms && mounted,\n      usePercentages: !mounted,\n      transformScale: transformScale,\n      w: l.w,\n      h: l.h,\n      x: l.x,\n      y: l.y,\n      i: l.i,\n      minH: l.minH,\n      minW: l.minW,\n      maxH: l.maxH,\n      maxW: l.maxW,\n      static: l.static,\n      droppingPosition: isDroppingItem ? droppingPosition : undefined,\n      resizeHandles: resizeHandlesOptions,\n      resizeHandle: resizeHandle\n    }, child);\n  }\n  render() /*: React.Element<\"div\">*/{\n    const {\n      className,\n      style,\n      isDroppable,\n      innerRef\n    } = this.props;\n    const mergedClassName = (0, _clsx.default)(layoutClassName, className);\n    const mergedStyle = {\n      height: this.containerHeight(),\n      ...style\n    };\n    return /*#__PURE__*/React.createElement(\"div\", {\n      ref: innerRef,\n      className: mergedClassName,\n      style: mergedStyle,\n      onDrop: isDroppable ? this.onDrop : _utils.noop,\n      onDragLeave: isDroppable ? this.onDragLeave : _utils.noop,\n      onDragEnter: isDroppable ? this.onDragEnter : _utils.noop,\n      onDragOver: isDroppable ? this.onDragOver : _utils.noop\n    }, React.Children.map(this.props.children, child => this.processGridItem(child)), isDroppable && this.state.droppingDOMNode && this.processGridItem(this.state.droppingDOMNode, true), this.placeholder());\n  }\n}\nexports[\"default\"] = ReactGridLayout;\n// TODO publish internal ReactClass displayName transform\n_defineProperty(ReactGridLayout, \"displayName\", \"ReactGridLayout\");\n// Refactored to another module to make way for preval\n_defineProperty(ReactGridLayout, \"propTypes\", _ReactGridLayoutPropTypes.default);\n_defineProperty(ReactGridLayout, \"defaultProps\", {\n  autoSize: true,\n  cols: 12,\n  className: \"\",\n  style: {},\n  draggableHandle: \"\",\n  draggableCancel: \"\",\n  containerPadding: null,\n  rowHeight: 150,\n  maxRows: Infinity,\n  // infinite vertical growth\n  layout: [],\n  margin: [10, 10],\n  isBounded: false,\n  isDraggable: true,\n  isResizable: true,\n  allowOverlap: false,\n  isDroppable: false,\n  useCSSTransforms: true,\n  transformScale: 1,\n  verticalCompact: true,\n  compactType: \"vertical\",\n  preventCollision: false,\n  droppingItem: {\n    i: \"__dropping-elem__\",\n    h: 1,\n    w: 1\n  },\n  resizeHandles: [\"se\"],\n  onLayoutChange: _utils.noop,\n  onDragStart: _utils.noop,\n  onDrag: _utils.noop,\n  onDragStop: _utils.noop,\n  onResizeStart: _utils.noop,\n  onResize: _utils.noop,\n  onResizeStop: _utils.noop,\n  onDrop: _utils.noop,\n  onDropDragOver: _utils.noop\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvUmVhY3RHcmlkTGF5b3V0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2Ysb0NBQW9DLG1CQUFPLENBQUMsd0dBQU87QUFDbkQsa0JBQWtCLG1CQUFPLENBQUMsNkVBQWE7QUFDdkMsbUNBQW1DLG1CQUFPLENBQUMsb0RBQU07QUFDakQsYUFBYSxtQkFBTyxDQUFDLHNFQUFTO0FBQzlCLHNCQUFzQixtQkFBTyxDQUFDLHdGQUFrQjtBQUNoRCx1Q0FBdUMsbUJBQU8sQ0FBQyw0RUFBWTtBQUMzRCx1REFBdUQsbUJBQU8sQ0FBQyw0R0FBNEI7QUFDM0YscUNBQXFDLGlDQUFpQztBQUN0RSx5Q0FBeUMsNEVBQTRFLG9EQUFvRCx1Q0FBdUMsZ0JBQWdCLCtCQUErQiw0RUFBNEUscUJBQXFCLCtCQUErQixlQUFlLHdDQUF3QywySkFBMkosV0FBVztBQUM1bEIsb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsMENBQTBDLCtCQUErQixvQkFBb0IsbUNBQW1DLG9DQUFvQyx1RUFBdUU7QUFDelE7QUFDQTtBQUNBO0FBQ0EsRUFBRSxhQUFhO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZUFBZTtBQUNqQjtBQUNBLG1CQUFtQixpQkFBaUIsd0JBQXdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsbUJBQW1CLHNCQUFzQixrQ0FBa0M7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTixRQUFRLDBCQUEwQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsa0RBQWtEO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3oxMHRyaWFnZS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvUmVhY3RHcmlkTGF5b3V0LmpzPzk5OWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgUmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9mYXN0RXF1YWxzID0gcmVxdWlyZShcImZhc3QtZXF1YWxzXCIpO1xudmFyIF9jbHN4ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xzeFwiKSk7XG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgX2NhbGN1bGF0ZVV0aWxzID0gcmVxdWlyZShcIi4vY2FsY3VsYXRlVXRpbHNcIik7XG52YXIgX0dyaWRJdGVtID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9HcmlkSXRlbVwiKSk7XG52YXIgX1JlYWN0R3JpZExheW91dFByb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vUmVhY3RHcmlkTGF5b3V0UHJvcFR5cGVzXCIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH07IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHQpIHsgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgV2Vha01hcCkgdmFyIHIgPSBuZXcgV2Vha01hcCgpLCBuID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IGZ1bmN0aW9uIChlLCB0KSB7IGlmICghdCAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7IHZhciBvLCBpLCBmID0geyBfX3Byb3RvX186IG51bGwsIGRlZmF1bHQ6IGUgfTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSB0eXBlb2YgZSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiBmOyBpZiAobyA9IHQgPyBuIDogcikgeyBpZiAoby5oYXMoZSkpIHJldHVybiBvLmdldChlKTsgby5zZXQoZSwgZik7IH0gZm9yIChjb25zdCB0IGluIGUpIFwiZGVmYXVsdFwiICE9PSB0ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgdCkgJiYgKChpID0gKG8gPSBPYmplY3QuZGVmaW5lUHJvcGVydHkpICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdCkpICYmIChpLmdldCB8fCBpLnNldCkgPyBvKGYsIHQsIGkpIDogZlt0XSA9IGVbdF0pOyByZXR1cm4gZjsgfSkoZSwgdCk7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7IHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3JdID0gdCwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbi8qOjogaW1wb3J0IHR5cGUge1xuICBDaGlsZHJlbkFycmF5IGFzIFJlYWN0Q2hpbGRyZW5BcnJheSxcbiAgRWxlbWVudCBhcyBSZWFjdEVsZW1lbnRcbn0gZnJvbSBcInJlYWN0XCI7Ki9cbi8qOjogaW1wb3J0IHR5cGUge1xuICBDb21wYWN0VHlwZSxcbiAgR3JpZFJlc2l6ZUV2ZW50LFxuICBHcmlkRHJhZ0V2ZW50LFxuICBEcmFnT3ZlckV2ZW50LFxuICBMYXlvdXQsXG4gIERyb3BwaW5nUG9zaXRpb24sXG4gIExheW91dEl0ZW1cbn0gZnJvbSBcIi4vdXRpbHNcIjsqL1xuLy8gVHlwZXNcbi8qOjogaW1wb3J0IHR5cGUgeyBQb3NpdGlvblBhcmFtcyB9IGZyb20gXCIuL2NhbGN1bGF0ZVV0aWxzXCI7Ki9cbi8qOjogdHlwZSBTdGF0ZSA9IHtcbiAgYWN0aXZlRHJhZzogP0xheW91dEl0ZW0sXG4gIGxheW91dDogTGF5b3V0LFxuICBtb3VudGVkOiBib29sZWFuLFxuICBvbGREcmFnSXRlbTogP0xheW91dEl0ZW0sXG4gIG9sZExheW91dDogP0xheW91dCxcbiAgb2xkUmVzaXplSXRlbTogP0xheW91dEl0ZW0sXG4gIHJlc2l6aW5nOiBib29sZWFuLFxuICBkcm9wcGluZ0RPTU5vZGU6ID9SZWFjdEVsZW1lbnQ8YW55PixcbiAgZHJvcHBpbmdQb3NpdGlvbj86IERyb3BwaW5nUG9zaXRpb24sXG4gIC8vIE1pcnJvcmVkIHByb3BzXG4gIGNoaWxkcmVuOiBSZWFjdENoaWxkcmVuQXJyYXk8UmVhY3RFbGVtZW50PGFueT4+LFxuICBjb21wYWN0VHlwZT86IENvbXBhY3RUeXBlLFxuICBwcm9wc0xheW91dD86IExheW91dFxufTsqL1xuLyo6OiBpbXBvcnQgdHlwZSB7IFByb3BzLCBEZWZhdWx0UHJvcHMgfSBmcm9tIFwiLi9SZWFjdEdyaWRMYXlvdXRQcm9wVHlwZXNcIjsqL1xuLy8gRW5kIFR5cGVzXG5jb25zdCBsYXlvdXRDbGFzc05hbWUgPSBcInJlYWN0LWdyaWQtbGF5b3V0XCI7XG5sZXQgaXNGaXJlZm94ID0gZmFsc2U7XG4vLyBUcnkuLi5jYXRjaCB3aWxsIHByb3RlY3QgZnJvbSBuYXZpZ2F0b3Igbm90IGV4aXN0aW5nIChlLmcuIG5vZGUpIG9yIGEgYmFkIGltcGxlbWVudGF0aW9uIG9mIG5hdmlnYXRvclxudHJ5IHtcbiAgaXNGaXJlZm94ID0gL2ZpcmVmb3gvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xufSBjYXRjaCAoZSkge1xuICAvKiBJZ25vcmUgKi9cbn1cblxuLyoqXG4gKiBBIHJlYWN0aXZlLCBmbHVpZCBncmlkIGxheW91dCB3aXRoIGRyYWdnYWJsZSwgcmVzaXphYmxlIGNvbXBvbmVudHMuXG4gKi9cblxuY2xhc3MgUmVhY3RHcmlkTGF5b3V0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IC8qOjogPFByb3BzLCBTdGF0ZT4qL3tcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICBhY3RpdmVEcmFnOiBudWxsLFxuICAgICAgbGF5b3V0OiAoMCwgX3V0aWxzLnN5bmNocm9uaXplTGF5b3V0V2l0aENoaWxkcmVuKSh0aGlzLnByb3BzLmxheW91dCwgdGhpcy5wcm9wcy5jaGlsZHJlbiwgdGhpcy5wcm9wcy5jb2xzLFxuICAgICAgLy8gTGVnYWN5IHN1cHBvcnQgZm9yIHZlcnRpY2FsQ29tcGFjdDogZmFsc2VcbiAgICAgICgwLCBfdXRpbHMuY29tcGFjdFR5cGUpKHRoaXMucHJvcHMpLCB0aGlzLnByb3BzLmFsbG93T3ZlcmxhcCksXG4gICAgICBtb3VudGVkOiBmYWxzZSxcbiAgICAgIG9sZERyYWdJdGVtOiBudWxsLFxuICAgICAgb2xkTGF5b3V0OiBudWxsLFxuICAgICAgb2xkUmVzaXplSXRlbTogbnVsbCxcbiAgICAgIHJlc2l6aW5nOiBmYWxzZSxcbiAgICAgIGRyb3BwaW5nRE9NTm9kZTogbnVsbCxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRyYWdFbnRlckNvdW50ZXJcIiwgMCk7XG4gICAgLyoqXG4gICAgICogV2hlbiBkcmFnZ2luZyBzdGFydHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaSBJZCBvZiB0aGUgY2hpbGRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBYIHBvc2l0aW9uIG9mIHRoZSBtb3ZlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBwb3NpdGlvbiBvZiB0aGUgbW92ZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgVGhlIG1vdXNlZG93biBldmVudFxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBUaGUgY3VycmVudCBkcmFnZ2luZyBET00gZWxlbWVudFxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRHJhZ1N0YXJ0XCIsIChpIC8qOiBzdHJpbmcqLywgeCAvKjogbnVtYmVyKi8sIHkgLyo6IG51bWJlciovLCBfcmVmIC8qOjogKi8pID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGUsXG4gICAgICAgIG5vZGVcbiAgICAgIH0gLyo6IEdyaWREcmFnRXZlbnQqLyA9IF9yZWYgLyo6IEdyaWREcmFnRXZlbnQqLztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGF5b3V0XG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IGwgPSAoMCwgX3V0aWxzLmdldExheW91dEl0ZW0pKGxheW91dCwgaSk7XG4gICAgICBpZiAoIWwpIHJldHVybjtcblxuICAgICAgLy8gQ3JlYXRlIHBsYWNlaG9sZGVyIChkaXNwbGF5IG9ubHkpXG4gICAgICBjb25zdCBwbGFjZWhvbGRlciA9IHtcbiAgICAgICAgdzogbC53LFxuICAgICAgICBoOiBsLmgsXG4gICAgICAgIHg6IGwueCxcbiAgICAgICAgeTogbC55LFxuICAgICAgICBwbGFjZWhvbGRlcjogdHJ1ZSxcbiAgICAgICAgaTogaVxuICAgICAgfTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBvbGREcmFnSXRlbTogKDAsIF91dGlscy5jbG9uZUxheW91dEl0ZW0pKGwpLFxuICAgICAgICBvbGRMYXlvdXQ6IGxheW91dCxcbiAgICAgICAgYWN0aXZlRHJhZzogcGxhY2Vob2xkZXJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMub25EcmFnU3RhcnQobGF5b3V0LCBsLCBsLCBudWxsLCBlLCBub2RlKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBFYWNoIGRyYWcgbW92ZW1lbnQgY3JlYXRlIGEgbmV3IGRyYWdlbGVtZW50IGFuZCBtb3ZlIHRoZSBlbGVtZW50IHRvIHRoZSBkcmFnZ2VkIGxvY2F0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGkgSWQgb2YgdGhlIGNoaWxkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggWCBwb3NpdGlvbiBvZiB0aGUgbW92ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgcG9zaXRpb24gb2YgdGhlIG1vdmVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIFRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgVGhlIGN1cnJlbnQgZHJhZ2dpbmcgRE9NIGVsZW1lbnRcbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkRyYWdcIiwgKGksIHgsIHksIF9yZWYyKSA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBlLFxuICAgICAgICBub2RlXG4gICAgICB9ID0gX3JlZjI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9sZERyYWdJdGVtXG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGxldCB7XG4gICAgICAgIGxheW91dFxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbHMsXG4gICAgICAgIGFsbG93T3ZlcmxhcCxcbiAgICAgICAgcHJldmVudENvbGxpc2lvblxuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCBsID0gKDAsIF91dGlscy5nZXRMYXlvdXRJdGVtKShsYXlvdXQsIGkpO1xuICAgICAgaWYgKCFsKSByZXR1cm47XG5cbiAgICAgIC8vIENyZWF0ZSBwbGFjZWhvbGRlciAoZGlzcGxheSBvbmx5KVxuICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSB7XG4gICAgICAgIHc6IGwudyxcbiAgICAgICAgaDogbC5oLFxuICAgICAgICB4OiBsLngsXG4gICAgICAgIHk6IGwueSxcbiAgICAgICAgcGxhY2Vob2xkZXI6IHRydWUsXG4gICAgICAgIGk6IGlcbiAgICAgIH07XG5cbiAgICAgIC8vIE1vdmUgdGhlIGVsZW1lbnQgdG8gdGhlIGRyYWdnZWQgbG9jYXRpb24uXG4gICAgICBjb25zdCBpc1VzZXJBY3Rpb24gPSB0cnVlO1xuICAgICAgbGF5b3V0ID0gKDAsIF91dGlscy5tb3ZlRWxlbWVudCkobGF5b3V0LCBsLCB4LCB5LCBpc1VzZXJBY3Rpb24sIHByZXZlbnRDb2xsaXNpb24sICgwLCBfdXRpbHMuY29tcGFjdFR5cGUpKHRoaXMucHJvcHMpLCBjb2xzLCBhbGxvd092ZXJsYXApO1xuICAgICAgdGhpcy5wcm9wcy5vbkRyYWcobGF5b3V0LCBvbGREcmFnSXRlbSwgbCwgcGxhY2Vob2xkZXIsIGUsIG5vZGUpO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGxheW91dDogYWxsb3dPdmVybGFwID8gbGF5b3V0IDogKDAsIF91dGlscy5jb21wYWN0KShsYXlvdXQsICgwLCBfdXRpbHMuY29tcGFjdFR5cGUpKHRoaXMucHJvcHMpLCBjb2xzKSxcbiAgICAgICAgYWN0aXZlRHJhZzogcGxhY2Vob2xkZXJcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFdoZW4gZHJhZ2dpbmcgc3RvcHMsIGZpZ3VyZSBvdXQgd2hpY2ggcG9zaXRpb24gdGhlIGVsZW1lbnQgaXMgY2xvc2VzdCB0byBhbmQgdXBkYXRlIGl0cyB4IGFuZCB5LlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gaSBJbmRleCBvZiB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggWCBwb3NpdGlvbiBvZiB0aGUgbW92ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgcG9zaXRpb24gb2YgdGhlIG1vdmVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIFRoZSBtb3VzZWRvd24gZXZlbnRcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgVGhlIGN1cnJlbnQgZHJhZ2dpbmcgRE9NIGVsZW1lbnRcbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkRyYWdTdG9wXCIsIChpLCB4LCB5LCBfcmVmMykgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgZSxcbiAgICAgICAgbm9kZVxuICAgICAgfSA9IF9yZWYzO1xuICAgICAgaWYgKCF0aGlzLnN0YXRlLmFjdGl2ZURyYWcpIHJldHVybjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2xkRHJhZ0l0ZW1cbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgbGV0IHtcbiAgICAgICAgbGF5b3V0XG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29scyxcbiAgICAgICAgcHJldmVudENvbGxpc2lvbixcbiAgICAgICAgYWxsb3dPdmVybGFwXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IGwgPSAoMCwgX3V0aWxzLmdldExheW91dEl0ZW0pKGxheW91dCwgaSk7XG4gICAgICBpZiAoIWwpIHJldHVybjtcblxuICAgICAgLy8gTW92ZSB0aGUgZWxlbWVudCBoZXJlXG4gICAgICBjb25zdCBpc1VzZXJBY3Rpb24gPSB0cnVlO1xuICAgICAgbGF5b3V0ID0gKDAsIF91dGlscy5tb3ZlRWxlbWVudCkobGF5b3V0LCBsLCB4LCB5LCBpc1VzZXJBY3Rpb24sIHByZXZlbnRDb2xsaXNpb24sICgwLCBfdXRpbHMuY29tcGFjdFR5cGUpKHRoaXMucHJvcHMpLCBjb2xzLCBhbGxvd092ZXJsYXApO1xuXG4gICAgICAvLyBTZXQgc3RhdGVcbiAgICAgIGNvbnN0IG5ld0xheW91dCA9IGFsbG93T3ZlcmxhcCA/IGxheW91dCA6ICgwLCBfdXRpbHMuY29tcGFjdCkobGF5b3V0LCAoMCwgX3V0aWxzLmNvbXBhY3RUeXBlKSh0aGlzLnByb3BzKSwgY29scyk7XG4gICAgICB0aGlzLnByb3BzLm9uRHJhZ1N0b3AobmV3TGF5b3V0LCBvbGREcmFnSXRlbSwgbCwgbnVsbCwgZSwgbm9kZSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9sZExheW91dFxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgYWN0aXZlRHJhZzogbnVsbCxcbiAgICAgICAgbGF5b3V0OiBuZXdMYXlvdXQsXG4gICAgICAgIG9sZERyYWdJdGVtOiBudWxsLFxuICAgICAgICBvbGRMYXlvdXQ6IG51bGxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbkxheW91dE1heWJlQ2hhbmdlZChuZXdMYXlvdXQsIG9sZExheW91dCk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25SZXNpemVTdGFydFwiLCAoaSwgdywgaCwgX3JlZjQpID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGUsXG4gICAgICAgIG5vZGVcbiAgICAgIH0gPSBfcmVmNDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGF5b3V0XG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IGwgPSAoMCwgX3V0aWxzLmdldExheW91dEl0ZW0pKGxheW91dCwgaSk7XG4gICAgICBpZiAoIWwpIHJldHVybjtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBvbGRSZXNpemVJdGVtOiAoMCwgX3V0aWxzLmNsb25lTGF5b3V0SXRlbSkobCksXG4gICAgICAgIG9sZExheW91dDogdGhpcy5zdGF0ZS5sYXlvdXQsXG4gICAgICAgIHJlc2l6aW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJvcHMub25SZXNpemVTdGFydChsYXlvdXQsIGwsIGwsIG51bGwsIGUsIG5vZGUpO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uUmVzaXplXCIsIChpLCB3LCBoLCBfcmVmNSkgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgZSxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgaGFuZGxlXG4gICAgICB9ID0gX3JlZjU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9sZFJlc2l6ZUl0ZW1cbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBsYXlvdXRcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb2xzLFxuICAgICAgICBwcmV2ZW50Q29sbGlzaW9uLFxuICAgICAgICBhbGxvd092ZXJsYXBcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgbGV0IHNob3VsZE1vdmVJdGVtID0gZmFsc2U7XG4gICAgICBsZXQgZmluYWxMYXlvdXQ7XG4gICAgICBsZXQgeDtcbiAgICAgIGxldCB5O1xuICAgICAgY29uc3QgW25ld0xheW91dCwgbF0gPSAoMCwgX3V0aWxzLndpdGhMYXlvdXRJdGVtKShsYXlvdXQsIGksIGwgPT4ge1xuICAgICAgICBsZXQgaGFzQ29sbGlzaW9ucztcbiAgICAgICAgeCA9IGwueDtcbiAgICAgICAgeSA9IGwueTtcbiAgICAgICAgaWYgKFtcInN3XCIsIFwid1wiLCBcIm53XCIsIFwiblwiLCBcIm5lXCJdLmluZGV4T2YoaGFuZGxlKSAhPT0gLTEpIHtcbiAgICAgICAgICBpZiAoW1wic3dcIiwgXCJud1wiLCBcIndcIl0uaW5kZXhPZihoYW5kbGUpICE9PSAtMSkge1xuICAgICAgICAgICAgeCA9IGwueCArIChsLncgLSB3KTtcbiAgICAgICAgICAgIHcgPSBsLnggIT09IHggJiYgeCA8IDAgPyBsLncgOiB3O1xuICAgICAgICAgICAgeCA9IHggPCAwID8gMCA6IHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChbXCJuZVwiLCBcIm5cIiwgXCJud1wiXS5pbmRleE9mKGhhbmRsZSkgIT09IC0xKSB7XG4gICAgICAgICAgICB5ID0gbC55ICsgKGwuaCAtIGgpO1xuICAgICAgICAgICAgaCA9IGwueSAhPT0geSAmJiB5IDwgMCA/IGwuaCA6IGg7XG4gICAgICAgICAgICB5ID0geSA8IDAgPyAwIDogeTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2hvdWxkTW92ZUl0ZW0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU29tZXRoaW5nIGxpa2UgcXVhZCB0cmVlIHNob3VsZCBiZSB1c2VkXG4gICAgICAgIC8vIHRvIGZpbmQgY29sbGlzaW9ucyBmYXN0ZXJcbiAgICAgICAgaWYgKHByZXZlbnRDb2xsaXNpb24gJiYgIWFsbG93T3ZlcmxhcCkge1xuICAgICAgICAgIGNvbnN0IGNvbGxpc2lvbnMgPSAoMCwgX3V0aWxzLmdldEFsbENvbGxpc2lvbnMpKGxheW91dCwge1xuICAgICAgICAgICAgLi4ubCxcbiAgICAgICAgICAgIHcsXG4gICAgICAgICAgICBoLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHlcbiAgICAgICAgICB9KS5maWx0ZXIobGF5b3V0SXRlbSA9PiBsYXlvdXRJdGVtLmkgIT09IGwuaSk7XG4gICAgICAgICAgaGFzQ29sbGlzaW9ucyA9IGNvbGxpc2lvbnMubGVuZ3RoID4gMDtcblxuICAgICAgICAgIC8vIElmIHdlJ3JlIGNvbGxpZGluZywgd2UgbmVlZCBhZGp1c3QgdGhlIHBsYWNlaG9sZGVyLlxuICAgICAgICAgIGlmIChoYXNDb2xsaXNpb25zKSB7XG4gICAgICAgICAgICAvLyBSZXNldCBsYXlvdXRJdGVtIGRpbWVuc2lvbnMgaWYgdGhlcmUgd2VyZSBjb2xsaXNpb25zXG4gICAgICAgICAgICB5ID0gbC55O1xuICAgICAgICAgICAgaCA9IGwuaDtcbiAgICAgICAgICAgIHggPSBsLng7XG4gICAgICAgICAgICB3ID0gbC53O1xuICAgICAgICAgICAgc2hvdWxkTW92ZUl0ZW0gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbC53ID0gdztcbiAgICAgICAgbC5oID0gaDtcbiAgICAgICAgcmV0dXJuIGw7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2hvdWxkbid0IGV2ZXIgaGFwcGVuLCBidXQgdHlwZWNoZWNraW5nIG1ha2VzIGl0IG5lY2Vzc2FyeVxuICAgICAgaWYgKCFsKSByZXR1cm47XG4gICAgICBmaW5hbExheW91dCA9IG5ld0xheW91dDtcbiAgICAgIGlmIChzaG91bGRNb3ZlSXRlbSkge1xuICAgICAgICAvLyBNb3ZlIHRoZSBlbGVtZW50IHRvIHRoZSBuZXcgcG9zaXRpb24uXG4gICAgICAgIGNvbnN0IGlzVXNlckFjdGlvbiA9IHRydWU7XG4gICAgICAgIGZpbmFsTGF5b3V0ID0gKDAsIF91dGlscy5tb3ZlRWxlbWVudCkobmV3TGF5b3V0LCBsLCB4LCB5LCBpc1VzZXJBY3Rpb24sIHRoaXMucHJvcHMucHJldmVudENvbGxpc2lvbiwgKDAsIF91dGlscy5jb21wYWN0VHlwZSkodGhpcy5wcm9wcyksIGNvbHMsIGFsbG93T3ZlcmxhcCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBwbGFjZWhvbGRlciBlbGVtZW50IChkaXNwbGF5IG9ubHkpXG4gICAgICBjb25zdCBwbGFjZWhvbGRlciA9IHtcbiAgICAgICAgdzogbC53LFxuICAgICAgICBoOiBsLmgsXG4gICAgICAgIHg6IGwueCxcbiAgICAgICAgeTogbC55LFxuICAgICAgICBzdGF0aWM6IHRydWUsXG4gICAgICAgIGk6IGlcbiAgICAgIH07XG4gICAgICB0aGlzLnByb3BzLm9uUmVzaXplKGZpbmFsTGF5b3V0LCBvbGRSZXNpemVJdGVtLCBsLCBwbGFjZWhvbGRlciwgZSwgbm9kZSk7XG5cbiAgICAgIC8vIFJlLWNvbXBhY3QgdGhlIG5ld0xheW91dCBhbmQgc2V0IHRoZSBkcmFnIHBsYWNlaG9sZGVyLlxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGxheW91dDogYWxsb3dPdmVybGFwID8gZmluYWxMYXlvdXQgOiAoMCwgX3V0aWxzLmNvbXBhY3QpKGZpbmFsTGF5b3V0LCAoMCwgX3V0aWxzLmNvbXBhY3RUeXBlKSh0aGlzLnByb3BzKSwgY29scyksXG4gICAgICAgIGFjdGl2ZURyYWc6IHBsYWNlaG9sZGVyXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvblJlc2l6ZVN0b3BcIiwgKGksIHcsIGgsIF9yZWY2KSA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBlLFxuICAgICAgICBub2RlXG4gICAgICB9ID0gX3JlZjY7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxheW91dCxcbiAgICAgICAgb2xkUmVzaXplSXRlbVxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbHMsXG4gICAgICAgIGFsbG93T3ZlcmxhcFxuICAgICAgfSA9IHRoaXMucHJvcHM7XG4gICAgICBjb25zdCBsID0gKDAsIF91dGlscy5nZXRMYXlvdXRJdGVtKShsYXlvdXQsIGkpO1xuXG4gICAgICAvLyBTZXQgc3RhdGVcbiAgICAgIGNvbnN0IG5ld0xheW91dCA9IGFsbG93T3ZlcmxhcCA/IGxheW91dCA6ICgwLCBfdXRpbHMuY29tcGFjdCkobGF5b3V0LCAoMCwgX3V0aWxzLmNvbXBhY3RUeXBlKSh0aGlzLnByb3BzKSwgY29scyk7XG4gICAgICB0aGlzLnByb3BzLm9uUmVzaXplU3RvcChuZXdMYXlvdXQsIG9sZFJlc2l6ZUl0ZW0sIGwsIG51bGwsIGUsIG5vZGUpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBvbGRMYXlvdXRcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGFjdGl2ZURyYWc6IG51bGwsXG4gICAgICAgIGxheW91dDogbmV3TGF5b3V0LFxuICAgICAgICBvbGRSZXNpemVJdGVtOiBudWxsLFxuICAgICAgICBvbGRMYXlvdXQ6IG51bGwsXG4gICAgICAgIHJlc2l6aW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICB0aGlzLm9uTGF5b3V0TWF5YmVDaGFuZ2VkKG5ld0xheW91dCwgb2xkTGF5b3V0KTtcbiAgICB9KTtcbiAgICAvLyBDYWxsZWQgd2hpbGUgZHJhZ2dpbmcgYW4gZWxlbWVudC4gUGFydCBvZiBicm93c2VyIG5hdGl2ZSBkcmFnL2Ryb3AgQVBJLlxuICAgIC8vIE5hdGl2ZSBldmVudCB0YXJnZXQgbWlnaHQgYmUgdGhlIGxheW91dCBpdHNlbGYsIG9yIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBsYXlvdXQuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25EcmFnT3ZlclwiLCBlID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gUHJldmVudCBhbnkgYnJvd3NlciBuYXRpdmUgYWN0aW9uXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAvLyB3ZSBzaG91bGQgaWdub3JlIGV2ZW50cyBmcm9tIGxheW91dCdzIGNoaWxkcmVuIGluIEZpcmVmb3hcbiAgICAgIC8vIHRvIGF2b2lkIHVucHJlZGljdGFibGUganVtcGluZyBvZiBhIGRyb3BwaW5nIHBsYWNlaG9sZGVyXG4gICAgICAvLyBGSVhNRSByZW1vdmUgdGhpcyBoYWNrXG4gICAgICBpZiAoaXNGaXJlZm94ICYmXG4gICAgICAvLyAkRmxvd0lnbm9yZSBjYW4ndCBmaWd1cmUgdGhpcyBvdXRcbiAgICAgICFlLm5hdGl2ZUV2ZW50LnRhcmdldD8uY2xhc3NMaXN0LmNvbnRhaW5zKGxheW91dENsYXNzTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBkcm9wcGluZ0l0ZW0sXG4gICAgICAgIG9uRHJvcERyYWdPdmVyLFxuICAgICAgICBtYXJnaW4sXG4gICAgICAgIGNvbHMsXG4gICAgICAgIHJvd0hlaWdodCxcbiAgICAgICAgbWF4Um93cyxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGNvbnRhaW5lclBhZGRpbmcsXG4gICAgICAgIHRyYW5zZm9ybVNjYWxlXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIC8vIEFsbG93IHVzZXIgdG8gY3VzdG9taXplIHRoZSBkcm9wcGluZyBpdGVtIG9yIHNob3J0LWNpcmN1aXQgdGhlIGRyb3AgYmFzZWQgb24gdGhlIHJlc3VsdHNcbiAgICAgIC8vIG9mIHRoZSBgb25EcmFnT3ZlcihlOiBFdmVudClgIGNhbGxiYWNrLlxuICAgICAgY29uc3Qgb25EcmFnT3ZlclJlc3VsdCA9IG9uRHJvcERyYWdPdmVyPy4oZSk7XG4gICAgICBpZiAob25EcmFnT3ZlclJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZHJvcHBpbmdET01Ob2RlKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVEcm9wcGluZ1BsYWNlaG9sZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgZmluYWxEcm9wcGluZ0l0ZW0gPSB7XG4gICAgICAgIC4uLmRyb3BwaW5nSXRlbSxcbiAgICAgICAgLi4ub25EcmFnT3ZlclJlc3VsdFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGF5b3V0XG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgLy8gJEZsb3dJZ25vcmUgbWlzc2luZyBkZWZcbiAgICAgIGNvbnN0IGdyaWRSZWN0ID0gZS5jdXJyZW50VGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBUaGUgZ3JpZCdzIHBvc2l0aW9uIGluIHRoZSB2aWV3cG9ydFxuXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIG1vdXNlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBncmlkXG4gICAgICBjb25zdCBsYXllclggPSBlLmNsaWVudFggLSBncmlkUmVjdC5sZWZ0O1xuICAgICAgY29uc3QgbGF5ZXJZID0gZS5jbGllbnRZIC0gZ3JpZFJlY3QudG9wO1xuICAgICAgY29uc3QgZHJvcHBpbmdQb3NpdGlvbiA9IHtcbiAgICAgICAgbGVmdDogbGF5ZXJYIC8gdHJhbnNmb3JtU2NhbGUsXG4gICAgICAgIHRvcDogbGF5ZXJZIC8gdHJhbnNmb3JtU2NhbGUsXG4gICAgICAgIGVcbiAgICAgIH07XG4gICAgICBpZiAoIXRoaXMuc3RhdGUuZHJvcHBpbmdET01Ob2RlKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uUGFyYW1zIC8qOiBQb3NpdGlvblBhcmFtcyovID0ge1xuICAgICAgICAgIGNvbHMsXG4gICAgICAgICAgbWFyZ2luLFxuICAgICAgICAgIG1heFJvd3MsXG4gICAgICAgICAgcm93SGVpZ2h0LFxuICAgICAgICAgIGNvbnRhaW5lcldpZHRoOiB3aWR0aCxcbiAgICAgICAgICBjb250YWluZXJQYWRkaW5nOiBjb250YWluZXJQYWRkaW5nIHx8IG1hcmdpblxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYWxjdWxhdGVkUG9zaXRpb24gPSAoMCwgX2NhbGN1bGF0ZVV0aWxzLmNhbGNYWSkocG9zaXRpb25QYXJhbXMsIGxheWVyWSwgbGF5ZXJYLCBmaW5hbERyb3BwaW5nSXRlbS53LCBmaW5hbERyb3BwaW5nSXRlbS5oKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgZHJvcHBpbmdET01Ob2RlOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICBrZXk6IGZpbmFsRHJvcHBpbmdJdGVtLmlcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBkcm9wcGluZ1Bvc2l0aW9uLFxuICAgICAgICAgIGxheW91dDogWy4uLmxheW91dCwge1xuICAgICAgICAgICAgLi4uZmluYWxEcm9wcGluZ0l0ZW0sXG4gICAgICAgICAgICB4OiBjYWxjdWxhdGVkUG9zaXRpb24ueCxcbiAgICAgICAgICAgIHk6IGNhbGN1bGF0ZWRQb3NpdGlvbi55LFxuICAgICAgICAgICAgc3RhdGljOiBmYWxzZSxcbiAgICAgICAgICAgIGlzRHJhZ2dhYmxlOiB0cnVlXG4gICAgICAgICAgfV1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuZHJvcHBpbmdQb3NpdGlvbikge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICB0b3BcbiAgICAgICAgfSA9IHRoaXMuc3RhdGUuZHJvcHBpbmdQb3NpdGlvbjtcbiAgICAgICAgY29uc3Qgc2hvdWxkVXBkYXRlUG9zaXRpb24gPSBsZWZ0ICE9IGxheWVyWCB8fCB0b3AgIT0gbGF5ZXJZO1xuICAgICAgICBpZiAoc2hvdWxkVXBkYXRlUG9zaXRpb24pIHtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGRyb3BwaW5nUG9zaXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlbW92ZURyb3BwaW5nUGxhY2Vob2xkZXJcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkcm9wcGluZ0l0ZW0sXG4gICAgICAgIGNvbHNcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBsYXlvdXRcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgbmV3TGF5b3V0ID0gKDAsIF91dGlscy5jb21wYWN0KShsYXlvdXQuZmlsdGVyKGwgPT4gbC5pICE9PSBkcm9wcGluZ0l0ZW0uaSksICgwLCBfdXRpbHMuY29tcGFjdFR5cGUpKHRoaXMucHJvcHMpLCBjb2xzLCB0aGlzLnByb3BzLmFsbG93T3ZlcmxhcCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgbGF5b3V0OiBuZXdMYXlvdXQsXG4gICAgICAgIGRyb3BwaW5nRE9NTm9kZTogbnVsbCxcbiAgICAgICAgYWN0aXZlRHJhZzogbnVsbCxcbiAgICAgICAgZHJvcHBpbmdQb3NpdGlvbjogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkRyYWdMZWF2ZVwiLCBlID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gUHJldmVudCBhbnkgYnJvd3NlciBuYXRpdmUgYWN0aW9uXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgdGhpcy5kcmFnRW50ZXJDb3VudGVyLS07XG5cbiAgICAgIC8vIG9uRHJhZ0xlYXZlIGNhbiBiZSB0cmlnZ2VyZWQgb24gZWFjaCBsYXlvdXQncyBjaGlsZC5cbiAgICAgIC8vIEJ1dCB3ZSBrbm93IHRoYXQgY291bnQgb2YgZHJhZ0VudGVyIGFuZCBkcmFnTGVhdmUgZXZlbnRzXG4gICAgICAvLyB3aWxsIGJlIGJhbGFuY2VkIGFmdGVyIGxlYXZpbmcgdGhlIGxheW91dCdzIGNvbnRhaW5lclxuICAgICAgLy8gc28gd2UgY2FuIGluY3JlYXNlIGFuZCBkZWNyZWFzZSBjb3VudCBvZiBkcmFnRW50ZXIgYW5kXG4gICAgICAvLyB3aGVuIGl0J2xsIGJlIGVxdWFsIHRvIDAgd2UnbGwgcmVtb3ZlIHRoZSBwbGFjZWhvbGRlclxuICAgICAgaWYgKHRoaXMuZHJhZ0VudGVyQ291bnRlciA9PT0gMCkge1xuICAgICAgICB0aGlzLnJlbW92ZURyb3BwaW5nUGxhY2Vob2xkZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkRyYWdFbnRlclwiLCBlID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gUHJldmVudCBhbnkgYnJvd3NlciBuYXRpdmUgYWN0aW9uXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgdGhpcy5kcmFnRW50ZXJDb3VudGVyKys7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25Ecm9wXCIsIChlIC8qOiBFdmVudCovKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgYW55IGJyb3dzZXIgbmF0aXZlIGFjdGlvblxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZHJvcHBpbmdJdGVtXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGF5b3V0XG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IGl0ZW0gPSBsYXlvdXQuZmluZChsID0+IGwuaSA9PT0gZHJvcHBpbmdJdGVtLmkpO1xuXG4gICAgICAvLyByZXNldCBkcmFnRW50ZXIgY291bnRlciBvbiBkcm9wXG4gICAgICB0aGlzLmRyYWdFbnRlckNvdW50ZXIgPSAwO1xuICAgICAgdGhpcy5yZW1vdmVEcm9wcGluZ1BsYWNlaG9sZGVyKCk7XG4gICAgICB0aGlzLnByb3BzLm9uRHJvcChsYXlvdXQsIGl0ZW0sIGUpO1xuICAgIH0pO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgbW91bnRlZDogdHJ1ZVxuICAgIH0pO1xuICAgIC8vIFBvc3NpYmx5IGNhbGwgYmFjayB3aXRoIGxheW91dCBvbiBtb3VudC4gVGhpcyBzaG91bGQgYmUgZG9uZSBhZnRlciBjb3JyZWN0aW5nIHRoZSBsYXlvdXQgd2lkdGhcbiAgICAvLyB0byBlbnN1cmUgd2UgZG9uJ3QgcmVyZW5kZXIgd2l0aCB0aGUgd3Jvbmcgd2lkdGguXG4gICAgdGhpcy5vbkxheW91dE1heWJlQ2hhbmdlZCh0aGlzLnN0YXRlLmxheW91dCwgdGhpcy5wcm9wcy5sYXlvdXQpO1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzIC8qOiBQcm9wcyovLCBwcmV2U3RhdGUgLyo6IFN0YXRlKi8pIC8qOiAkU2hhcGU8U3RhdGU+IHwgbnVsbCove1xuICAgIGxldCBuZXdMYXlvdXRCYXNlO1xuICAgIGlmIChwcmV2U3RhdGUuYWN0aXZlRHJhZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IHN1cHBvcnQgZm9yIGNvbXBhY3RUeXBlXG4gICAgLy8gQWxsb3cgcGFyZW50IHRvIHNldCBsYXlvdXQgZGlyZWN0bHkuXG4gICAgaWYgKCEoMCwgX2Zhc3RFcXVhbHMuZGVlcEVxdWFsKShuZXh0UHJvcHMubGF5b3V0LCBwcmV2U3RhdGUucHJvcHNMYXlvdXQpIHx8IG5leHRQcm9wcy5jb21wYWN0VHlwZSAhPT0gcHJldlN0YXRlLmNvbXBhY3RUeXBlKSB7XG4gICAgICBuZXdMYXlvdXRCYXNlID0gbmV4dFByb3BzLmxheW91dDtcbiAgICB9IGVsc2UgaWYgKCEoMCwgX3V0aWxzLmNoaWxkcmVuRXF1YWwpKG5leHRQcm9wcy5jaGlsZHJlbiwgcHJldlN0YXRlLmNoaWxkcmVuKSkge1xuICAgICAgLy8gSWYgY2hpbGRyZW4gY2hhbmdlLCBhbHNvIHJlZ2VuZXJhdGUgdGhlIGxheW91dC4gVXNlIG91ciBzdGF0ZVxuICAgICAgLy8gYXMgdGhlIGJhc2UgaW4gY2FzZSBiZWNhdXNlIGl0IG1heSBiZSBtb3JlIHVwIHRvIGRhdGUgdGhhblxuICAgICAgLy8gd2hhdCBpcyBpbiBwcm9wcy5cbiAgICAgIG5ld0xheW91dEJhc2UgPSBwcmV2U3RhdGUubGF5b3V0O1xuICAgIH1cblxuICAgIC8vIFdlIG5lZWQgdG8gcmVnZW5lcmF0ZSB0aGUgbGF5b3V0LlxuICAgIGlmIChuZXdMYXlvdXRCYXNlKSB7XG4gICAgICBjb25zdCBuZXdMYXlvdXQgPSAoMCwgX3V0aWxzLnN5bmNocm9uaXplTGF5b3V0V2l0aENoaWxkcmVuKShuZXdMYXlvdXRCYXNlLCBuZXh0UHJvcHMuY2hpbGRyZW4sIG5leHRQcm9wcy5jb2xzLCAoMCwgX3V0aWxzLmNvbXBhY3RUeXBlKShuZXh0UHJvcHMpLCBuZXh0UHJvcHMuYWxsb3dPdmVybGFwKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxheW91dDogbmV3TGF5b3V0LFxuICAgICAgICAvLyBXZSBuZWVkIHRvIHNhdmUgdGhlc2UgcHJvcHMgdG8gc3RhdGUgZm9yIHVzaW5nXG4gICAgICAgIC8vIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyBpbnN0ZWFkIG9mIGNvbXBvbmVudERpZE1vdW50IChpbiB3aGljaCB3ZSB3b3VsZCBnZXQgZXh0cmEgcmVyZW5kZXIpXG4gICAgICAgIGNvbXBhY3RUeXBlOiBuZXh0UHJvcHMuY29tcGFjdFR5cGUsXG4gICAgICAgIGNoaWxkcmVuOiBuZXh0UHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIHByb3BzTGF5b3V0OiBuZXh0UHJvcHMubGF5b3V0XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzIC8qOiBQcm9wcyovLCBuZXh0U3RhdGUgLyo6IFN0YXRlKi8pIC8qOiBib29sZWFuKi97XG4gICAgcmV0dXJuIChcbiAgICAgIC8vIE5PVEU6IHRoaXMgaXMgYWxtb3N0IGFsd2F5cyB1bmVxdWFsLiBUaGVyZWZvcmUgdGhlIG9ubHkgd2F5IHRvIGdldCBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAgICAgIC8vIGZyb20gU0NVIGlzIGlmIHRoZSB1c2VyIGludGVudGlvbmFsbHkgbWVtb2l6ZXMgY2hpbGRyZW4uIElmIHRoZXkgZG8sIGFuZCB0aGV5IGNhblxuICAgICAgLy8gaGFuZGxlIGNoYW5nZXMgcHJvcGVybHksIHBlcmZvcm1hbmNlIHdpbGwgaW5jcmVhc2UuXG4gICAgICB0aGlzLnByb3BzLmNoaWxkcmVuICE9PSBuZXh0UHJvcHMuY2hpbGRyZW4gfHwgISgwLCBfdXRpbHMuZmFzdFJHTFByb3BzRXF1YWwpKHRoaXMucHJvcHMsIG5leHRQcm9wcywgX2Zhc3RFcXVhbHMuZGVlcEVxdWFsKSB8fCB0aGlzLnN0YXRlLmFjdGl2ZURyYWcgIT09IG5leHRTdGF0ZS5hY3RpdmVEcmFnIHx8IHRoaXMuc3RhdGUubW91bnRlZCAhPT0gbmV4dFN0YXRlLm1vdW50ZWQgfHwgdGhpcy5zdGF0ZS5kcm9wcGluZ1Bvc2l0aW9uICE9PSBuZXh0U3RhdGUuZHJvcHBpbmdQb3NpdGlvblxuICAgICk7XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcyAvKjogUHJvcHMqLywgcHJldlN0YXRlIC8qOiBTdGF0ZSovKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLmFjdGl2ZURyYWcpIHtcbiAgICAgIGNvbnN0IG5ld0xheW91dCA9IHRoaXMuc3RhdGUubGF5b3V0O1xuICAgICAgY29uc3Qgb2xkTGF5b3V0ID0gcHJldlN0YXRlLmxheW91dDtcbiAgICAgIHRoaXMub25MYXlvdXRNYXliZUNoYW5nZWQobmV3TGF5b3V0LCBvbGRMYXlvdXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIGEgcGl4ZWwgdmFsdWUgZm9yIHRoZSBjb250YWluZXIuXG4gICAqIEByZXR1cm4ge1N0cmluZ30gQ29udGFpbmVyIGhlaWdodCBpbiBwaXhlbHMuXG4gICAqL1xuICBjb250YWluZXJIZWlnaHQoKSAvKjogP3N0cmluZyove1xuICAgIGlmICghdGhpcy5wcm9wcy5hdXRvU2l6ZSkgcmV0dXJuO1xuICAgIGNvbnN0IG5iUm93ID0gKDAsIF91dGlscy5ib3R0b20pKHRoaXMuc3RhdGUubGF5b3V0KTtcbiAgICBjb25zdCBjb250YWluZXJQYWRkaW5nWSA9IHRoaXMucHJvcHMuY29udGFpbmVyUGFkZGluZyA/IHRoaXMucHJvcHMuY29udGFpbmVyUGFkZGluZ1sxXSA6IHRoaXMucHJvcHMubWFyZ2luWzFdO1xuICAgIHJldHVybiBuYlJvdyAqIHRoaXMucHJvcHMucm93SGVpZ2h0ICsgKG5iUm93IC0gMSkgKiB0aGlzLnByb3BzLm1hcmdpblsxXSArIGNvbnRhaW5lclBhZGRpbmdZICogMiArIFwicHhcIjtcbiAgfVxuICBvbkxheW91dE1heWJlQ2hhbmdlZChuZXdMYXlvdXQgLyo6IExheW91dCovLCBvbGRMYXlvdXQgLyo6ID9MYXlvdXQqLykge1xuICAgIGlmICghb2xkTGF5b3V0KSBvbGRMYXlvdXQgPSB0aGlzLnN0YXRlLmxheW91dDtcbiAgICBpZiAoISgwLCBfZmFzdEVxdWFscy5kZWVwRXF1YWwpKG9sZExheW91dCwgbmV3TGF5b3V0KSkge1xuICAgICAgdGhpcy5wcm9wcy5vbkxheW91dENoYW5nZShuZXdMYXlvdXQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgcGxhY2Vob2xkZXIgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBQbGFjZWhvbGRlciBkaXYuXG4gICAqL1xuICBwbGFjZWhvbGRlcigpIC8qOiA/UmVhY3RFbGVtZW50PGFueT4qL3tcbiAgICBjb25zdCB7XG4gICAgICBhY3RpdmVEcmFnXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKCFhY3RpdmVEcmFnKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGNvbHMsXG4gICAgICBtYXJnaW4sXG4gICAgICBjb250YWluZXJQYWRkaW5nLFxuICAgICAgcm93SGVpZ2h0LFxuICAgICAgbWF4Um93cyxcbiAgICAgIHVzZUNTU1RyYW5zZm9ybXMsXG4gICAgICB0cmFuc2Zvcm1TY2FsZVxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgLy8gey4uLnRoaXMuc3RhdGUuYWN0aXZlRHJhZ30gaXMgcHJldHR5IHNsb3csIGFjdHVhbGx5XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KF9HcmlkSXRlbS5kZWZhdWx0LCB7XG4gICAgICB3OiBhY3RpdmVEcmFnLncsXG4gICAgICBoOiBhY3RpdmVEcmFnLmgsXG4gICAgICB4OiBhY3RpdmVEcmFnLngsXG4gICAgICB5OiBhY3RpdmVEcmFnLnksXG4gICAgICBpOiBhY3RpdmVEcmFnLmksXG4gICAgICBjbGFzc05hbWU6IGByZWFjdC1ncmlkLXBsYWNlaG9sZGVyICR7dGhpcy5zdGF0ZS5yZXNpemluZyA/IFwicGxhY2Vob2xkZXItcmVzaXppbmdcIiA6IFwiXCJ9YCxcbiAgICAgIGNvbnRhaW5lcldpZHRoOiB3aWR0aCxcbiAgICAgIGNvbHM6IGNvbHMsXG4gICAgICBtYXJnaW46IG1hcmdpbixcbiAgICAgIGNvbnRhaW5lclBhZGRpbmc6IGNvbnRhaW5lclBhZGRpbmcgfHwgbWFyZ2luLFxuICAgICAgbWF4Um93czogbWF4Um93cyxcbiAgICAgIHJvd0hlaWdodDogcm93SGVpZ2h0LFxuICAgICAgaXNEcmFnZ2FibGU6IGZhbHNlLFxuICAgICAgaXNSZXNpemFibGU6IGZhbHNlLFxuICAgICAgaXNCb3VuZGVkOiBmYWxzZSxcbiAgICAgIHVzZUNTU1RyYW5zZm9ybXM6IHVzZUNTU1RyYW5zZm9ybXMsXG4gICAgICB0cmFuc2Zvcm1TY2FsZTogdHJhbnNmb3JtU2NhbGVcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsKSk7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBncmlkIGl0ZW0sIHNldCBpdHMgc3R5bGUgYXR0cmlidXRlcyAmIHN1cnJvdW5kIGluIGEgPERyYWdnYWJsZT4uXG4gICAqIEBwYXJhbSAge0VsZW1lbnR9IGNoaWxkIFJlYWN0IGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9ICAgICAgIEVsZW1lbnQgd3JhcHBlZCBpbiBkcmFnZ2FibGUgYW5kIHByb3Blcmx5IHBsYWNlZC5cbiAgICovXG4gIHByb2Nlc3NHcmlkSXRlbShjaGlsZCAvKjogUmVhY3RFbGVtZW50PGFueT4qLywgaXNEcm9wcGluZ0l0ZW0gLyo6IGJvb2xlYW4qLykgLyo6ID9SZWFjdEVsZW1lbnQ8YW55Piove1xuICAgIGlmICghY2hpbGQgfHwgIWNoaWxkLmtleSkgcmV0dXJuO1xuICAgIGNvbnN0IGwgPSAoMCwgX3V0aWxzLmdldExheW91dEl0ZW0pKHRoaXMuc3RhdGUubGF5b3V0LCBTdHJpbmcoY2hpbGQua2V5KSk7XG4gICAgaWYgKCFsKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGNvbHMsXG4gICAgICBtYXJnaW4sXG4gICAgICBjb250YWluZXJQYWRkaW5nLFxuICAgICAgcm93SGVpZ2h0LFxuICAgICAgbWF4Um93cyxcbiAgICAgIGlzRHJhZ2dhYmxlLFxuICAgICAgaXNSZXNpemFibGUsXG4gICAgICBpc0JvdW5kZWQsXG4gICAgICB1c2VDU1NUcmFuc2Zvcm1zLFxuICAgICAgdHJhbnNmb3JtU2NhbGUsXG4gICAgICBkcmFnZ2FibGVDYW5jZWwsXG4gICAgICBkcmFnZ2FibGVIYW5kbGUsXG4gICAgICByZXNpemVIYW5kbGVzLFxuICAgICAgcmVzaXplSGFuZGxlXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3Qge1xuICAgICAgbW91bnRlZCxcbiAgICAgIGRyb3BwaW5nUG9zaXRpb25cbiAgICB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIC8vIERldGVybWluZSB1c2VyIG1hbmlwdWxhdGlvbnMgcG9zc2libGUuXG4gICAgLy8gSWYgYW4gaXRlbSBpcyBzdGF0aWMsIGl0IGNhbid0IGJlIG1hbmlwdWxhdGVkIGJ5IGRlZmF1bHQuXG4gICAgLy8gQW55IHByb3BlcnRpZXMgZGVmaW5lZCBkaXJlY3RseSBvbiB0aGUgZ3JpZCBpdGVtIHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICAgIGNvbnN0IGRyYWdnYWJsZSA9IHR5cGVvZiBsLmlzRHJhZ2dhYmxlID09PSBcImJvb2xlYW5cIiA/IGwuaXNEcmFnZ2FibGUgOiAhbC5zdGF0aWMgJiYgaXNEcmFnZ2FibGU7XG4gICAgY29uc3QgcmVzaXphYmxlID0gdHlwZW9mIGwuaXNSZXNpemFibGUgPT09IFwiYm9vbGVhblwiID8gbC5pc1Jlc2l6YWJsZSA6ICFsLnN0YXRpYyAmJiBpc1Jlc2l6YWJsZTtcbiAgICBjb25zdCByZXNpemVIYW5kbGVzT3B0aW9ucyA9IGwucmVzaXplSGFuZGxlcyB8fCByZXNpemVIYW5kbGVzO1xuXG4gICAgLy8gaXNCb3VuZGVkIHNldCBvbiBjaGlsZCBpZiBzZXQgb24gcGFyZW50LCBhbmQgY2hpbGQgaXMgbm90IGV4cGxpY2l0bHkgZmFsc2VcbiAgICBjb25zdCBib3VuZGVkID0gZHJhZ2dhYmxlICYmIGlzQm91bmRlZCAmJiBsLmlzQm91bmRlZCAhPT0gZmFsc2U7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KF9HcmlkSXRlbS5kZWZhdWx0LCB7XG4gICAgICBjb250YWluZXJXaWR0aDogd2lkdGgsXG4gICAgICBjb2xzOiBjb2xzLFxuICAgICAgbWFyZ2luOiBtYXJnaW4sXG4gICAgICBjb250YWluZXJQYWRkaW5nOiBjb250YWluZXJQYWRkaW5nIHx8IG1hcmdpbixcbiAgICAgIG1heFJvd3M6IG1heFJvd3MsXG4gICAgICByb3dIZWlnaHQ6IHJvd0hlaWdodCxcbiAgICAgIGNhbmNlbDogZHJhZ2dhYmxlQ2FuY2VsLFxuICAgICAgaGFuZGxlOiBkcmFnZ2FibGVIYW5kbGUsXG4gICAgICBvbkRyYWdTdG9wOiB0aGlzLm9uRHJhZ1N0b3AsXG4gICAgICBvbkRyYWdTdGFydDogdGhpcy5vbkRyYWdTdGFydCxcbiAgICAgIG9uRHJhZzogdGhpcy5vbkRyYWcsXG4gICAgICBvblJlc2l6ZVN0YXJ0OiB0aGlzLm9uUmVzaXplU3RhcnQsXG4gICAgICBvblJlc2l6ZTogdGhpcy5vblJlc2l6ZSxcbiAgICAgIG9uUmVzaXplU3RvcDogdGhpcy5vblJlc2l6ZVN0b3AsXG4gICAgICBpc0RyYWdnYWJsZTogZHJhZ2dhYmxlLFxuICAgICAgaXNSZXNpemFibGU6IHJlc2l6YWJsZSxcbiAgICAgIGlzQm91bmRlZDogYm91bmRlZCxcbiAgICAgIHVzZUNTU1RyYW5zZm9ybXM6IHVzZUNTU1RyYW5zZm9ybXMgJiYgbW91bnRlZCxcbiAgICAgIHVzZVBlcmNlbnRhZ2VzOiAhbW91bnRlZCxcbiAgICAgIHRyYW5zZm9ybVNjYWxlOiB0cmFuc2Zvcm1TY2FsZSxcbiAgICAgIHc6IGwudyxcbiAgICAgIGg6IGwuaCxcbiAgICAgIHg6IGwueCxcbiAgICAgIHk6IGwueSxcbiAgICAgIGk6IGwuaSxcbiAgICAgIG1pbkg6IGwubWluSCxcbiAgICAgIG1pblc6IGwubWluVyxcbiAgICAgIG1heEg6IGwubWF4SCxcbiAgICAgIG1heFc6IGwubWF4VyxcbiAgICAgIHN0YXRpYzogbC5zdGF0aWMsXG4gICAgICBkcm9wcGluZ1Bvc2l0aW9uOiBpc0Ryb3BwaW5nSXRlbSA/IGRyb3BwaW5nUG9zaXRpb24gOiB1bmRlZmluZWQsXG4gICAgICByZXNpemVIYW5kbGVzOiByZXNpemVIYW5kbGVzT3B0aW9ucyxcbiAgICAgIHJlc2l6ZUhhbmRsZTogcmVzaXplSGFuZGxlXG4gICAgfSwgY2hpbGQpO1xuICB9XG4gIHJlbmRlcigpIC8qOiBSZWFjdC5FbGVtZW50PFwiZGl2XCI+Ki97XG4gICAgY29uc3Qge1xuICAgICAgY2xhc3NOYW1lLFxuICAgICAgc3R5bGUsXG4gICAgICBpc0Ryb3BwYWJsZSxcbiAgICAgIGlubmVyUmVmXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgbWVyZ2VkQ2xhc3NOYW1lID0gKDAsIF9jbHN4LmRlZmF1bHQpKGxheW91dENsYXNzTmFtZSwgY2xhc3NOYW1lKTtcbiAgICBjb25zdCBtZXJnZWRTdHlsZSA9IHtcbiAgICAgIGhlaWdodDogdGhpcy5jb250YWluZXJIZWlnaHQoKSxcbiAgICAgIC4uLnN0eWxlXG4gICAgfTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgcmVmOiBpbm5lclJlZixcbiAgICAgIGNsYXNzTmFtZTogbWVyZ2VkQ2xhc3NOYW1lLFxuICAgICAgc3R5bGU6IG1lcmdlZFN0eWxlLFxuICAgICAgb25Ecm9wOiBpc0Ryb3BwYWJsZSA/IHRoaXMub25Ecm9wIDogX3V0aWxzLm5vb3AsXG4gICAgICBvbkRyYWdMZWF2ZTogaXNEcm9wcGFibGUgPyB0aGlzLm9uRHJhZ0xlYXZlIDogX3V0aWxzLm5vb3AsXG4gICAgICBvbkRyYWdFbnRlcjogaXNEcm9wcGFibGUgPyB0aGlzLm9uRHJhZ0VudGVyIDogX3V0aWxzLm5vb3AsXG4gICAgICBvbkRyYWdPdmVyOiBpc0Ryb3BwYWJsZSA/IHRoaXMub25EcmFnT3ZlciA6IF91dGlscy5ub29wXG4gICAgfSwgUmVhY3QuQ2hpbGRyZW4ubWFwKHRoaXMucHJvcHMuY2hpbGRyZW4sIGNoaWxkID0+IHRoaXMucHJvY2Vzc0dyaWRJdGVtKGNoaWxkKSksIGlzRHJvcHBhYmxlICYmIHRoaXMuc3RhdGUuZHJvcHBpbmdET01Ob2RlICYmIHRoaXMucHJvY2Vzc0dyaWRJdGVtKHRoaXMuc3RhdGUuZHJvcHBpbmdET01Ob2RlLCB0cnVlKSwgdGhpcy5wbGFjZWhvbGRlcigpKTtcbiAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUmVhY3RHcmlkTGF5b3V0O1xuLy8gVE9ETyBwdWJsaXNoIGludGVybmFsIFJlYWN0Q2xhc3MgZGlzcGxheU5hbWUgdHJhbnNmb3JtXG5fZGVmaW5lUHJvcGVydHkoUmVhY3RHcmlkTGF5b3V0LCBcImRpc3BsYXlOYW1lXCIsIFwiUmVhY3RHcmlkTGF5b3V0XCIpO1xuLy8gUmVmYWN0b3JlZCB0byBhbm90aGVyIG1vZHVsZSB0byBtYWtlIHdheSBmb3IgcHJldmFsXG5fZGVmaW5lUHJvcGVydHkoUmVhY3RHcmlkTGF5b3V0LCBcInByb3BUeXBlc1wiLCBfUmVhY3RHcmlkTGF5b3V0UHJvcFR5cGVzLmRlZmF1bHQpO1xuX2RlZmluZVByb3BlcnR5KFJlYWN0R3JpZExheW91dCwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICBhdXRvU2l6ZTogdHJ1ZSxcbiAgY29sczogMTIsXG4gIGNsYXNzTmFtZTogXCJcIixcbiAgc3R5bGU6IHt9LFxuICBkcmFnZ2FibGVIYW5kbGU6IFwiXCIsXG4gIGRyYWdnYWJsZUNhbmNlbDogXCJcIixcbiAgY29udGFpbmVyUGFkZGluZzogbnVsbCxcbiAgcm93SGVpZ2h0OiAxNTAsXG4gIG1heFJvd3M6IEluZmluaXR5LFxuICAvLyBpbmZpbml0ZSB2ZXJ0aWNhbCBncm93dGhcbiAgbGF5b3V0OiBbXSxcbiAgbWFyZ2luOiBbMTAsIDEwXSxcbiAgaXNCb3VuZGVkOiBmYWxzZSxcbiAgaXNEcmFnZ2FibGU6IHRydWUsXG4gIGlzUmVzaXphYmxlOiB0cnVlLFxuICBhbGxvd092ZXJsYXA6IGZhbHNlLFxuICBpc0Ryb3BwYWJsZTogZmFsc2UsXG4gIHVzZUNTU1RyYW5zZm9ybXM6IHRydWUsXG4gIHRyYW5zZm9ybVNjYWxlOiAxLFxuICB2ZXJ0aWNhbENvbXBhY3Q6IHRydWUsXG4gIGNvbXBhY3RUeXBlOiBcInZlcnRpY2FsXCIsXG4gIHByZXZlbnRDb2xsaXNpb246IGZhbHNlLFxuICBkcm9wcGluZ0l0ZW06IHtcbiAgICBpOiBcIl9fZHJvcHBpbmctZWxlbV9fXCIsXG4gICAgaDogMSxcbiAgICB3OiAxXG4gIH0sXG4gIHJlc2l6ZUhhbmRsZXM6IFtcInNlXCJdLFxuICBvbkxheW91dENoYW5nZTogX3V0aWxzLm5vb3AsXG4gIG9uRHJhZ1N0YXJ0OiBfdXRpbHMubm9vcCxcbiAgb25EcmFnOiBfdXRpbHMubm9vcCxcbiAgb25EcmFnU3RvcDogX3V0aWxzLm5vb3AsXG4gIG9uUmVzaXplU3RhcnQ6IF91dGlscy5ub29wLFxuICBvblJlc2l6ZTogX3V0aWxzLm5vb3AsXG4gIG9uUmVzaXplU3RvcDogX3V0aWxzLm5vb3AsXG4gIG9uRHJvcDogX3V0aWxzLm5vb3AsXG4gIG9uRHJvcERyYWdPdmVyOiBfdXRpbHMubm9vcFxufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/ReactGridLayout.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js":
/*!**************************************************************************!*\
  !*** ./node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.resizeHandleType = exports.resizeHandleAxesType = exports[\"default\"] = void 0;\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n/*:: import type {\n  Ref,\n  ChildrenArray as ReactChildrenArray,\n  Element as ReactElement\n} from \"react\";*/\n/*:: import type {\n  DragOverEvent,\n  EventCallback,\n  CompactType,\n  Layout,\n  LayoutItem,\n  ResizeHandleAxis\n} from \"./utils\";*/\n/*:: export type ReactRef<T: HTMLElement> = {|\n  +current: T | null\n|};*/\n// util\n/*:: export type ResizeHandle =\n  | ReactElement<any>\n  | ((\n      resizeHandleAxis: ResizeHandleAxis,\n      ref: ReactRef<HTMLElement>\n    ) => ReactElement<any>);*/\n// Defines which resize handles should be rendered (default: 'se')\n// Allows for any combination of:\n// 's' - South handle (bottom-center)\n// 'w' - West handle (left-center)\n// 'e' - East handle (right-center)\n// 'n' - North handle (top-center)\n// 'sw' - Southwest handle (bottom-left)\n// 'nw' - Northwest handle (top-left)\n// 'se' - Southeast handle (bottom-right)\n// 'ne' - Northeast handle (top-right)\nconst resizeHandleAxesType /*: ReactPropsChainableTypeChecker*/ = exports.resizeHandleAxesType = _propTypes.default.arrayOf(_propTypes.default.oneOf([\"s\", \"w\", \"e\", \"n\", \"sw\", \"nw\", \"se\", \"ne\"]));\n// Custom component for resize handles\nconst resizeHandleType /*: ReactPropsChainableTypeChecker*/ = exports.resizeHandleType = _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.func]);\n/*:: export type Props = {|\n  className: string,\n  style: Object,\n  width: number,\n  autoSize: boolean,\n  cols: number,\n  draggableCancel: string,\n  draggableHandle: string,\n  verticalCompact: boolean,\n  compactType: CompactType,\n  layout: Layout,\n  margin: [number, number],\n  containerPadding: ?[number, number],\n  rowHeight: number,\n  maxRows: number,\n  isBounded: boolean,\n  isDraggable: boolean,\n  isResizable: boolean,\n  isDroppable: boolean,\n  preventCollision: boolean,\n  useCSSTransforms: boolean,\n  transformScale: number,\n  droppingItem: $Shape<LayoutItem>,\n  resizeHandles: ResizeHandleAxis[],\n  resizeHandle?: ResizeHandle,\n  allowOverlap: boolean,\n\n  // Callbacks\n  onLayoutChange: Layout => void,\n  onDrag: EventCallback,\n  onDragStart: EventCallback,\n  onDragStop: EventCallback,\n  onResize: EventCallback,\n  onResizeStart: EventCallback,\n  onResizeStop: EventCallback,\n  onDropDragOver: (e: DragOverEvent) => ?({| w?: number, h?: number |} | false),\n  onDrop: (layout: Layout, item: ?LayoutItem, e: Event) => void,\n  children: ReactChildrenArray<ReactElement<any>>,\n  innerRef?: Ref<\"div\">\n|};*/\n/*:: export type DefaultProps = $Diff<\n  Props,\n  {\n    children: ReactChildrenArray<ReactElement<any>>,\n    width: number\n  }\n>;*/\nvar _default = exports[\"default\"] = {\n  //\n  // Basic props\n  //\n  className: _propTypes.default.string,\n  style: _propTypes.default.object,\n  // This can be set explicitly. If it is not set, it will automatically\n  // be set to the container width. Note that resizes will *not* cause this to adjust.\n  // If you need that behavior, use WidthProvider.\n  width: _propTypes.default.number,\n  // If true, the container height swells and contracts to fit contents\n  autoSize: _propTypes.default.bool,\n  // # of cols.\n  cols: _propTypes.default.number,\n  // A selector that will not be draggable.\n  draggableCancel: _propTypes.default.string,\n  // A selector for the draggable handler\n  draggableHandle: _propTypes.default.string,\n  // Deprecated\n  verticalCompact: function (props /*: Props*/) {\n    if (props.verticalCompact === false && \"development\" !== \"production\") {\n      console.warn(\n      // eslint-disable-line no-console\n      \"`verticalCompact` on <ReactGridLayout> is deprecated and will be removed soon. \" + 'Use `compactType`: \"horizontal\" | \"vertical\" | null.');\n    }\n  },\n  // Choose vertical or hotizontal compaction\n  compactType: (_propTypes.default.oneOf([\"vertical\", \"horizontal\"]) /*: ReactPropsChainableTypeChecker*/),\n  // layout is an array of object with the format:\n  // {x: Number, y: Number, w: Number, h: Number, i: String}\n  layout: function (props /*: Props*/) {\n    var layout = props.layout;\n    // I hope you're setting the data-grid property on the grid items\n    if (layout === undefined) return;\n    (__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-grid-layout/build/utils.js\").validateLayout)(layout, \"layout\");\n  },\n  //\n  // Grid Dimensions\n  //\n\n  // Margin between items [x, y] in px\n  margin: (_propTypes.default.arrayOf(_propTypes.default.number) /*: ReactPropsChainableTypeChecker*/),\n  // Padding inside the container [x, y] in px\n  containerPadding: (_propTypes.default.arrayOf(_propTypes.default.number) /*: ReactPropsChainableTypeChecker*/),\n  // Rows have a static height, but you can change this based on breakpoints if you like\n  rowHeight: _propTypes.default.number,\n  // Default Infinity, but you can specify a max here if you like.\n  // Note that this isn't fully fleshed out and won't error if you specify a layout that\n  // extends beyond the row capacity. It will, however, not allow users to drag/resize\n  // an item past the barrier. They can push items beyond the barrier, though.\n  // Intentionally not documented for this reason.\n  maxRows: _propTypes.default.number,\n  //\n  // Flags\n  //\n  isBounded: _propTypes.default.bool,\n  isDraggable: _propTypes.default.bool,\n  isResizable: _propTypes.default.bool,\n  // If true, grid can be placed one over the other.\n  allowOverlap: _propTypes.default.bool,\n  // If true, grid items won't change position when being dragged over.\n  preventCollision: _propTypes.default.bool,\n  // Use CSS transforms instead of top/left\n  useCSSTransforms: _propTypes.default.bool,\n  // parent layout transform scale\n  transformScale: _propTypes.default.number,\n  // If true, an external element can trigger onDrop callback with a specific grid position as a parameter\n  isDroppable: _propTypes.default.bool,\n  // Resize handle options\n  resizeHandles: resizeHandleAxesType,\n  resizeHandle: resizeHandleType,\n  //\n  // Callbacks\n  //\n\n  // Callback so you can save the layout. Calls after each drag & resize stops.\n  onLayoutChange: _propTypes.default.func,\n  // Calls when drag starts. Callback is of the signature (layout, oldItem, newItem, placeholder, e, ?node).\n  // All callbacks below have the same signature. 'start' and 'stop' callbacks omit the 'placeholder'.\n  onDragStart: _propTypes.default.func,\n  // Calls on each drag movement.\n  onDrag: _propTypes.default.func,\n  // Calls when drag is complete.\n  onDragStop: _propTypes.default.func,\n  //Calls when resize starts.\n  onResizeStart: _propTypes.default.func,\n  // Calls when resize movement happens.\n  onResize: _propTypes.default.func,\n  // Calls when resize is complete.\n  onResizeStop: _propTypes.default.func,\n  // Calls when some element is dropped.\n  onDrop: _propTypes.default.func,\n  //\n  // Other validations\n  //\n\n  droppingItem: (_propTypes.default.shape({\n    i: _propTypes.default.string.isRequired,\n    w: _propTypes.default.number.isRequired,\n    h: _propTypes.default.number.isRequired\n  }) /*: ReactPropsChainableTypeChecker*/),\n  // Children must not have duplicate keys.\n  children: function (props /*: Props*/, propName /*: string*/) {\n    const children = props[propName];\n\n    // Check children keys for duplicates. Throw if found.\n    const keys = {};\n    _react.default.Children.forEach(children, function (child) {\n      if (child?.key == null) return;\n      if (keys[child.key]) {\n        throw new Error('Duplicate child key \"' + child.key + '\" found! This will cause problems in ReactGridLayout.');\n      }\n      keys[child.key] = true;\n    });\n  },\n  // Optional ref for getting a reference for the wrapping div.\n  innerRef: _propTypes.default.any\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvUmVhY3RHcmlkTGF5b3V0UHJvcFR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLHdCQUF3QixHQUFHLDRCQUE0QixHQUFHLGtCQUFlO0FBQ3pFLHdDQUF3QyxtQkFBTyxDQUFDLDREQUFZO0FBQzVELG9DQUFvQyxtQkFBTyxDQUFDLHdHQUFPO0FBQ25ELHFDQUFxQyxpQ0FBaUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGFBQWE7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZUFBZTtBQUNqQiw2Q0FBNkM7QUFDN0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLDRCQUE0QjtBQUM5RjtBQUNBLDhEQUE4RCx3QkFBd0I7QUFDdEYsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsNEJBQTRCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsZUFBZSxrQkFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFvQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRHQUFpQztBQUNyQyxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3oxMHRyaWFnZS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvUmVhY3RHcmlkTGF5b3V0UHJvcFR5cGVzLmpzPzMxNDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJlc2l6ZUhhbmRsZVR5cGUgPSBleHBvcnRzLnJlc2l6ZUhhbmRsZUF4ZXNUeXBlID0gZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9OyB9XG4vKjo6IGltcG9ydCB0eXBlIHtcbiAgUmVmLFxuICBDaGlsZHJlbkFycmF5IGFzIFJlYWN0Q2hpbGRyZW5BcnJheSxcbiAgRWxlbWVudCBhcyBSZWFjdEVsZW1lbnRcbn0gZnJvbSBcInJlYWN0XCI7Ki9cbi8qOjogaW1wb3J0IHR5cGUge1xuICBEcmFnT3ZlckV2ZW50LFxuICBFdmVudENhbGxiYWNrLFxuICBDb21wYWN0VHlwZSxcbiAgTGF5b3V0LFxuICBMYXlvdXRJdGVtLFxuICBSZXNpemVIYW5kbGVBeGlzXG59IGZyb20gXCIuL3V0aWxzXCI7Ki9cbi8qOjogZXhwb3J0IHR5cGUgUmVhY3RSZWY8VDogSFRNTEVsZW1lbnQ+ID0ge3xcbiAgK2N1cnJlbnQ6IFQgfCBudWxsXG58fTsqL1xuLy8gdXRpbFxuLyo6OiBleHBvcnQgdHlwZSBSZXNpemVIYW5kbGUgPVxuICB8IFJlYWN0RWxlbWVudDxhbnk+XG4gIHwgKChcbiAgICAgIHJlc2l6ZUhhbmRsZUF4aXM6IFJlc2l6ZUhhbmRsZUF4aXMsXG4gICAgICByZWY6IFJlYWN0UmVmPEhUTUxFbGVtZW50PlxuICAgICkgPT4gUmVhY3RFbGVtZW50PGFueT4pOyovXG4vLyBEZWZpbmVzIHdoaWNoIHJlc2l6ZSBoYW5kbGVzIHNob3VsZCBiZSByZW5kZXJlZCAoZGVmYXVsdDogJ3NlJylcbi8vIEFsbG93cyBmb3IgYW55IGNvbWJpbmF0aW9uIG9mOlxuLy8gJ3MnIC0gU291dGggaGFuZGxlIChib3R0b20tY2VudGVyKVxuLy8gJ3cnIC0gV2VzdCBoYW5kbGUgKGxlZnQtY2VudGVyKVxuLy8gJ2UnIC0gRWFzdCBoYW5kbGUgKHJpZ2h0LWNlbnRlcilcbi8vICduJyAtIE5vcnRoIGhhbmRsZSAodG9wLWNlbnRlcilcbi8vICdzdycgLSBTb3V0aHdlc3QgaGFuZGxlIChib3R0b20tbGVmdClcbi8vICdudycgLSBOb3J0aHdlc3QgaGFuZGxlICh0b3AtbGVmdClcbi8vICdzZScgLSBTb3V0aGVhc3QgaGFuZGxlIChib3R0b20tcmlnaHQpXG4vLyAnbmUnIC0gTm9ydGhlYXN0IGhhbmRsZSAodG9wLXJpZ2h0KVxuY29uc3QgcmVzaXplSGFuZGxlQXhlc1R5cGUgLyo6IFJlYWN0UHJvcHNDaGFpbmFibGVUeXBlQ2hlY2tlciovID0gZXhwb3J0cy5yZXNpemVIYW5kbGVBeGVzVHlwZSA9IF9wcm9wVHlwZXMuZGVmYXVsdC5hcnJheU9mKF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZihbXCJzXCIsIFwid1wiLCBcImVcIiwgXCJuXCIsIFwic3dcIiwgXCJud1wiLCBcInNlXCIsIFwibmVcIl0pKTtcbi8vIEN1c3RvbSBjb21wb25lbnQgZm9yIHJlc2l6ZSBoYW5kbGVzXG5jb25zdCByZXNpemVIYW5kbGVUeXBlIC8qOiBSZWFjdFByb3BzQ2hhaW5hYmxlVHlwZUNoZWNrZXIqLyA9IGV4cG9ydHMucmVzaXplSGFuZGxlVHlwZSA9IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5ub2RlLCBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuY10pO1xuLyo6OiBleHBvcnQgdHlwZSBQcm9wcyA9IHt8XG4gIGNsYXNzTmFtZTogc3RyaW5nLFxuICBzdHlsZTogT2JqZWN0LFxuICB3aWR0aDogbnVtYmVyLFxuICBhdXRvU2l6ZTogYm9vbGVhbixcbiAgY29sczogbnVtYmVyLFxuICBkcmFnZ2FibGVDYW5jZWw6IHN0cmluZyxcbiAgZHJhZ2dhYmxlSGFuZGxlOiBzdHJpbmcsXG4gIHZlcnRpY2FsQ29tcGFjdDogYm9vbGVhbixcbiAgY29tcGFjdFR5cGU6IENvbXBhY3RUeXBlLFxuICBsYXlvdXQ6IExheW91dCxcbiAgbWFyZ2luOiBbbnVtYmVyLCBudW1iZXJdLFxuICBjb250YWluZXJQYWRkaW5nOiA/W251bWJlciwgbnVtYmVyXSxcbiAgcm93SGVpZ2h0OiBudW1iZXIsXG4gIG1heFJvd3M6IG51bWJlcixcbiAgaXNCb3VuZGVkOiBib29sZWFuLFxuICBpc0RyYWdnYWJsZTogYm9vbGVhbixcbiAgaXNSZXNpemFibGU6IGJvb2xlYW4sXG4gIGlzRHJvcHBhYmxlOiBib29sZWFuLFxuICBwcmV2ZW50Q29sbGlzaW9uOiBib29sZWFuLFxuICB1c2VDU1NUcmFuc2Zvcm1zOiBib29sZWFuLFxuICB0cmFuc2Zvcm1TY2FsZTogbnVtYmVyLFxuICBkcm9wcGluZ0l0ZW06ICRTaGFwZTxMYXlvdXRJdGVtPixcbiAgcmVzaXplSGFuZGxlczogUmVzaXplSGFuZGxlQXhpc1tdLFxuICByZXNpemVIYW5kbGU/OiBSZXNpemVIYW5kbGUsXG4gIGFsbG93T3ZlcmxhcDogYm9vbGVhbixcblxuICAvLyBDYWxsYmFja3NcbiAgb25MYXlvdXRDaGFuZ2U6IExheW91dCA9PiB2b2lkLFxuICBvbkRyYWc6IEV2ZW50Q2FsbGJhY2ssXG4gIG9uRHJhZ1N0YXJ0OiBFdmVudENhbGxiYWNrLFxuICBvbkRyYWdTdG9wOiBFdmVudENhbGxiYWNrLFxuICBvblJlc2l6ZTogRXZlbnRDYWxsYmFjayxcbiAgb25SZXNpemVTdGFydDogRXZlbnRDYWxsYmFjayxcbiAgb25SZXNpemVTdG9wOiBFdmVudENhbGxiYWNrLFxuICBvbkRyb3BEcmFnT3ZlcjogKGU6IERyYWdPdmVyRXZlbnQpID0+ID8oe3wgdz86IG51bWJlciwgaD86IG51bWJlciB8fSB8IGZhbHNlKSxcbiAgb25Ecm9wOiAobGF5b3V0OiBMYXlvdXQsIGl0ZW06ID9MYXlvdXRJdGVtLCBlOiBFdmVudCkgPT4gdm9pZCxcbiAgY2hpbGRyZW46IFJlYWN0Q2hpbGRyZW5BcnJheTxSZWFjdEVsZW1lbnQ8YW55Pj4sXG4gIGlubmVyUmVmPzogUmVmPFwiZGl2XCI+XG58fTsqL1xuLyo6OiBleHBvcnQgdHlwZSBEZWZhdWx0UHJvcHMgPSAkRGlmZjxcbiAgUHJvcHMsXG4gIHtcbiAgICBjaGlsZHJlbjogUmVhY3RDaGlsZHJlbkFycmF5PFJlYWN0RWxlbWVudDxhbnk+PixcbiAgICB3aWR0aDogbnVtYmVyXG4gIH1cbj47Ki9cbnZhciBfZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgLy9cbiAgLy8gQmFzaWMgcHJvcHNcbiAgLy9cbiAgY2xhc3NOYW1lOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICBzdHlsZTogX3Byb3BUeXBlcy5kZWZhdWx0Lm9iamVjdCxcbiAgLy8gVGhpcyBjYW4gYmUgc2V0IGV4cGxpY2l0bHkuIElmIGl0IGlzIG5vdCBzZXQsIGl0IHdpbGwgYXV0b21hdGljYWxseVxuICAvLyBiZSBzZXQgdG8gdGhlIGNvbnRhaW5lciB3aWR0aC4gTm90ZSB0aGF0IHJlc2l6ZXMgd2lsbCAqbm90KiBjYXVzZSB0aGlzIHRvIGFkanVzdC5cbiAgLy8gSWYgeW91IG5lZWQgdGhhdCBiZWhhdmlvciwgdXNlIFdpZHRoUHJvdmlkZXIuXG4gIHdpZHRoOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAvLyBJZiB0cnVlLCB0aGUgY29udGFpbmVyIGhlaWdodCBzd2VsbHMgYW5kIGNvbnRyYWN0cyB0byBmaXQgY29udGVudHNcbiAgYXV0b1NpemU6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICAvLyAjIG9mIGNvbHMuXG4gIGNvbHM6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gIC8vIEEgc2VsZWN0b3IgdGhhdCB3aWxsIG5vdCBiZSBkcmFnZ2FibGUuXG4gIGRyYWdnYWJsZUNhbmNlbDogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgLy8gQSBzZWxlY3RvciBmb3IgdGhlIGRyYWdnYWJsZSBoYW5kbGVyXG4gIGRyYWdnYWJsZUhhbmRsZTogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgLy8gRGVwcmVjYXRlZFxuICB2ZXJ0aWNhbENvbXBhY3Q6IGZ1bmN0aW9uIChwcm9wcyAvKjogUHJvcHMqLykge1xuICAgIGlmIChwcm9wcy52ZXJ0aWNhbENvbXBhY3QgPT09IGZhbHNlICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICBcImB2ZXJ0aWNhbENvbXBhY3RgIG9uIDxSZWFjdEdyaWRMYXlvdXQ+IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBzb29uLiBcIiArICdVc2UgYGNvbXBhY3RUeXBlYDogXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCIgfCBudWxsLicpO1xuICAgIH1cbiAgfSxcbiAgLy8gQ2hvb3NlIHZlcnRpY2FsIG9yIGhvdGl6b250YWwgY29tcGFjdGlvblxuICBjb21wYWN0VHlwZTogKF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZihbXCJ2ZXJ0aWNhbFwiLCBcImhvcml6b250YWxcIl0pIC8qOiBSZWFjdFByb3BzQ2hhaW5hYmxlVHlwZUNoZWNrZXIqLyksXG4gIC8vIGxheW91dCBpcyBhbiBhcnJheSBvZiBvYmplY3Qgd2l0aCB0aGUgZm9ybWF0OlxuICAvLyB7eDogTnVtYmVyLCB5OiBOdW1iZXIsIHc6IE51bWJlciwgaDogTnVtYmVyLCBpOiBTdHJpbmd9XG4gIGxheW91dDogZnVuY3Rpb24gKHByb3BzIC8qOiBQcm9wcyovKSB7XG4gICAgdmFyIGxheW91dCA9IHByb3BzLmxheW91dDtcbiAgICAvLyBJIGhvcGUgeW91J3JlIHNldHRpbmcgdGhlIGRhdGEtZ3JpZCBwcm9wZXJ0eSBvbiB0aGUgZ3JpZCBpdGVtc1xuICAgIGlmIChsYXlvdXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIHJlcXVpcmUoXCIuL3V0aWxzXCIpLnZhbGlkYXRlTGF5b3V0KGxheW91dCwgXCJsYXlvdXRcIik7XG4gIH0sXG4gIC8vXG4gIC8vIEdyaWQgRGltZW5zaW9uc1xuICAvL1xuXG4gIC8vIE1hcmdpbiBiZXR3ZWVuIGl0ZW1zIFt4LCB5XSBpbiBweFxuICBtYXJnaW46IChfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXlPZihfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyKSAvKjogUmVhY3RQcm9wc0NoYWluYWJsZVR5cGVDaGVja2VyKi8pLFxuICAvLyBQYWRkaW5nIGluc2lkZSB0aGUgY29udGFpbmVyIFt4LCB5XSBpbiBweFxuICBjb250YWluZXJQYWRkaW5nOiAoX3Byb3BUeXBlcy5kZWZhdWx0LmFycmF5T2YoX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlcikgLyo6IFJlYWN0UHJvcHNDaGFpbmFibGVUeXBlQ2hlY2tlciovKSxcbiAgLy8gUm93cyBoYXZlIGEgc3RhdGljIGhlaWdodCwgYnV0IHlvdSBjYW4gY2hhbmdlIHRoaXMgYmFzZWQgb24gYnJlYWtwb2ludHMgaWYgeW91IGxpa2VcbiAgcm93SGVpZ2h0OiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAvLyBEZWZhdWx0IEluZmluaXR5LCBidXQgeW91IGNhbiBzcGVjaWZ5IGEgbWF4IGhlcmUgaWYgeW91IGxpa2UuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIGlzbid0IGZ1bGx5IGZsZXNoZWQgb3V0IGFuZCB3b24ndCBlcnJvciBpZiB5b3Ugc3BlY2lmeSBhIGxheW91dCB0aGF0XG4gIC8vIGV4dGVuZHMgYmV5b25kIHRoZSByb3cgY2FwYWNpdHkuIEl0IHdpbGwsIGhvd2V2ZXIsIG5vdCBhbGxvdyB1c2VycyB0byBkcmFnL3Jlc2l6ZVxuICAvLyBhbiBpdGVtIHBhc3QgdGhlIGJhcnJpZXIuIFRoZXkgY2FuIHB1c2ggaXRlbXMgYmV5b25kIHRoZSBiYXJyaWVyLCB0aG91Z2guXG4gIC8vIEludGVudGlvbmFsbHkgbm90IGRvY3VtZW50ZWQgZm9yIHRoaXMgcmVhc29uLlxuICBtYXhSb3dzOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAvL1xuICAvLyBGbGFnc1xuICAvL1xuICBpc0JvdW5kZWQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICBpc0RyYWdnYWJsZTogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2wsXG4gIGlzUmVzaXphYmxlOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgLy8gSWYgdHJ1ZSwgZ3JpZCBjYW4gYmUgcGxhY2VkIG9uZSBvdmVyIHRoZSBvdGhlci5cbiAgYWxsb3dPdmVybGFwOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgLy8gSWYgdHJ1ZSwgZ3JpZCBpdGVtcyB3b24ndCBjaGFuZ2UgcG9zaXRpb24gd2hlbiBiZWluZyBkcmFnZ2VkIG92ZXIuXG4gIHByZXZlbnRDb2xsaXNpb246IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICAvLyBVc2UgQ1NTIHRyYW5zZm9ybXMgaW5zdGVhZCBvZiB0b3AvbGVmdFxuICB1c2VDU1NUcmFuc2Zvcm1zOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgLy8gcGFyZW50IGxheW91dCB0cmFuc2Zvcm0gc2NhbGVcbiAgdHJhbnNmb3JtU2NhbGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIsXG4gIC8vIElmIHRydWUsIGFuIGV4dGVybmFsIGVsZW1lbnQgY2FuIHRyaWdnZXIgb25Ecm9wIGNhbGxiYWNrIHdpdGggYSBzcGVjaWZpYyBncmlkIHBvc2l0aW9uIGFzIGEgcGFyYW1ldGVyXG4gIGlzRHJvcHBhYmxlOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgLy8gUmVzaXplIGhhbmRsZSBvcHRpb25zXG4gIHJlc2l6ZUhhbmRsZXM6IHJlc2l6ZUhhbmRsZUF4ZXNUeXBlLFxuICByZXNpemVIYW5kbGU6IHJlc2l6ZUhhbmRsZVR5cGUsXG4gIC8vXG4gIC8vIENhbGxiYWNrc1xuICAvL1xuXG4gIC8vIENhbGxiYWNrIHNvIHlvdSBjYW4gc2F2ZSB0aGUgbGF5b3V0LiBDYWxscyBhZnRlciBlYWNoIGRyYWcgJiByZXNpemUgc3RvcHMuXG4gIG9uTGF5b3V0Q2hhbmdlOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLy8gQ2FsbHMgd2hlbiBkcmFnIHN0YXJ0cy4gQ2FsbGJhY2sgaXMgb2YgdGhlIHNpZ25hdHVyZSAobGF5b3V0LCBvbGRJdGVtLCBuZXdJdGVtLCBwbGFjZWhvbGRlciwgZSwgP25vZGUpLlxuICAvLyBBbGwgY2FsbGJhY2tzIGJlbG93IGhhdmUgdGhlIHNhbWUgc2lnbmF0dXJlLiAnc3RhcnQnIGFuZCAnc3RvcCcgY2FsbGJhY2tzIG9taXQgdGhlICdwbGFjZWhvbGRlcicuXG4gIG9uRHJhZ1N0YXJ0OiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLy8gQ2FsbHMgb24gZWFjaCBkcmFnIG1vdmVtZW50LlxuICBvbkRyYWc6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAvLyBDYWxscyB3aGVuIGRyYWcgaXMgY29tcGxldGUuXG4gIG9uRHJhZ1N0b3A6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICAvL0NhbGxzIHdoZW4gcmVzaXplIHN0YXJ0cy5cbiAgb25SZXNpemVTdGFydDogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8vIENhbGxzIHdoZW4gcmVzaXplIG1vdmVtZW50IGhhcHBlbnMuXG4gIG9uUmVzaXplOiBfcHJvcFR5cGVzLmRlZmF1bHQuZnVuYyxcbiAgLy8gQ2FsbHMgd2hlbiByZXNpemUgaXMgY29tcGxldGUuXG4gIG9uUmVzaXplU3RvcDogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8vIENhbGxzIHdoZW4gc29tZSBlbGVtZW50IGlzIGRyb3BwZWQuXG4gIG9uRHJvcDogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8vXG4gIC8vIE90aGVyIHZhbGlkYXRpb25zXG4gIC8vXG5cbiAgZHJvcHBpbmdJdGVtOiAoX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgICBpOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgdzogX3Byb3BUeXBlcy5kZWZhdWx0Lm51bWJlci5pc1JlcXVpcmVkLFxuICAgIGg6IF9wcm9wVHlwZXMuZGVmYXVsdC5udW1iZXIuaXNSZXF1aXJlZFxuICB9KSAvKjogUmVhY3RQcm9wc0NoYWluYWJsZVR5cGVDaGVja2VyKi8pLFxuICAvLyBDaGlsZHJlbiBtdXN0IG5vdCBoYXZlIGR1cGxpY2F0ZSBrZXlzLlxuICBjaGlsZHJlbjogZnVuY3Rpb24gKHByb3BzIC8qOiBQcm9wcyovLCBwcm9wTmFtZSAvKjogc3RyaW5nKi8pIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHByb3BzW3Byb3BOYW1lXTtcblxuICAgIC8vIENoZWNrIGNoaWxkcmVuIGtleXMgZm9yIGR1cGxpY2F0ZXMuIFRocm93IGlmIGZvdW5kLlxuICAgIGNvbnN0IGtleXMgPSB7fTtcbiAgICBfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZD8ua2V5ID09IG51bGwpIHJldHVybjtcbiAgICAgIGlmIChrZXlzW2NoaWxkLmtleV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEdXBsaWNhdGUgY2hpbGQga2V5IFwiJyArIGNoaWxkLmtleSArICdcIiBmb3VuZCEgVGhpcyB3aWxsIGNhdXNlIHByb2JsZW1zIGluIFJlYWN0R3JpZExheW91dC4nKTtcbiAgICAgIH1cbiAgICAgIGtleXNbY2hpbGQua2V5XSA9IHRydWU7XG4gICAgfSk7XG4gIH0sXG4gIC8vIE9wdGlvbmFsIHJlZiBmb3IgZ2V0dGluZyBhIHJlZmVyZW5jZSBmb3IgdGhlIHdyYXBwaW5nIGRpdi5cbiAgaW5uZXJSZWY6IF9wcm9wVHlwZXMuZGVmYXVsdC5hbnlcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/ReactGridLayoutPropTypes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/ResponsiveReactGridLayout.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-grid-layout/build/ResponsiveReactGridLayout.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\nvar _fastEquals = __webpack_require__(/*! fast-equals */ \"(ssr)/./node_modules/fast-equals/dist/fast-equals.esm.js\");\nvar _utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-grid-layout/build/utils.js\");\nvar _responsiveUtils = __webpack_require__(/*! ./responsiveUtils */ \"(ssr)/./node_modules/react-grid-layout/build/responsiveUtils.js\");\nvar _ReactGridLayout = _interopRequireDefault(__webpack_require__(/*! ./ReactGridLayout */ \"(ssr)/./node_modules/react-grid-layout/build/ReactGridLayout.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) \"default\" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); } /*:: import { type Layout, type Pick } from \"./utils\";*/ /*:: import { type ResponsiveLayout, type OnLayoutChangeCallback, type Breakpoints } from \"./responsiveUtils\";*/\n// $FlowFixMe[method-unbinding]\nconst type = obj => Object.prototype.toString.call(obj);\n\n/**\n * Get a value of margin or containerPadding.\n *\n * @param  {Array | Object} param Margin | containerPadding, e.g. [10, 10] | {lg: [10, 10], ...}.\n * @param  {String} breakpoint   Breakpoint: lg, md, sm, xs and etc.\n * @return {Array}\n */\nfunction getIndentationValue /*:: <T: ?[number, number]>*/(param /*: { [key: string]: T } | T*/, breakpoint /*: string*/) /*: T*/{\n  // $FlowIgnore TODO fix this typedef\n  if (param == null) return null;\n  // $FlowIgnore TODO fix this typedef\n  return Array.isArray(param) ? param : param[breakpoint];\n}\n/*:: type State = {\n  layout: Layout,\n  breakpoint: string,\n  cols: number,\n  layouts?: ResponsiveLayout<string>\n};*/\n/*:: type Props<Breakpoint: string = string> = {|\n  ...React.ElementConfig<typeof ReactGridLayout>,\n\n  // Responsive config\n  breakpoint?: ?Breakpoint,\n  breakpoints: Breakpoints<Breakpoint>,\n  cols: { [key: Breakpoint]: number },\n  layouts: ResponsiveLayout<Breakpoint>,\n  width: number,\n  margin: { [key: Breakpoint]: [number, number] } | [number, number],\n  /* prettier-ignore *-/\n  containerPadding: { [key: Breakpoint]: ?[number, number] } | ?[number, number],\n\n  // Callbacks\n  onBreakpointChange: (Breakpoint, cols: number) => void,\n  onLayoutChange: OnLayoutChangeCallback,\n  onWidthChange: (\n    containerWidth: number,\n    margin: [number, number],\n    cols: number,\n    containerPadding: ?[number, number]\n  ) => void\n|};*/\n/*:: type DefaultProps = Pick<\n  Props<>,\n  {|\n    allowOverlap: 0,\n    breakpoints: 0,\n    cols: 0,\n    containerPadding: 0,\n    layouts: 0,\n    margin: 0,\n    onBreakpointChange: 0,\n    onLayoutChange: 0,\n    onWidthChange: 0\n  |}\n>;*/\nclass ResponsiveReactGridLayout extends React.Component\n/*:: <\n  Props<>,\n  State\n>*/\n{\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", this.generateInitialState());\n    // wrap layouts so we do not need to pass layouts to child\n    _defineProperty(this, \"onLayoutChange\", (layout /*: Layout*/) => {\n      this.props.onLayoutChange(layout, {\n        ...this.props.layouts,\n        [this.state.breakpoint]: layout\n      });\n    });\n  }\n  generateInitialState() /*: State*/{\n    const {\n      width,\n      breakpoints,\n      layouts,\n      cols\n    } = this.props;\n    const breakpoint = (0, _responsiveUtils.getBreakpointFromWidth)(breakpoints, width);\n    const colNo = (0, _responsiveUtils.getColsFromBreakpoint)(breakpoint, cols);\n    // verticalCompact compatibility, now deprecated\n    const compactType = this.props.verticalCompact === false ? null : this.props.compactType;\n    // Get the initial layout. This can tricky; we try to generate one however possible if one doesn't exist\n    // for this layout.\n    const initialLayout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(layouts, breakpoints, breakpoint, breakpoint, colNo, compactType);\n    return {\n      layout: initialLayout,\n      breakpoint: breakpoint,\n      cols: colNo\n    };\n  }\n  static getDerivedStateFromProps(nextProps /*: Props<*>*/, prevState /*: State*/) /*: ?$Shape<State>*/{\n    if (!(0, _fastEquals.deepEqual)(nextProps.layouts, prevState.layouts)) {\n      // Allow parent to set layouts directly.\n      const {\n        breakpoint,\n        cols\n      } = prevState;\n\n      // Since we're setting an entirely new layout object, we must generate a new responsive layout\n      // if one does not exist.\n      const newLayout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(nextProps.layouts, nextProps.breakpoints, breakpoint, breakpoint, cols, nextProps.compactType);\n      return {\n        layout: newLayout,\n        layouts: nextProps.layouts\n      };\n    }\n    return null;\n  }\n  componentDidUpdate(prevProps /*: Props<*>*/) {\n    // Allow parent to set width or breakpoint directly.\n    if (this.props.width != prevProps.width || this.props.breakpoint !== prevProps.breakpoint || !(0, _fastEquals.deepEqual)(this.props.breakpoints, prevProps.breakpoints) || !(0, _fastEquals.deepEqual)(this.props.cols, prevProps.cols)) {\n      this.onWidthChange(prevProps);\n    }\n  }\n  /**\n   * When the width changes work through breakpoints and reset state with the new width & breakpoint.\n   * Width changes are necessary to figure out the widget widths.\n   */\n  onWidthChange(prevProps /*: Props<*>*/) {\n    const {\n      breakpoints,\n      cols,\n      layouts,\n      compactType\n    } = this.props;\n    const newBreakpoint = this.props.breakpoint || (0, _responsiveUtils.getBreakpointFromWidth)(this.props.breakpoints, this.props.width);\n    const lastBreakpoint = this.state.breakpoint;\n    const newCols /*: number*/ = (0, _responsiveUtils.getColsFromBreakpoint)(newBreakpoint, cols);\n    const newLayouts = {\n      ...layouts\n    };\n\n    // Breakpoint change\n    if (lastBreakpoint !== newBreakpoint || prevProps.breakpoints !== breakpoints || prevProps.cols !== cols) {\n      // Preserve the current layout if the current breakpoint is not present in the next layouts.\n      if (!(lastBreakpoint in newLayouts)) newLayouts[lastBreakpoint] = (0, _utils.cloneLayout)(this.state.layout);\n\n      // Find or generate a new layout.\n      let layout = (0, _responsiveUtils.findOrGenerateResponsiveLayout)(newLayouts, breakpoints, newBreakpoint, lastBreakpoint, newCols, compactType);\n\n      // This adds missing items.\n      layout = (0, _utils.synchronizeLayoutWithChildren)(layout, this.props.children, newCols, compactType, this.props.allowOverlap);\n\n      // Store the new layout.\n      newLayouts[newBreakpoint] = layout;\n\n      // callbacks\n      this.props.onBreakpointChange(newBreakpoint, newCols);\n      this.props.onLayoutChange(layout, newLayouts);\n      this.setState({\n        breakpoint: newBreakpoint,\n        layout: layout,\n        cols: newCols\n      });\n    }\n    const margin = getIndentationValue(this.props.margin, newBreakpoint);\n    const containerPadding = getIndentationValue(this.props.containerPadding, newBreakpoint);\n\n    //call onWidthChange on every change of width, not only on breakpoint changes\n    this.props.onWidthChange(this.props.width, margin, newCols, containerPadding);\n  }\n  render() /*: React.Element<typeof ReactGridLayout>*/{\n    /* eslint-disable no-unused-vars */\n    const {\n      breakpoint,\n      breakpoints,\n      cols,\n      layouts,\n      margin,\n      containerPadding,\n      onBreakpointChange,\n      onLayoutChange,\n      onWidthChange,\n      ...other\n    } = this.props;\n    /* eslint-enable no-unused-vars */\n\n    return /*#__PURE__*/React.createElement(_ReactGridLayout.default, _extends({}, other, {\n      // $FlowIgnore should allow nullable here due to DefaultProps\n      margin: getIndentationValue(margin, this.state.breakpoint),\n      containerPadding: getIndentationValue(containerPadding, this.state.breakpoint),\n      onLayoutChange: this.onLayoutChange,\n      layout: this.state.layout,\n      cols: this.state.cols\n    }));\n  }\n}\nexports[\"default\"] = ResponsiveReactGridLayout;\n// This should only include propTypes needed in this code; RGL itself\n// will do validation of the rest props passed to it.\n_defineProperty(ResponsiveReactGridLayout, \"propTypes\", {\n  //\n  // Basic props\n  //\n\n  // Optional, but if you are managing width yourself you may want to set the breakpoint\n  // yourself as well.\n  breakpoint: _propTypes.default.string,\n  // {name: pxVal}, e.g. {lg: 1200, md: 996, sm: 768, xs: 480}\n  breakpoints: _propTypes.default.object,\n  allowOverlap: _propTypes.default.bool,\n  // # of cols. This is a breakpoint -> cols map\n  cols: _propTypes.default.object,\n  // # of margin. This is a breakpoint -> margin map\n  // e.g. { lg: [5, 5], md: [10, 10], sm: [15, 15] }\n  // Margin between items [x, y] in px\n  // e.g. [10, 10]\n  margin: _propTypes.default.oneOfType([_propTypes.default.array, _propTypes.default.object]),\n  // # of containerPadding. This is a breakpoint -> containerPadding map\n  // e.g. { lg: [5, 5], md: [10, 10], sm: [15, 15] }\n  // Padding inside the container [x, y] in px\n  // e.g. [10, 10]\n  containerPadding: _propTypes.default.oneOfType([_propTypes.default.array, _propTypes.default.object]),\n  // layouts is an object mapping breakpoints to layouts.\n  // e.g. {lg: Layout, md: Layout, ...}\n  layouts(props /*: Props<>*/, propName /*: string*/) {\n    if (type(props[propName]) !== \"[object Object]\") {\n      throw new Error(\"Layout property must be an object. Received: \" + type(props[propName]));\n    }\n    Object.keys(props[propName]).forEach(key => {\n      if (!(key in props.breakpoints)) {\n        throw new Error(\"Each key in layouts must align with a key in breakpoints.\");\n      }\n      (0, _utils.validateLayout)(props.layouts[key], \"layouts.\" + key);\n    });\n  },\n  // The width of this component.\n  // Required in this propTypes stanza because generateInitialState() will fail without it.\n  width: _propTypes.default.number.isRequired,\n  //\n  // Callbacks\n  //\n\n  // Calls back with breakpoint and new # cols\n  onBreakpointChange: _propTypes.default.func,\n  // Callback so you can save the layout.\n  // Calls back with (currentLayout, allLayouts). allLayouts are keyed by breakpoint.\n  onLayoutChange: _propTypes.default.func,\n  // Calls back with (containerWidth, margin, cols, containerPadding)\n  onWidthChange: _propTypes.default.func\n});\n_defineProperty(ResponsiveReactGridLayout, \"defaultProps\", {\n  breakpoints: {\n    lg: 1200,\n    md: 996,\n    sm: 768,\n    xs: 480,\n    xxs: 0\n  },\n  cols: {\n    lg: 12,\n    md: 10,\n    sm: 6,\n    xs: 4,\n    xxs: 2\n  },\n  containerPadding: {\n    lg: null,\n    md: null,\n    sm: null,\n    xs: null,\n    xxs: null\n  },\n  layouts: {},\n  margin: [10, 10],\n  allowOverlap: false,\n  onBreakpointChange: _utils.noop,\n  onLayoutChange: _utils.noop,\n  onWidthChange: _utils.noop\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvUmVzcG9uc2l2ZVJlYWN0R3JpZExheW91dC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLG9DQUFvQyxtQkFBTyxDQUFDLHdHQUFPO0FBQ25ELHdDQUF3QyxtQkFBTyxDQUFDLDREQUFZO0FBQzVELGtCQUFrQixtQkFBTyxDQUFDLDZFQUFhO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQyxzRUFBUztBQUM5Qix1QkFBdUIsbUJBQU8sQ0FBQywwRkFBbUI7QUFDbEQsOENBQThDLG1CQUFPLENBQUMsMEZBQW1CO0FBQ3pFLHFDQUFxQyxpQ0FBaUM7QUFDdEUseUNBQXlDLDRFQUE0RSxvREFBb0QsdUNBQXVDLGdCQUFnQiwrQkFBK0IsNEVBQTRFLHFCQUFxQiwrQkFBK0IsZUFBZSx3Q0FBd0MsMkpBQTJKLFdBQVc7QUFDNWxCLHNCQUFzQix3RUFBd0UsZ0JBQWdCLHNCQUFzQixPQUFPLHNCQUFzQixvQkFBb0IsZ0RBQWdELFdBQVc7QUFDaFAsb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsMENBQTBDLCtCQUErQixvQkFBb0IsbUNBQW1DLG9DQUFvQyx1RUFBdUUsZ0RBQWdELGNBQWMseUJBQXlCLGVBQWUsaUJBQWlCLHVFQUF1RSx5QkFBeUI7QUFDaGU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQixrREFBa0Qsa0JBQWtCO0FBQ2hHLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQSx1RUFBdUUsbUJBQW1CO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJCQUEyQjtBQUNyQztBQUNBO0FBQ0EsWUFBWSxzQ0FBc0M7QUFDbEQ7QUFDQSxzQkFBc0IsdUNBQXVDOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUEsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0JBQWU7QUFDZiwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFlBQVksUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vejEwdHJpYWdlLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLWxheW91dC9idWlsZC9SZXNwb25zaXZlUmVhY3RHcmlkTGF5b3V0LmpzP2Q5ZjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgUmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcbnZhciBfZmFzdEVxdWFscyA9IHJlcXVpcmUoXCJmYXN0LWVxdWFsc1wiKTtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBfcmVzcG9uc2l2ZVV0aWxzID0gcmVxdWlyZShcIi4vcmVzcG9uc2l2ZVV0aWxzXCIpO1xudmFyIF9SZWFjdEdyaWRMYXlvdXQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL1JlYWN0R3JpZExheW91dFwiKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9OyB9XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCB0KSB7IGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFdlYWtNYXApIHZhciByID0gbmV3IFdlYWtNYXAoKSwgbiA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSBmdW5jdGlvbiAoZSwgdCkgeyBpZiAoIXQgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlOyB2YXIgbywgaSwgZiA9IHsgX19wcm90b19fOiBudWxsLCBkZWZhdWx0OiBlIH07IGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gdHlwZW9mIGUgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4gZjsgaWYgKG8gPSB0ID8gbiA6IHIpIHsgaWYgKG8uaGFzKGUpKSByZXR1cm4gby5nZXQoZSk7IG8uc2V0KGUsIGYpOyB9IGZvciAoY29uc3QgdCBpbiBlKSBcImRlZmF1bHRcIiAhPT0gdCAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHQpICYmICgoaSA9IChvID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHQpKSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gbyhmLCB0LCBpKSA6IGZbdF0gPSBlW3RdKTsgcmV0dXJuIGY7IH0pKGUsIHQpOyB9XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgcmV0dXJuIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKG4pIHsgZm9yICh2YXIgZSA9IDE7IGUgPCBhcmd1bWVudHMubGVuZ3RoOyBlKyspIHsgdmFyIHQgPSBhcmd1bWVudHNbZV07IGZvciAodmFyIHIgaW4gdCkgKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIHIpICYmIChuW3JdID0gdFtyXSk7IH0gcmV0dXJuIG47IH0sIF9leHRlbmRzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7IHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3JdID0gdCwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH0gLyo6OiBpbXBvcnQgeyB0eXBlIExheW91dCwgdHlwZSBQaWNrIH0gZnJvbSBcIi4vdXRpbHNcIjsqLyAvKjo6IGltcG9ydCB7IHR5cGUgUmVzcG9uc2l2ZUxheW91dCwgdHlwZSBPbkxheW91dENoYW5nZUNhbGxiYWNrLCB0eXBlIEJyZWFrcG9pbnRzIH0gZnJvbSBcIi4vcmVzcG9uc2l2ZVV0aWxzXCI7Ki9cbi8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbmNvbnN0IHR5cGUgPSBvYmogPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG5cbi8qKlxuICogR2V0IGEgdmFsdWUgb2YgbWFyZ2luIG9yIGNvbnRhaW5lclBhZGRpbmcuXG4gKlxuICogQHBhcmFtICB7QXJyYXkgfCBPYmplY3R9IHBhcmFtIE1hcmdpbiB8IGNvbnRhaW5lclBhZGRpbmcsIGUuZy4gWzEwLCAxMF0gfCB7bGc6IFsxMCwgMTBdLCAuLi59LlxuICogQHBhcmFtICB7U3RyaW5nfSBicmVha3BvaW50ICAgQnJlYWtwb2ludDogbGcsIG1kLCBzbSwgeHMgYW5kIGV0Yy5cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiBnZXRJbmRlbnRhdGlvblZhbHVlIC8qOjogPFQ6ID9bbnVtYmVyLCBudW1iZXJdPiovKHBhcmFtIC8qOiB7IFtrZXk6IHN0cmluZ106IFQgfSB8IFQqLywgYnJlYWtwb2ludCAvKjogc3RyaW5nKi8pIC8qOiBUKi97XG4gIC8vICRGbG93SWdub3JlIFRPRE8gZml4IHRoaXMgdHlwZWRlZlxuICBpZiAocGFyYW0gPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIC8vICRGbG93SWdub3JlIFRPRE8gZml4IHRoaXMgdHlwZWRlZlxuICByZXR1cm4gQXJyYXkuaXNBcnJheShwYXJhbSkgPyBwYXJhbSA6IHBhcmFtW2JyZWFrcG9pbnRdO1xufVxuLyo6OiB0eXBlIFN0YXRlID0ge1xuICBsYXlvdXQ6IExheW91dCxcbiAgYnJlYWtwb2ludDogc3RyaW5nLFxuICBjb2xzOiBudW1iZXIsXG4gIGxheW91dHM/OiBSZXNwb25zaXZlTGF5b3V0PHN0cmluZz5cbn07Ki9cbi8qOjogdHlwZSBQcm9wczxCcmVha3BvaW50OiBzdHJpbmcgPSBzdHJpbmc+ID0ge3xcbiAgLi4uUmVhY3QuRWxlbWVudENvbmZpZzx0eXBlb2YgUmVhY3RHcmlkTGF5b3V0PixcblxuICAvLyBSZXNwb25zaXZlIGNvbmZpZ1xuICBicmVha3BvaW50PzogP0JyZWFrcG9pbnQsXG4gIGJyZWFrcG9pbnRzOiBCcmVha3BvaW50czxCcmVha3BvaW50PixcbiAgY29sczogeyBba2V5OiBCcmVha3BvaW50XTogbnVtYmVyIH0sXG4gIGxheW91dHM6IFJlc3BvbnNpdmVMYXlvdXQ8QnJlYWtwb2ludD4sXG4gIHdpZHRoOiBudW1iZXIsXG4gIG1hcmdpbjogeyBba2V5OiBCcmVha3BvaW50XTogW251bWJlciwgbnVtYmVyXSB9IHwgW251bWJlciwgbnVtYmVyXSxcbiAgLyogcHJldHRpZXItaWdub3JlICotL1xuICBjb250YWluZXJQYWRkaW5nOiB7IFtrZXk6IEJyZWFrcG9pbnRdOiA/W251bWJlciwgbnVtYmVyXSB9IHwgP1tudW1iZXIsIG51bWJlcl0sXG5cbiAgLy8gQ2FsbGJhY2tzXG4gIG9uQnJlYWtwb2ludENoYW5nZTogKEJyZWFrcG9pbnQsIGNvbHM6IG51bWJlcikgPT4gdm9pZCxcbiAgb25MYXlvdXRDaGFuZ2U6IE9uTGF5b3V0Q2hhbmdlQ2FsbGJhY2ssXG4gIG9uV2lkdGhDaGFuZ2U6IChcbiAgICBjb250YWluZXJXaWR0aDogbnVtYmVyLFxuICAgIG1hcmdpbjogW251bWJlciwgbnVtYmVyXSxcbiAgICBjb2xzOiBudW1iZXIsXG4gICAgY29udGFpbmVyUGFkZGluZzogP1tudW1iZXIsIG51bWJlcl1cbiAgKSA9PiB2b2lkXG58fTsqL1xuLyo6OiB0eXBlIERlZmF1bHRQcm9wcyA9IFBpY2s8XG4gIFByb3BzPD4sXG4gIHt8XG4gICAgYWxsb3dPdmVybGFwOiAwLFxuICAgIGJyZWFrcG9pbnRzOiAwLFxuICAgIGNvbHM6IDAsXG4gICAgY29udGFpbmVyUGFkZGluZzogMCxcbiAgICBsYXlvdXRzOiAwLFxuICAgIG1hcmdpbjogMCxcbiAgICBvbkJyZWFrcG9pbnRDaGFuZ2U6IDAsXG4gICAgb25MYXlvdXRDaGFuZ2U6IDAsXG4gICAgb25XaWR0aENoYW5nZTogMFxuICB8fVxuPjsqL1xuY2xhc3MgUmVzcG9uc2l2ZVJlYWN0R3JpZExheW91dCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFxuLyo6OiA8XG4gIFByb3BzPD4sXG4gIFN0YXRlXG4+Ki9cbntcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB0aGlzLmdlbmVyYXRlSW5pdGlhbFN0YXRlKCkpO1xuICAgIC8vIHdyYXAgbGF5b3V0cyBzbyB3ZSBkbyBub3QgbmVlZCB0byBwYXNzIGxheW91dHMgdG8gY2hpbGRcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkxheW91dENoYW5nZVwiLCAobGF5b3V0IC8qOiBMYXlvdXQqLykgPT4ge1xuICAgICAgdGhpcy5wcm9wcy5vbkxheW91dENoYW5nZShsYXlvdXQsIHtcbiAgICAgICAgLi4udGhpcy5wcm9wcy5sYXlvdXRzLFxuICAgICAgICBbdGhpcy5zdGF0ZS5icmVha3BvaW50XTogbGF5b3V0XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBnZW5lcmF0ZUluaXRpYWxTdGF0ZSgpIC8qOiBTdGF0ZSove1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgYnJlYWtwb2ludHMsXG4gICAgICBsYXlvdXRzLFxuICAgICAgY29sc1xuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGJyZWFrcG9pbnQgPSAoMCwgX3Jlc3BvbnNpdmVVdGlscy5nZXRCcmVha3BvaW50RnJvbVdpZHRoKShicmVha3BvaW50cywgd2lkdGgpO1xuICAgIGNvbnN0IGNvbE5vID0gKDAsIF9yZXNwb25zaXZlVXRpbHMuZ2V0Q29sc0Zyb21CcmVha3BvaW50KShicmVha3BvaW50LCBjb2xzKTtcbiAgICAvLyB2ZXJ0aWNhbENvbXBhY3QgY29tcGF0aWJpbGl0eSwgbm93IGRlcHJlY2F0ZWRcbiAgICBjb25zdCBjb21wYWN0VHlwZSA9IHRoaXMucHJvcHMudmVydGljYWxDb21wYWN0ID09PSBmYWxzZSA/IG51bGwgOiB0aGlzLnByb3BzLmNvbXBhY3RUeXBlO1xuICAgIC8vIEdldCB0aGUgaW5pdGlhbCBsYXlvdXQuIFRoaXMgY2FuIHRyaWNreTsgd2UgdHJ5IHRvIGdlbmVyYXRlIG9uZSBob3dldmVyIHBvc3NpYmxlIGlmIG9uZSBkb2Vzbid0IGV4aXN0XG4gICAgLy8gZm9yIHRoaXMgbGF5b3V0LlxuICAgIGNvbnN0IGluaXRpYWxMYXlvdXQgPSAoMCwgX3Jlc3BvbnNpdmVVdGlscy5maW5kT3JHZW5lcmF0ZVJlc3BvbnNpdmVMYXlvdXQpKGxheW91dHMsIGJyZWFrcG9pbnRzLCBicmVha3BvaW50LCBicmVha3BvaW50LCBjb2xObywgY29tcGFjdFR5cGUpO1xuICAgIHJldHVybiB7XG4gICAgICBsYXlvdXQ6IGluaXRpYWxMYXlvdXQsXG4gICAgICBicmVha3BvaW50OiBicmVha3BvaW50LFxuICAgICAgY29sczogY29sTm9cbiAgICB9O1xuICB9XG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzIC8qOiBQcm9wczwqPiovLCBwcmV2U3RhdGUgLyo6IFN0YXRlKi8pIC8qOiA/JFNoYXBlPFN0YXRlPiove1xuICAgIGlmICghKDAsIF9mYXN0RXF1YWxzLmRlZXBFcXVhbCkobmV4dFByb3BzLmxheW91dHMsIHByZXZTdGF0ZS5sYXlvdXRzKSkge1xuICAgICAgLy8gQWxsb3cgcGFyZW50IHRvIHNldCBsYXlvdXRzIGRpcmVjdGx5LlxuICAgICAgY29uc3Qge1xuICAgICAgICBicmVha3BvaW50LFxuICAgICAgICBjb2xzXG4gICAgICB9ID0gcHJldlN0YXRlO1xuXG4gICAgICAvLyBTaW5jZSB3ZSdyZSBzZXR0aW5nIGFuIGVudGlyZWx5IG5ldyBsYXlvdXQgb2JqZWN0LCB3ZSBtdXN0IGdlbmVyYXRlIGEgbmV3IHJlc3BvbnNpdmUgbGF5b3V0XG4gICAgICAvLyBpZiBvbmUgZG9lcyBub3QgZXhpc3QuXG4gICAgICBjb25zdCBuZXdMYXlvdXQgPSAoMCwgX3Jlc3BvbnNpdmVVdGlscy5maW5kT3JHZW5lcmF0ZVJlc3BvbnNpdmVMYXlvdXQpKG5leHRQcm9wcy5sYXlvdXRzLCBuZXh0UHJvcHMuYnJlYWtwb2ludHMsIGJyZWFrcG9pbnQsIGJyZWFrcG9pbnQsIGNvbHMsIG5leHRQcm9wcy5jb21wYWN0VHlwZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYXlvdXQ6IG5ld0xheW91dCxcbiAgICAgICAgbGF5b3V0czogbmV4dFByb3BzLmxheW91dHNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMgLyo6IFByb3BzPCo+Ki8pIHtcbiAgICAvLyBBbGxvdyBwYXJlbnQgdG8gc2V0IHdpZHRoIG9yIGJyZWFrcG9pbnQgZGlyZWN0bHkuXG4gICAgaWYgKHRoaXMucHJvcHMud2lkdGggIT0gcHJldlByb3BzLndpZHRoIHx8IHRoaXMucHJvcHMuYnJlYWtwb2ludCAhPT0gcHJldlByb3BzLmJyZWFrcG9pbnQgfHwgISgwLCBfZmFzdEVxdWFscy5kZWVwRXF1YWwpKHRoaXMucHJvcHMuYnJlYWtwb2ludHMsIHByZXZQcm9wcy5icmVha3BvaW50cykgfHwgISgwLCBfZmFzdEVxdWFscy5kZWVwRXF1YWwpKHRoaXMucHJvcHMuY29scywgcHJldlByb3BzLmNvbHMpKSB7XG4gICAgICB0aGlzLm9uV2lkdGhDaGFuZ2UocHJldlByb3BzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHdpZHRoIGNoYW5nZXMgd29yayB0aHJvdWdoIGJyZWFrcG9pbnRzIGFuZCByZXNldCBzdGF0ZSB3aXRoIHRoZSBuZXcgd2lkdGggJiBicmVha3BvaW50LlxuICAgKiBXaWR0aCBjaGFuZ2VzIGFyZSBuZWNlc3NhcnkgdG8gZmlndXJlIG91dCB0aGUgd2lkZ2V0IHdpZHRocy5cbiAgICovXG4gIG9uV2lkdGhDaGFuZ2UocHJldlByb3BzIC8qOiBQcm9wczwqPiovKSB7XG4gICAgY29uc3Qge1xuICAgICAgYnJlYWtwb2ludHMsXG4gICAgICBjb2xzLFxuICAgICAgbGF5b3V0cyxcbiAgICAgIGNvbXBhY3RUeXBlXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgbmV3QnJlYWtwb2ludCA9IHRoaXMucHJvcHMuYnJlYWtwb2ludCB8fCAoMCwgX3Jlc3BvbnNpdmVVdGlscy5nZXRCcmVha3BvaW50RnJvbVdpZHRoKSh0aGlzLnByb3BzLmJyZWFrcG9pbnRzLCB0aGlzLnByb3BzLndpZHRoKTtcbiAgICBjb25zdCBsYXN0QnJlYWtwb2ludCA9IHRoaXMuc3RhdGUuYnJlYWtwb2ludDtcbiAgICBjb25zdCBuZXdDb2xzIC8qOiBudW1iZXIqLyA9ICgwLCBfcmVzcG9uc2l2ZVV0aWxzLmdldENvbHNGcm9tQnJlYWtwb2ludCkobmV3QnJlYWtwb2ludCwgY29scyk7XG4gICAgY29uc3QgbmV3TGF5b3V0cyA9IHtcbiAgICAgIC4uLmxheW91dHNcbiAgICB9O1xuXG4gICAgLy8gQnJlYWtwb2ludCBjaGFuZ2VcbiAgICBpZiAobGFzdEJyZWFrcG9pbnQgIT09IG5ld0JyZWFrcG9pbnQgfHwgcHJldlByb3BzLmJyZWFrcG9pbnRzICE9PSBicmVha3BvaW50cyB8fCBwcmV2UHJvcHMuY29scyAhPT0gY29scykge1xuICAgICAgLy8gUHJlc2VydmUgdGhlIGN1cnJlbnQgbGF5b3V0IGlmIHRoZSBjdXJyZW50IGJyZWFrcG9pbnQgaXMgbm90IHByZXNlbnQgaW4gdGhlIG5leHQgbGF5b3V0cy5cbiAgICAgIGlmICghKGxhc3RCcmVha3BvaW50IGluIG5ld0xheW91dHMpKSBuZXdMYXlvdXRzW2xhc3RCcmVha3BvaW50XSA9ICgwLCBfdXRpbHMuY2xvbmVMYXlvdXQpKHRoaXMuc3RhdGUubGF5b3V0KTtcblxuICAgICAgLy8gRmluZCBvciBnZW5lcmF0ZSBhIG5ldyBsYXlvdXQuXG4gICAgICBsZXQgbGF5b3V0ID0gKDAsIF9yZXNwb25zaXZlVXRpbHMuZmluZE9yR2VuZXJhdGVSZXNwb25zaXZlTGF5b3V0KShuZXdMYXlvdXRzLCBicmVha3BvaW50cywgbmV3QnJlYWtwb2ludCwgbGFzdEJyZWFrcG9pbnQsIG5ld0NvbHMsIGNvbXBhY3RUeXBlKTtcblxuICAgICAgLy8gVGhpcyBhZGRzIG1pc3NpbmcgaXRlbXMuXG4gICAgICBsYXlvdXQgPSAoMCwgX3V0aWxzLnN5bmNocm9uaXplTGF5b3V0V2l0aENoaWxkcmVuKShsYXlvdXQsIHRoaXMucHJvcHMuY2hpbGRyZW4sIG5ld0NvbHMsIGNvbXBhY3RUeXBlLCB0aGlzLnByb3BzLmFsbG93T3ZlcmxhcCk7XG5cbiAgICAgIC8vIFN0b3JlIHRoZSBuZXcgbGF5b3V0LlxuICAgICAgbmV3TGF5b3V0c1tuZXdCcmVha3BvaW50XSA9IGxheW91dDtcblxuICAgICAgLy8gY2FsbGJhY2tzXG4gICAgICB0aGlzLnByb3BzLm9uQnJlYWtwb2ludENoYW5nZShuZXdCcmVha3BvaW50LCBuZXdDb2xzKTtcbiAgICAgIHRoaXMucHJvcHMub25MYXlvdXRDaGFuZ2UobGF5b3V0LCBuZXdMYXlvdXRzKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBicmVha3BvaW50OiBuZXdCcmVha3BvaW50LFxuICAgICAgICBsYXlvdXQ6IGxheW91dCxcbiAgICAgICAgY29sczogbmV3Q29sc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1hcmdpbiA9IGdldEluZGVudGF0aW9uVmFsdWUodGhpcy5wcm9wcy5tYXJnaW4sIG5ld0JyZWFrcG9pbnQpO1xuICAgIGNvbnN0IGNvbnRhaW5lclBhZGRpbmcgPSBnZXRJbmRlbnRhdGlvblZhbHVlKHRoaXMucHJvcHMuY29udGFpbmVyUGFkZGluZywgbmV3QnJlYWtwb2ludCk7XG5cbiAgICAvL2NhbGwgb25XaWR0aENoYW5nZSBvbiBldmVyeSBjaGFuZ2Ugb2Ygd2lkdGgsIG5vdCBvbmx5IG9uIGJyZWFrcG9pbnQgY2hhbmdlc1xuICAgIHRoaXMucHJvcHMub25XaWR0aENoYW5nZSh0aGlzLnByb3BzLndpZHRoLCBtYXJnaW4sIG5ld0NvbHMsIGNvbnRhaW5lclBhZGRpbmcpO1xuICB9XG4gIHJlbmRlcigpIC8qOiBSZWFjdC5FbGVtZW50PHR5cGVvZiBSZWFjdEdyaWRMYXlvdXQ+Ki97XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICBjb25zdCB7XG4gICAgICBicmVha3BvaW50LFxuICAgICAgYnJlYWtwb2ludHMsXG4gICAgICBjb2xzLFxuICAgICAgbGF5b3V0cyxcbiAgICAgIG1hcmdpbixcbiAgICAgIGNvbnRhaW5lclBhZGRpbmcsXG4gICAgICBvbkJyZWFrcG9pbnRDaGFuZ2UsXG4gICAgICBvbkxheW91dENoYW5nZSxcbiAgICAgIG9uV2lkdGhDaGFuZ2UsXG4gICAgICAuLi5vdGhlclxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChfUmVhY3RHcmlkTGF5b3V0LmRlZmF1bHQsIF9leHRlbmRzKHt9LCBvdGhlciwge1xuICAgICAgLy8gJEZsb3dJZ25vcmUgc2hvdWxkIGFsbG93IG51bGxhYmxlIGhlcmUgZHVlIHRvIERlZmF1bHRQcm9wc1xuICAgICAgbWFyZ2luOiBnZXRJbmRlbnRhdGlvblZhbHVlKG1hcmdpbiwgdGhpcy5zdGF0ZS5icmVha3BvaW50KSxcbiAgICAgIGNvbnRhaW5lclBhZGRpbmc6IGdldEluZGVudGF0aW9uVmFsdWUoY29udGFpbmVyUGFkZGluZywgdGhpcy5zdGF0ZS5icmVha3BvaW50KSxcbiAgICAgIG9uTGF5b3V0Q2hhbmdlOiB0aGlzLm9uTGF5b3V0Q2hhbmdlLFxuICAgICAgbGF5b3V0OiB0aGlzLnN0YXRlLmxheW91dCxcbiAgICAgIGNvbHM6IHRoaXMuc3RhdGUuY29sc1xuICAgIH0pKTtcbiAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUmVzcG9uc2l2ZVJlYWN0R3JpZExheW91dDtcbi8vIFRoaXMgc2hvdWxkIG9ubHkgaW5jbHVkZSBwcm9wVHlwZXMgbmVlZGVkIGluIHRoaXMgY29kZTsgUkdMIGl0c2VsZlxuLy8gd2lsbCBkbyB2YWxpZGF0aW9uIG9mIHRoZSByZXN0IHByb3BzIHBhc3NlZCB0byBpdC5cbl9kZWZpbmVQcm9wZXJ0eShSZXNwb25zaXZlUmVhY3RHcmlkTGF5b3V0LCBcInByb3BUeXBlc1wiLCB7XG4gIC8vXG4gIC8vIEJhc2ljIHByb3BzXG4gIC8vXG5cbiAgLy8gT3B0aW9uYWwsIGJ1dCBpZiB5b3UgYXJlIG1hbmFnaW5nIHdpZHRoIHlvdXJzZWxmIHlvdSBtYXkgd2FudCB0byBzZXQgdGhlIGJyZWFrcG9pbnRcbiAgLy8geW91cnNlbGYgYXMgd2VsbC5cbiAgYnJlYWtwb2ludDogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgLy8ge25hbWU6IHB4VmFsfSwgZS5nLiB7bGc6IDEyMDAsIG1kOiA5OTYsIHNtOiA3NjgsIHhzOiA0ODB9XG4gIGJyZWFrcG9pbnRzOiBfcHJvcFR5cGVzLmRlZmF1bHQub2JqZWN0LFxuICBhbGxvd092ZXJsYXA6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICAvLyAjIG9mIGNvbHMuIFRoaXMgaXMgYSBicmVha3BvaW50IC0+IGNvbHMgbWFwXG4gIGNvbHM6IF9wcm9wVHlwZXMuZGVmYXVsdC5vYmplY3QsXG4gIC8vICMgb2YgbWFyZ2luLiBUaGlzIGlzIGEgYnJlYWtwb2ludCAtPiBtYXJnaW4gbWFwXG4gIC8vIGUuZy4geyBsZzogWzUsIDVdLCBtZDogWzEwLCAxMF0sIHNtOiBbMTUsIDE1XSB9XG4gIC8vIE1hcmdpbiBiZXR3ZWVuIGl0ZW1zIFt4LCB5XSBpbiBweFxuICAvLyBlLmcuIFsxMCwgMTBdXG4gIG1hcmdpbjogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0LmFycmF5LCBfcHJvcFR5cGVzLmRlZmF1bHQub2JqZWN0XSksXG4gIC8vICMgb2YgY29udGFpbmVyUGFkZGluZy4gVGhpcyBpcyBhIGJyZWFrcG9pbnQgLT4gY29udGFpbmVyUGFkZGluZyBtYXBcbiAgLy8gZS5nLiB7IGxnOiBbNSwgNV0sIG1kOiBbMTAsIDEwXSwgc206IFsxNSwgMTVdIH1cbiAgLy8gUGFkZGluZyBpbnNpZGUgdGhlIGNvbnRhaW5lciBbeCwgeV0gaW4gcHhcbiAgLy8gZS5nLiBbMTAsIDEwXVxuICBjb250YWluZXJQYWRkaW5nOiBfcHJvcFR5cGVzLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzLmRlZmF1bHQuYXJyYXksIF9wcm9wVHlwZXMuZGVmYXVsdC5vYmplY3RdKSxcbiAgLy8gbGF5b3V0cyBpcyBhbiBvYmplY3QgbWFwcGluZyBicmVha3BvaW50cyB0byBsYXlvdXRzLlxuICAvLyBlLmcuIHtsZzogTGF5b3V0LCBtZDogTGF5b3V0LCAuLi59XG4gIGxheW91dHMocHJvcHMgLyo6IFByb3BzPD4qLywgcHJvcE5hbWUgLyo6IHN0cmluZyovKSB7XG4gICAgaWYgKHR5cGUocHJvcHNbcHJvcE5hbWVdKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGF5b3V0IHByb3BlcnR5IG11c3QgYmUgYW4gb2JqZWN0LiBSZWNlaXZlZDogXCIgKyB0eXBlKHByb3BzW3Byb3BOYW1lXSkpO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhwcm9wc1twcm9wTmFtZV0pLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmICghKGtleSBpbiBwcm9wcy5icmVha3BvaW50cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWFjaCBrZXkgaW4gbGF5b3V0cyBtdXN0IGFsaWduIHdpdGggYSBrZXkgaW4gYnJlYWtwb2ludHMuXCIpO1xuICAgICAgfVxuICAgICAgKDAsIF91dGlscy52YWxpZGF0ZUxheW91dCkocHJvcHMubGF5b3V0c1trZXldLCBcImxheW91dHMuXCIgKyBrZXkpO1xuICAgIH0pO1xuICB9LFxuICAvLyBUaGUgd2lkdGggb2YgdGhpcyBjb21wb25lbnQuXG4gIC8vIFJlcXVpcmVkIGluIHRoaXMgcHJvcFR5cGVzIHN0YW56YSBiZWNhdXNlIGdlbmVyYXRlSW5pdGlhbFN0YXRlKCkgd2lsbCBmYWlsIHdpdGhvdXQgaXQuXG4gIHdpZHRoOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLmlzUmVxdWlyZWQsXG4gIC8vXG4gIC8vIENhbGxiYWNrc1xuICAvL1xuXG4gIC8vIENhbGxzIGJhY2sgd2l0aCBicmVha3BvaW50IGFuZCBuZXcgIyBjb2xzXG4gIG9uQnJlYWtwb2ludENoYW5nZTogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8vIENhbGxiYWNrIHNvIHlvdSBjYW4gc2F2ZSB0aGUgbGF5b3V0LlxuICAvLyBDYWxscyBiYWNrIHdpdGggKGN1cnJlbnRMYXlvdXQsIGFsbExheW91dHMpLiBhbGxMYXlvdXRzIGFyZSBrZXllZCBieSBicmVha3BvaW50LlxuICBvbkxheW91dENoYW5nZTogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIC8vIENhbGxzIGJhY2sgd2l0aCAoY29udGFpbmVyV2lkdGgsIG1hcmdpbiwgY29scywgY29udGFpbmVyUGFkZGluZylcbiAgb25XaWR0aENoYW5nZTogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmNcbn0pO1xuX2RlZmluZVByb3BlcnR5KFJlc3BvbnNpdmVSZWFjdEdyaWRMYXlvdXQsIFwiZGVmYXVsdFByb3BzXCIsIHtcbiAgYnJlYWtwb2ludHM6IHtcbiAgICBsZzogMTIwMCxcbiAgICBtZDogOTk2LFxuICAgIHNtOiA3NjgsXG4gICAgeHM6IDQ4MCxcbiAgICB4eHM6IDBcbiAgfSxcbiAgY29sczoge1xuICAgIGxnOiAxMixcbiAgICBtZDogMTAsXG4gICAgc206IDYsXG4gICAgeHM6IDQsXG4gICAgeHhzOiAyXG4gIH0sXG4gIGNvbnRhaW5lclBhZGRpbmc6IHtcbiAgICBsZzogbnVsbCxcbiAgICBtZDogbnVsbCxcbiAgICBzbTogbnVsbCxcbiAgICB4czogbnVsbCxcbiAgICB4eHM6IG51bGxcbiAgfSxcbiAgbGF5b3V0czoge30sXG4gIG1hcmdpbjogWzEwLCAxMF0sXG4gIGFsbG93T3ZlcmxhcDogZmFsc2UsXG4gIG9uQnJlYWtwb2ludENoYW5nZTogX3V0aWxzLm5vb3AsXG4gIG9uTGF5b3V0Q2hhbmdlOiBfdXRpbHMubm9vcCxcbiAgb25XaWR0aENoYW5nZTogX3V0aWxzLm5vb3Bcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/ResponsiveReactGridLayout.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/calculateUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-grid-layout/build/calculateUtils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.calcGridColWidth = calcGridColWidth;\nexports.calcGridItemPosition = calcGridItemPosition;\nexports.calcGridItemWHPx = calcGridItemWHPx;\nexports.calcWH = calcWH;\nexports.calcXY = calcXY;\nexports.clamp = clamp;\n/*:: import type { Position } from \"./utils\";*/\n/*:: export type PositionParams = {\n  margin: [number, number],\n  containerPadding: [number, number],\n  containerWidth: number,\n  cols: number,\n  rowHeight: number,\n  maxRows: number\n};*/\n// Helper for generating column width\nfunction calcGridColWidth(positionParams /*: PositionParams*/) /*: number*/{\n  const {\n    margin,\n    containerPadding,\n    containerWidth,\n    cols\n  } = positionParams;\n  return (containerWidth - margin[0] * (cols - 1) - containerPadding[0] * 2) / cols;\n}\n\n// This can either be called:\n// calcGridItemWHPx(w, colWidth, margin[0])\n// or\n// calcGridItemWHPx(h, rowHeight, margin[1])\nfunction calcGridItemWHPx(gridUnits /*: number*/, colOrRowSize /*: number*/, marginPx /*: number*/) /*: number*/{\n  // 0 * Infinity === NaN, which causes problems with resize contraints\n  if (!Number.isFinite(gridUnits)) return gridUnits;\n  return Math.round(colOrRowSize * gridUnits + Math.max(0, gridUnits - 1) * marginPx);\n}\n\n/**\n * Return position on the page given an x, y, w, h.\n * left, top, width, height are all in pixels.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number}  x                      X coordinate in grid units.\n * @param  {Number}  y                      Y coordinate in grid units.\n * @param  {Number}  w                      W coordinate in grid units.\n * @param  {Number}  h                      H coordinate in grid units.\n * @return {Position}                       Object containing coords.\n */\nfunction calcGridItemPosition(positionParams /*: PositionParams*/, x /*: number*/, y /*: number*/, w /*: number*/, h /*: number*/, state /*: ?Object*/) /*: Position*/{\n  const {\n    margin,\n    containerPadding,\n    rowHeight\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n  const out = {};\n\n  // If resizing, use the exact width and height as returned from resizing callbacks.\n  if (state && state.resizing) {\n    out.width = Math.round(state.resizing.width);\n    out.height = Math.round(state.resizing.height);\n  }\n  // Otherwise, calculate from grid units.\n  else {\n    out.width = calcGridItemWHPx(w, colWidth, margin[0]);\n    out.height = calcGridItemWHPx(h, rowHeight, margin[1]);\n  }\n\n  // If dragging, use the exact width and height as returned from dragging callbacks.\n  if (state && state.dragging) {\n    out.top = Math.round(state.dragging.top);\n    out.left = Math.round(state.dragging.left);\n  } else if (state && state.resizing && typeof state.resizing.top === \"number\" && typeof state.resizing.left === \"number\") {\n    out.top = Math.round(state.resizing.top);\n    out.left = Math.round(state.resizing.left);\n  }\n  // Otherwise, calculate from grid units.\n  else {\n    out.top = Math.round((rowHeight + margin[1]) * y + containerPadding[1]);\n    out.left = Math.round((colWidth + margin[0]) * x + containerPadding[0]);\n  }\n  return out;\n}\n\n/**\n * Translate x and y coordinates from pixels to grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calculations.\n * @param  {Number} top                     Top position (relative to parent) in pixels.\n * @param  {Number} left                    Left position (relative to parent) in pixels.\n * @param  {Number} w                       W coordinate in grid units.\n * @param  {Number} h                       H coordinate in grid units.\n * @return {Object}                         x and y in grid units.\n */\nfunction calcXY(positionParams /*: PositionParams*/, top /*: number*/, left /*: number*/, w /*: number*/, h /*: number*/) /*: { x: number, y: number }*/{\n  const {\n    margin,\n    containerPadding,\n    cols,\n    rowHeight,\n    maxRows\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n\n  // left = containerPaddingX + x * (colWidth + marginX)\n  // x * (colWidth + marginX) = left - containerPaddingX\n  // x = (left - containerPaddingX) / (colWidth + marginX)\n  let x = Math.round((left - containerPadding[0]) / (colWidth + margin[0]));\n  let y = Math.round((top - containerPadding[1]) / (rowHeight + margin[1]));\n\n  // Capping\n  x = clamp(x, 0, cols - w);\n  y = clamp(y, 0, maxRows - h);\n  return {\n    x,\n    y\n  };\n}\n\n/**\n * Given a height and width in pixel values, calculate grid units.\n * @param  {PositionParams} positionParams  Parameters of grid needed for coordinates calcluations.\n * @param  {Number} height                  Height in pixels.\n * @param  {Number} width                   Width in pixels.\n * @param  {Number} x                       X coordinate in grid units.\n * @param  {Number} y                       Y coordinate in grid units.\n * @param {String} handle Resize Handle.\n * @return {Object}                         w, h as grid units.\n */\nfunction calcWH(positionParams /*: PositionParams*/, width /*: number*/, height /*: number*/, x /*: number*/, y /*: number*/, handle /*: string*/) /*: { w: number, h: number }*/{\n  const {\n    margin,\n    maxRows,\n    cols,\n    rowHeight\n  } = positionParams;\n  const colWidth = calcGridColWidth(positionParams);\n\n  // width = colWidth * w - (margin * (w - 1))\n  // ...\n  // w = (width + margin) / (colWidth + margin)\n  let w = Math.round((width + margin[0]) / (colWidth + margin[0]));\n  let h = Math.round((height + margin[1]) / (rowHeight + margin[1]));\n\n  // Capping\n  let _w = clamp(w, 0, cols - x);\n  let _h = clamp(h, 0, maxRows - y);\n  if ([\"sw\", \"w\", \"nw\"].indexOf(handle) !== -1) {\n    _w = clamp(w, 0, cols);\n  }\n  if ([\"nw\", \"n\", \"ne\"].indexOf(handle) !== -1) {\n    _h = clamp(h, 0, maxRows);\n  }\n  return {\n    w: _w,\n    h: _h\n  };\n}\n\n// Similar to _.clamp\nfunction clamp(num /*: number*/, lowerBound /*: number*/, upperBound /*: number*/) /*: number*/{\n  return Math.max(Math.min(num, upperBound), lowerBound);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvY2FsY3VsYXRlVXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0JBQXdCO0FBQ3hCLDRCQUE0QjtBQUM1Qix3QkFBd0I7QUFDeEIsY0FBYztBQUNkLGNBQWM7QUFDZCxhQUFhO0FBQ2IsbUJBQW1CLFdBQVcsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QixZQUFZLFNBQVM7QUFDckIsWUFBWSxTQUFTO0FBQ3JCLFlBQVksU0FBUztBQUNyQixZQUFZLFNBQVM7QUFDckIsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLGdDQUFnQztBQUM1QztBQUNBLGdJQUFnSSxzQkFBc0I7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixZQUFZLGdDQUFnQztBQUM1QztBQUNBLHlKQUF5SixzQkFBc0I7QUFDL0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96MTB0cmlhZ2UtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2J1aWxkL2NhbGN1bGF0ZVV0aWxzLmpzPzIwMWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNhbGNHcmlkQ29sV2lkdGggPSBjYWxjR3JpZENvbFdpZHRoO1xuZXhwb3J0cy5jYWxjR3JpZEl0ZW1Qb3NpdGlvbiA9IGNhbGNHcmlkSXRlbVBvc2l0aW9uO1xuZXhwb3J0cy5jYWxjR3JpZEl0ZW1XSFB4ID0gY2FsY0dyaWRJdGVtV0hQeDtcbmV4cG9ydHMuY2FsY1dIID0gY2FsY1dIO1xuZXhwb3J0cy5jYWxjWFkgPSBjYWxjWFk7XG5leHBvcnRzLmNsYW1wID0gY2xhbXA7XG4vKjo6IGltcG9ydCB0eXBlIHsgUG9zaXRpb24gfSBmcm9tIFwiLi91dGlsc1wiOyovXG4vKjo6IGV4cG9ydCB0eXBlIFBvc2l0aW9uUGFyYW1zID0ge1xuICBtYXJnaW46IFtudW1iZXIsIG51bWJlcl0sXG4gIGNvbnRhaW5lclBhZGRpbmc6IFtudW1iZXIsIG51bWJlcl0sXG4gIGNvbnRhaW5lcldpZHRoOiBudW1iZXIsXG4gIGNvbHM6IG51bWJlcixcbiAgcm93SGVpZ2h0OiBudW1iZXIsXG4gIG1heFJvd3M6IG51bWJlclxufTsqL1xuLy8gSGVscGVyIGZvciBnZW5lcmF0aW5nIGNvbHVtbiB3aWR0aFxuZnVuY3Rpb24gY2FsY0dyaWRDb2xXaWR0aChwb3NpdGlvblBhcmFtcyAvKjogUG9zaXRpb25QYXJhbXMqLykgLyo6IG51bWJlciove1xuICBjb25zdCB7XG4gICAgbWFyZ2luLFxuICAgIGNvbnRhaW5lclBhZGRpbmcsXG4gICAgY29udGFpbmVyV2lkdGgsXG4gICAgY29sc1xuICB9ID0gcG9zaXRpb25QYXJhbXM7XG4gIHJldHVybiAoY29udGFpbmVyV2lkdGggLSBtYXJnaW5bMF0gKiAoY29scyAtIDEpIC0gY29udGFpbmVyUGFkZGluZ1swXSAqIDIpIC8gY29scztcbn1cblxuLy8gVGhpcyBjYW4gZWl0aGVyIGJlIGNhbGxlZDpcbi8vIGNhbGNHcmlkSXRlbVdIUHgodywgY29sV2lkdGgsIG1hcmdpblswXSlcbi8vIG9yXG4vLyBjYWxjR3JpZEl0ZW1XSFB4KGgsIHJvd0hlaWdodCwgbWFyZ2luWzFdKVxuZnVuY3Rpb24gY2FsY0dyaWRJdGVtV0hQeChncmlkVW5pdHMgLyo6IG51bWJlciovLCBjb2xPclJvd1NpemUgLyo6IG51bWJlciovLCBtYXJnaW5QeCAvKjogbnVtYmVyKi8pIC8qOiBudW1iZXIqL3tcbiAgLy8gMCAqIEluZmluaXR5ID09PSBOYU4sIHdoaWNoIGNhdXNlcyBwcm9ibGVtcyB3aXRoIHJlc2l6ZSBjb250cmFpbnRzXG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGdyaWRVbml0cykpIHJldHVybiBncmlkVW5pdHM7XG4gIHJldHVybiBNYXRoLnJvdW5kKGNvbE9yUm93U2l6ZSAqIGdyaWRVbml0cyArIE1hdGgubWF4KDAsIGdyaWRVbml0cyAtIDEpICogbWFyZ2luUHgpO1xufVxuXG4vKipcbiAqIFJldHVybiBwb3NpdGlvbiBvbiB0aGUgcGFnZSBnaXZlbiBhbiB4LCB5LCB3LCBoLlxuICogbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0IGFyZSBhbGwgaW4gcGl4ZWxzLlxuICogQHBhcmFtICB7UG9zaXRpb25QYXJhbXN9IHBvc2l0aW9uUGFyYW1zICBQYXJhbWV0ZXJzIG9mIGdyaWQgbmVlZGVkIGZvciBjb29yZGluYXRlcyBjYWxjdWxhdGlvbnMuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICB4ICAgICAgICAgICAgICAgICAgICAgIFggY29vcmRpbmF0ZSBpbiBncmlkIHVuaXRzLlxuICogQHBhcmFtICB7TnVtYmVyfSAgeSAgICAgICAgICAgICAgICAgICAgICBZIGNvb3JkaW5hdGUgaW4gZ3JpZCB1bml0cy5cbiAqIEBwYXJhbSAge051bWJlcn0gIHcgICAgICAgICAgICAgICAgICAgICAgVyBjb29yZGluYXRlIGluIGdyaWQgdW5pdHMuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICBoICAgICAgICAgICAgICAgICAgICAgIEggY29vcmRpbmF0ZSBpbiBncmlkIHVuaXRzLlxuICogQHJldHVybiB7UG9zaXRpb259ICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyBjb29yZHMuXG4gKi9cbmZ1bmN0aW9uIGNhbGNHcmlkSXRlbVBvc2l0aW9uKHBvc2l0aW9uUGFyYW1zIC8qOiBQb3NpdGlvblBhcmFtcyovLCB4IC8qOiBudW1iZXIqLywgeSAvKjogbnVtYmVyKi8sIHcgLyo6IG51bWJlciovLCBoIC8qOiBudW1iZXIqLywgc3RhdGUgLyo6ID9PYmplY3QqLykgLyo6IFBvc2l0aW9uKi97XG4gIGNvbnN0IHtcbiAgICBtYXJnaW4sXG4gICAgY29udGFpbmVyUGFkZGluZyxcbiAgICByb3dIZWlnaHRcbiAgfSA9IHBvc2l0aW9uUGFyYW1zO1xuICBjb25zdCBjb2xXaWR0aCA9IGNhbGNHcmlkQ29sV2lkdGgocG9zaXRpb25QYXJhbXMpO1xuICBjb25zdCBvdXQgPSB7fTtcblxuICAvLyBJZiByZXNpemluZywgdXNlIHRoZSBleGFjdCB3aWR0aCBhbmQgaGVpZ2h0IGFzIHJldHVybmVkIGZyb20gcmVzaXppbmcgY2FsbGJhY2tzLlxuICBpZiAoc3RhdGUgJiYgc3RhdGUucmVzaXppbmcpIHtcbiAgICBvdXQud2lkdGggPSBNYXRoLnJvdW5kKHN0YXRlLnJlc2l6aW5nLndpZHRoKTtcbiAgICBvdXQuaGVpZ2h0ID0gTWF0aC5yb3VuZChzdGF0ZS5yZXNpemluZy5oZWlnaHQpO1xuICB9XG4gIC8vIE90aGVyd2lzZSwgY2FsY3VsYXRlIGZyb20gZ3JpZCB1bml0cy5cbiAgZWxzZSB7XG4gICAgb3V0LndpZHRoID0gY2FsY0dyaWRJdGVtV0hQeCh3LCBjb2xXaWR0aCwgbWFyZ2luWzBdKTtcbiAgICBvdXQuaGVpZ2h0ID0gY2FsY0dyaWRJdGVtV0hQeChoLCByb3dIZWlnaHQsIG1hcmdpblsxXSk7XG4gIH1cblxuICAvLyBJZiBkcmFnZ2luZywgdXNlIHRoZSBleGFjdCB3aWR0aCBhbmQgaGVpZ2h0IGFzIHJldHVybmVkIGZyb20gZHJhZ2dpbmcgY2FsbGJhY2tzLlxuICBpZiAoc3RhdGUgJiYgc3RhdGUuZHJhZ2dpbmcpIHtcbiAgICBvdXQudG9wID0gTWF0aC5yb3VuZChzdGF0ZS5kcmFnZ2luZy50b3ApO1xuICAgIG91dC5sZWZ0ID0gTWF0aC5yb3VuZChzdGF0ZS5kcmFnZ2luZy5sZWZ0KTtcbiAgfSBlbHNlIGlmIChzdGF0ZSAmJiBzdGF0ZS5yZXNpemluZyAmJiB0eXBlb2Ygc3RhdGUucmVzaXppbmcudG9wID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBzdGF0ZS5yZXNpemluZy5sZWZ0ID09PSBcIm51bWJlclwiKSB7XG4gICAgb3V0LnRvcCA9IE1hdGgucm91bmQoc3RhdGUucmVzaXppbmcudG9wKTtcbiAgICBvdXQubGVmdCA9IE1hdGgucm91bmQoc3RhdGUucmVzaXppbmcubGVmdCk7XG4gIH1cbiAgLy8gT3RoZXJ3aXNlLCBjYWxjdWxhdGUgZnJvbSBncmlkIHVuaXRzLlxuICBlbHNlIHtcbiAgICBvdXQudG9wID0gTWF0aC5yb3VuZCgocm93SGVpZ2h0ICsgbWFyZ2luWzFdKSAqIHkgKyBjb250YWluZXJQYWRkaW5nWzFdKTtcbiAgICBvdXQubGVmdCA9IE1hdGgucm91bmQoKGNvbFdpZHRoICsgbWFyZ2luWzBdKSAqIHggKyBjb250YWluZXJQYWRkaW5nWzBdKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGZyb20gcGl4ZWxzIHRvIGdyaWQgdW5pdHMuXG4gKiBAcGFyYW0gIHtQb3NpdGlvblBhcmFtc30gcG9zaXRpb25QYXJhbXMgIFBhcmFtZXRlcnMgb2YgZ3JpZCBuZWVkZWQgZm9yIGNvb3JkaW5hdGVzIGNhbGN1bGF0aW9ucy5cbiAqIEBwYXJhbSAge051bWJlcn0gdG9wICAgICAgICAgICAgICAgICAgICAgVG9wIHBvc2l0aW9uIChyZWxhdGl2ZSB0byBwYXJlbnQpIGluIHBpeGVscy5cbiAqIEBwYXJhbSAge051bWJlcn0gbGVmdCAgICAgICAgICAgICAgICAgICAgTGVmdCBwb3NpdGlvbiAocmVsYXRpdmUgdG8gcGFyZW50KSBpbiBwaXhlbHMuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHcgICAgICAgICAgICAgICAgICAgICAgIFcgY29vcmRpbmF0ZSBpbiBncmlkIHVuaXRzLlxuICogQHBhcmFtICB7TnVtYmVyfSBoICAgICAgICAgICAgICAgICAgICAgICBIIGNvb3JkaW5hdGUgaW4gZ3JpZCB1bml0cy5cbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgeCBhbmQgeSBpbiBncmlkIHVuaXRzLlxuICovXG5mdW5jdGlvbiBjYWxjWFkocG9zaXRpb25QYXJhbXMgLyo6IFBvc2l0aW9uUGFyYW1zKi8sIHRvcCAvKjogbnVtYmVyKi8sIGxlZnQgLyo6IG51bWJlciovLCB3IC8qOiBudW1iZXIqLywgaCAvKjogbnVtYmVyKi8pIC8qOiB7IHg6IG51bWJlciwgeTogbnVtYmVyIH0qL3tcbiAgY29uc3Qge1xuICAgIG1hcmdpbixcbiAgICBjb250YWluZXJQYWRkaW5nLFxuICAgIGNvbHMsXG4gICAgcm93SGVpZ2h0LFxuICAgIG1heFJvd3NcbiAgfSA9IHBvc2l0aW9uUGFyYW1zO1xuICBjb25zdCBjb2xXaWR0aCA9IGNhbGNHcmlkQ29sV2lkdGgocG9zaXRpb25QYXJhbXMpO1xuXG4gIC8vIGxlZnQgPSBjb250YWluZXJQYWRkaW5nWCArIHggKiAoY29sV2lkdGggKyBtYXJnaW5YKVxuICAvLyB4ICogKGNvbFdpZHRoICsgbWFyZ2luWCkgPSBsZWZ0IC0gY29udGFpbmVyUGFkZGluZ1hcbiAgLy8geCA9IChsZWZ0IC0gY29udGFpbmVyUGFkZGluZ1gpIC8gKGNvbFdpZHRoICsgbWFyZ2luWClcbiAgbGV0IHggPSBNYXRoLnJvdW5kKChsZWZ0IC0gY29udGFpbmVyUGFkZGluZ1swXSkgLyAoY29sV2lkdGggKyBtYXJnaW5bMF0pKTtcbiAgbGV0IHkgPSBNYXRoLnJvdW5kKCh0b3AgLSBjb250YWluZXJQYWRkaW5nWzFdKSAvIChyb3dIZWlnaHQgKyBtYXJnaW5bMV0pKTtcblxuICAvLyBDYXBwaW5nXG4gIHggPSBjbGFtcCh4LCAwLCBjb2xzIC0gdyk7XG4gIHkgPSBjbGFtcCh5LCAwLCBtYXhSb3dzIC0gaCk7XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbi8qKlxuICogR2l2ZW4gYSBoZWlnaHQgYW5kIHdpZHRoIGluIHBpeGVsIHZhbHVlcywgY2FsY3VsYXRlIGdyaWQgdW5pdHMuXG4gKiBAcGFyYW0gIHtQb3NpdGlvblBhcmFtc30gcG9zaXRpb25QYXJhbXMgIFBhcmFtZXRlcnMgb2YgZ3JpZCBuZWVkZWQgZm9yIGNvb3JkaW5hdGVzIGNhbGNsdWF0aW9ucy5cbiAqIEBwYXJhbSAge051bWJlcn0gaGVpZ2h0ICAgICAgICAgICAgICAgICAgSGVpZ2h0IGluIHBpeGVscy5cbiAqIEBwYXJhbSAge051bWJlcn0gd2lkdGggICAgICAgICAgICAgICAgICAgV2lkdGggaW4gcGl4ZWxzLlxuICogQHBhcmFtICB7TnVtYmVyfSB4ICAgICAgICAgICAgICAgICAgICAgICBYIGNvb3JkaW5hdGUgaW4gZ3JpZCB1bml0cy5cbiAqIEBwYXJhbSAge051bWJlcn0geSAgICAgICAgICAgICAgICAgICAgICAgWSBjb29yZGluYXRlIGluIGdyaWQgdW5pdHMuXG4gKiBAcGFyYW0ge1N0cmluZ30gaGFuZGxlIFJlc2l6ZSBIYW5kbGUuXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICAgIHcsIGggYXMgZ3JpZCB1bml0cy5cbiAqL1xuZnVuY3Rpb24gY2FsY1dIKHBvc2l0aW9uUGFyYW1zIC8qOiBQb3NpdGlvblBhcmFtcyovLCB3aWR0aCAvKjogbnVtYmVyKi8sIGhlaWdodCAvKjogbnVtYmVyKi8sIHggLyo6IG51bWJlciovLCB5IC8qOiBudW1iZXIqLywgaGFuZGxlIC8qOiBzdHJpbmcqLykgLyo6IHsgdzogbnVtYmVyLCBoOiBudW1iZXIgfSove1xuICBjb25zdCB7XG4gICAgbWFyZ2luLFxuICAgIG1heFJvd3MsXG4gICAgY29scyxcbiAgICByb3dIZWlnaHRcbiAgfSA9IHBvc2l0aW9uUGFyYW1zO1xuICBjb25zdCBjb2xXaWR0aCA9IGNhbGNHcmlkQ29sV2lkdGgocG9zaXRpb25QYXJhbXMpO1xuXG4gIC8vIHdpZHRoID0gY29sV2lkdGggKiB3IC0gKG1hcmdpbiAqICh3IC0gMSkpXG4gIC8vIC4uLlxuICAvLyB3ID0gKHdpZHRoICsgbWFyZ2luKSAvIChjb2xXaWR0aCArIG1hcmdpbilcbiAgbGV0IHcgPSBNYXRoLnJvdW5kKCh3aWR0aCArIG1hcmdpblswXSkgLyAoY29sV2lkdGggKyBtYXJnaW5bMF0pKTtcbiAgbGV0IGggPSBNYXRoLnJvdW5kKChoZWlnaHQgKyBtYXJnaW5bMV0pIC8gKHJvd0hlaWdodCArIG1hcmdpblsxXSkpO1xuXG4gIC8vIENhcHBpbmdcbiAgbGV0IF93ID0gY2xhbXAodywgMCwgY29scyAtIHgpO1xuICBsZXQgX2ggPSBjbGFtcChoLCAwLCBtYXhSb3dzIC0geSk7XG4gIGlmIChbXCJzd1wiLCBcIndcIiwgXCJud1wiXS5pbmRleE9mKGhhbmRsZSkgIT09IC0xKSB7XG4gICAgX3cgPSBjbGFtcCh3LCAwLCBjb2xzKTtcbiAgfVxuICBpZiAoW1wibndcIiwgXCJuXCIsIFwibmVcIl0uaW5kZXhPZihoYW5kbGUpICE9PSAtMSkge1xuICAgIF9oID0gY2xhbXAoaCwgMCwgbWF4Um93cyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3OiBfdyxcbiAgICBoOiBfaFxuICB9O1xufVxuXG4vLyBTaW1pbGFyIHRvIF8uY2xhbXBcbmZ1bmN0aW9uIGNsYW1wKG51bSAvKjogbnVtYmVyKi8sIGxvd2VyQm91bmQgLyo6IG51bWJlciovLCB1cHBlckJvdW5kIC8qOiBudW1iZXIqLykgLyo6IG51bWJlciove1xuICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obnVtLCB1cHBlckJvdW5kKSwgbG93ZXJCb3VuZCk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/calculateUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/components/WidthProvider.js":
/*!**************************************************************************!*\
  !*** ./node_modules/react-grid-layout/build/components/WidthProvider.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = WidthProvideRGL;\nvar React = _interopRequireWildcard(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\nvar _resizeObserverPolyfill = _interopRequireDefault(__webpack_require__(/*! resize-observer-polyfill */ \"(ssr)/./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) \"default\" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/*:: import type { ReactRef } from \"../ReactGridLayoutPropTypes\";*/\n/*:: type WPDefaultProps = {|\n  measureBeforeMount: boolean\n|};*/\n/*:: type WPProps = {|\n  className?: string,\n  style?: Object,\n  ...WPDefaultProps\n|};*/\n// eslint-disable-next-line no-unused-vars\n/*:: type WPState = {|\n  width: number\n|};*/\n/*:: type ComposedProps<Config> = {|\n  ...Config,\n  measureBeforeMount?: boolean,\n  className?: string,\n  style?: Object,\n  width?: number\n|};*/\nconst layoutClassName = \"react-grid-layout\";\n\n/*\n * A simple HOC that provides facility for listening to container resizes.\n *\n * The Flow type is pretty janky here. I can't just spread `WPProps` into this returned object - I wish I could - but it triggers\n * a flow bug of some sort that causes it to stop typechecking.\n */\nfunction WidthProvideRGL /*:: <Config>*/(ComposedComponent /*: React.AbstractComponent<Config>*/) /*: React.AbstractComponent<ComposedProps<Config>>*/{\n  var _WidthProvider;\n  return _WidthProvider = class WidthProvider extends React.Component\n  /*:: <\n      ComposedProps<Config>,\n      WPState\n    >*/\n  {\n    constructor() {\n      super(...arguments);\n      _defineProperty(this, \"state\", {\n        width: 1280\n      });\n      _defineProperty(this, \"elementRef\", /*#__PURE__*/React.createRef());\n      _defineProperty(this, \"mounted\", false);\n      _defineProperty(this, \"resizeObserver\", void 0);\n    }\n    componentDidMount() {\n      this.mounted = true;\n      this.resizeObserver = new _resizeObserverPolyfill.default(entries => {\n        const node = this.elementRef.current;\n        if (node instanceof HTMLElement) {\n          const width = entries[0].contentRect.width;\n          this.setState({\n            width\n          });\n        }\n      });\n      const node = this.elementRef.current;\n      if (node instanceof HTMLElement) {\n        this.resizeObserver.observe(node);\n      }\n    }\n    componentWillUnmount() {\n      this.mounted = false;\n      const node = this.elementRef.current;\n      if (node instanceof HTMLElement) {\n        this.resizeObserver.unobserve(node);\n      }\n      this.resizeObserver.disconnect();\n    }\n    render() {\n      const {\n        measureBeforeMount,\n        ...rest\n      } = this.props;\n      if (measureBeforeMount && !this.mounted) {\n        return /*#__PURE__*/React.createElement(\"div\", {\n          className: (0, _clsx.default)(this.props.className, layoutClassName),\n          style: this.props.style\n          // $FlowIgnore ref types\n          ,\n          ref: this.elementRef\n        });\n      }\n      return /*#__PURE__*/React.createElement(ComposedComponent, _extends({\n        innerRef: this.elementRef\n      }, rest, this.state));\n    }\n  }, _defineProperty(_WidthProvider, \"defaultProps\", {\n    measureBeforeMount: false\n  }), _defineProperty(_WidthProvider, \"propTypes\", {\n    // If true, will not render children until mounted. Useful for getting the exact width before\n    // rendering, to prevent any unsightly resizing.\n    measureBeforeMount: _propTypes.default.bool\n  }), _WidthProvider;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvY29tcG9uZW50cy9XaWR0aFByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2Ysb0NBQW9DLG1CQUFPLENBQUMsd0dBQU87QUFDbkQsd0NBQXdDLG1CQUFPLENBQUMsNERBQVk7QUFDNUQscURBQXFELG1CQUFPLENBQUMseUdBQTBCO0FBQ3ZGLG1DQUFtQyxtQkFBTyxDQUFDLG9EQUFNO0FBQ2pELHFDQUFxQyxpQ0FBaUM7QUFDdEUseUNBQXlDLDRFQUE0RSxvREFBb0QsdUNBQXVDLGdCQUFnQiwrQkFBK0IsNEVBQTRFLHFCQUFxQiwrQkFBK0IsZUFBZSx3Q0FBd0MsMkpBQTJKLFdBQVc7QUFDNWxCLHNCQUFzQix3RUFBd0UsZ0JBQWdCLHNCQUFzQixPQUFPLHNCQUFzQixvQkFBb0IsZ0RBQWdELFdBQVc7QUFDaFAsb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsMENBQTBDLCtCQUErQixvQkFBb0IsbUNBQW1DLG9DQUFvQyx1RUFBdUU7QUFDelEsbUJBQW1CLFdBQVcsbUNBQW1DO0FBQ2pFLDRCQUE0QjtBQUM1QjtBQUNBLEdBQUc7QUFDSCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsR0FBRztBQUNILG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vejEwdHJpYWdlLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLWxheW91dC9idWlsZC9jb21wb25lbnRzL1dpZHRoUHJvdmlkZXIuanM/NGM5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFdpZHRoUHJvdmlkZVJHTDtcbnZhciBSZWFjdCA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX3Byb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xudmFyIF9yZXNpemVPYnNlcnZlclBvbHlmaWxsID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVzaXplLW9ic2VydmVyLXBvbHlmaWxsXCIpKTtcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfTsgfVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgdCkgeyBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBXZWFrTWFwKSB2YXIgciA9IG5ldyBXZWFrTWFwKCksIG4gPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkID0gZnVuY3Rpb24gKGUsIHQpIHsgaWYgKCF0ICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgdmFyIG8sIGksIGYgPSB7IF9fcHJvdG9fXzogbnVsbCwgZGVmYXVsdDogZSB9OyBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IHR5cGVvZiBlICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIGY7IGlmIChvID0gdCA/IG4gOiByKSB7IGlmIChvLmhhcyhlKSkgcmV0dXJuIG8uZ2V0KGUpOyBvLnNldChlLCBmKTsgfSBmb3IgKGNvbnN0IHQgaW4gZSkgXCJkZWZhdWx0XCIgIT09IHQgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCB0KSAmJiAoKGkgPSAobyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB0KSkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IG8oZiwgdCwgaSkgOiBmW3RdID0gZVt0XSk7IHJldHVybiBmOyB9KShlLCB0KTsgfVxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IHJldHVybiBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uIChuKSB7IGZvciAodmFyIGUgPSAxOyBlIDwgYXJndW1lbnRzLmxlbmd0aDsgZSsrKSB7IHZhciB0ID0gYXJndW1lbnRzW2VdOyBmb3IgKHZhciByIGluIHQpICh7fSkuaGFzT3duUHJvcGVydHkuY2FsbCh0LCByKSAmJiAobltyXSA9IHRbcl0pOyB9IHJldHVybiBuOyB9LCBfZXh0ZW5kcy5hcHBseShudWxsLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkgeyByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7IHZhbHVlOiB0LCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVtyXSA9IHQsIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdCB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG4vKjo6IGltcG9ydCB0eXBlIHsgUmVhY3RSZWYgfSBmcm9tIFwiLi4vUmVhY3RHcmlkTGF5b3V0UHJvcFR5cGVzXCI7Ki9cbi8qOjogdHlwZSBXUERlZmF1bHRQcm9wcyA9IHt8XG4gIG1lYXN1cmVCZWZvcmVNb3VudDogYm9vbGVhblxufH07Ki9cbi8qOjogdHlwZSBXUFByb3BzID0ge3xcbiAgY2xhc3NOYW1lPzogc3RyaW5nLFxuICBzdHlsZT86IE9iamVjdCxcbiAgLi4uV1BEZWZhdWx0UHJvcHNcbnx9OyovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbi8qOjogdHlwZSBXUFN0YXRlID0ge3xcbiAgd2lkdGg6IG51bWJlclxufH07Ki9cbi8qOjogdHlwZSBDb21wb3NlZFByb3BzPENvbmZpZz4gPSB7fFxuICAuLi5Db25maWcsXG4gIG1lYXN1cmVCZWZvcmVNb3VudD86IGJvb2xlYW4sXG4gIGNsYXNzTmFtZT86IHN0cmluZyxcbiAgc3R5bGU/OiBPYmplY3QsXG4gIHdpZHRoPzogbnVtYmVyXG58fTsqL1xuY29uc3QgbGF5b3V0Q2xhc3NOYW1lID0gXCJyZWFjdC1ncmlkLWxheW91dFwiO1xuXG4vKlxuICogQSBzaW1wbGUgSE9DIHRoYXQgcHJvdmlkZXMgZmFjaWxpdHkgZm9yIGxpc3RlbmluZyB0byBjb250YWluZXIgcmVzaXplcy5cbiAqXG4gKiBUaGUgRmxvdyB0eXBlIGlzIHByZXR0eSBqYW5reSBoZXJlLiBJIGNhbid0IGp1c3Qgc3ByZWFkIGBXUFByb3BzYCBpbnRvIHRoaXMgcmV0dXJuZWQgb2JqZWN0IC0gSSB3aXNoIEkgY291bGQgLSBidXQgaXQgdHJpZ2dlcnNcbiAqIGEgZmxvdyBidWcgb2Ygc29tZSBzb3J0IHRoYXQgY2F1c2VzIGl0IHRvIHN0b3AgdHlwZWNoZWNraW5nLlxuICovXG5mdW5jdGlvbiBXaWR0aFByb3ZpZGVSR0wgLyo6OiA8Q29uZmlnPiovKENvbXBvc2VkQ29tcG9uZW50IC8qOiBSZWFjdC5BYnN0cmFjdENvbXBvbmVudDxDb25maWc+Ki8pIC8qOiBSZWFjdC5BYnN0cmFjdENvbXBvbmVudDxDb21wb3NlZFByb3BzPENvbmZpZz4+Ki97XG4gIHZhciBfV2lkdGhQcm92aWRlcjtcbiAgcmV0dXJuIF9XaWR0aFByb3ZpZGVyID0gY2xhc3MgV2lkdGhQcm92aWRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudFxuICAvKjo6IDxcbiAgICAgIENvbXBvc2VkUHJvcHM8Q29uZmlnPixcbiAgICAgIFdQU3RhdGVcbiAgICA+Ki9cbiAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRlXCIsIHtcbiAgICAgICAgd2lkdGg6IDEyODBcbiAgICAgIH0pO1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZWxlbWVudFJlZlwiLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlUmVmKCkpO1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibW91bnRlZFwiLCBmYWxzZSk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXNpemVPYnNlcnZlclwiLCB2b2lkIDApO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IF9yZXNpemVPYnNlcnZlclBvbHlmaWxsLmRlZmF1bHQoZW50cmllcyA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmVsZW1lbnRSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gZW50cmllc1swXS5jb250ZW50UmVjdC53aWR0aDtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIHdpZHRoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZWxlbWVudFJlZi5jdXJyZW50O1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgdGhpcy5tb3VudGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5lbGVtZW50UmVmLmN1cnJlbnQ7XG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKG5vZGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWVhc3VyZUJlZm9yZU1vdW50LFxuICAgICAgICAuLi5yZXN0XG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGlmIChtZWFzdXJlQmVmb3JlTW91bnQgJiYgIXRoaXMubW91bnRlZCkge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICAgIGNsYXNzTmFtZTogKDAsIF9jbHN4LmRlZmF1bHQpKHRoaXMucHJvcHMuY2xhc3NOYW1lLCBsYXlvdXRDbGFzc05hbWUpLFxuICAgICAgICAgIHN0eWxlOiB0aGlzLnByb3BzLnN0eWxlXG4gICAgICAgICAgLy8gJEZsb3dJZ25vcmUgcmVmIHR5cGVzXG4gICAgICAgICAgLFxuICAgICAgICAgIHJlZjogdGhpcy5lbGVtZW50UmVmXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvc2VkQ29tcG9uZW50LCBfZXh0ZW5kcyh7XG4gICAgICAgIGlubmVyUmVmOiB0aGlzLmVsZW1lbnRSZWZcbiAgICAgIH0sIHJlc3QsIHRoaXMuc3RhdGUpKTtcbiAgICB9XG4gIH0sIF9kZWZpbmVQcm9wZXJ0eShfV2lkdGhQcm92aWRlciwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICAgIG1lYXN1cmVCZWZvcmVNb3VudDogZmFsc2VcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfV2lkdGhQcm92aWRlciwgXCJwcm9wVHlwZXNcIiwge1xuICAgIC8vIElmIHRydWUsIHdpbGwgbm90IHJlbmRlciBjaGlsZHJlbiB1bnRpbCBtb3VudGVkLiBVc2VmdWwgZm9yIGdldHRpbmcgdGhlIGV4YWN0IHdpZHRoIGJlZm9yZVxuICAgIC8vIHJlbmRlcmluZywgdG8gcHJldmVudCBhbnkgdW5zaWdodGx5IHJlc2l6aW5nLlxuICAgIG1lYXN1cmVCZWZvcmVNb3VudDogX3Byb3BUeXBlcy5kZWZhdWx0LmJvb2xcbiAgfSksIF9XaWR0aFByb3ZpZGVyO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/components/WidthProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/fastRGLPropsEqual.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-grid-layout/build/fastRGLPropsEqual.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("// this file was prevaled\nmodule.exports = function fastRGLPropsEqual(a, b, isEqualImpl) {\n  if (a === b) return true;\n  return a.className === b.className && isEqualImpl(a.style, b.style) && a.width === b.width && a.autoSize === b.autoSize && a.cols === b.cols && a.draggableCancel === b.draggableCancel && a.draggableHandle === b.draggableHandle && isEqualImpl(a.verticalCompact, b.verticalCompact) && isEqualImpl(a.compactType, b.compactType) && isEqualImpl(a.layout, b.layout) && isEqualImpl(a.margin, b.margin) && isEqualImpl(a.containerPadding, b.containerPadding) && a.rowHeight === b.rowHeight && a.maxRows === b.maxRows && a.isBounded === b.isBounded && a.isDraggable === b.isDraggable && a.isResizable === b.isResizable && a.allowOverlap === b.allowOverlap && a.preventCollision === b.preventCollision && a.useCSSTransforms === b.useCSSTransforms && a.transformScale === b.transformScale && a.isDroppable === b.isDroppable && isEqualImpl(a.resizeHandles, b.resizeHandles) && isEqualImpl(a.resizeHandle, b.resizeHandle) && a.onLayoutChange === b.onLayoutChange && a.onDragStart === b.onDragStart && a.onDrag === b.onDrag && a.onDragStop === b.onDragStop && a.onResizeStart === b.onResizeStart && a.onResize === b.onResize && a.onResizeStop === b.onResizeStop && a.onDrop === b.onDrop && isEqualImpl(a.droppingItem, b.droppingItem) && isEqualImpl(a.innerRef, b.innerRef);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvZmFzdFJHTFByb3BzRXF1YWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3oxMHRyaWFnZS1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvZmFzdFJHTFByb3BzRXF1YWwuanM/MmQ2NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0aGlzIGZpbGUgd2FzIHByZXZhbGVkXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZhc3RSR0xQcm9wc0VxdWFsKGEsIGIsIGlzRXF1YWxJbXBsKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGEuY2xhc3NOYW1lID09PSBiLmNsYXNzTmFtZSAmJiBpc0VxdWFsSW1wbChhLnN0eWxlLCBiLnN0eWxlKSAmJiBhLndpZHRoID09PSBiLndpZHRoICYmIGEuYXV0b1NpemUgPT09IGIuYXV0b1NpemUgJiYgYS5jb2xzID09PSBiLmNvbHMgJiYgYS5kcmFnZ2FibGVDYW5jZWwgPT09IGIuZHJhZ2dhYmxlQ2FuY2VsICYmIGEuZHJhZ2dhYmxlSGFuZGxlID09PSBiLmRyYWdnYWJsZUhhbmRsZSAmJiBpc0VxdWFsSW1wbChhLnZlcnRpY2FsQ29tcGFjdCwgYi52ZXJ0aWNhbENvbXBhY3QpICYmIGlzRXF1YWxJbXBsKGEuY29tcGFjdFR5cGUsIGIuY29tcGFjdFR5cGUpICYmIGlzRXF1YWxJbXBsKGEubGF5b3V0LCBiLmxheW91dCkgJiYgaXNFcXVhbEltcGwoYS5tYXJnaW4sIGIubWFyZ2luKSAmJiBpc0VxdWFsSW1wbChhLmNvbnRhaW5lclBhZGRpbmcsIGIuY29udGFpbmVyUGFkZGluZykgJiYgYS5yb3dIZWlnaHQgPT09IGIucm93SGVpZ2h0ICYmIGEubWF4Um93cyA9PT0gYi5tYXhSb3dzICYmIGEuaXNCb3VuZGVkID09PSBiLmlzQm91bmRlZCAmJiBhLmlzRHJhZ2dhYmxlID09PSBiLmlzRHJhZ2dhYmxlICYmIGEuaXNSZXNpemFibGUgPT09IGIuaXNSZXNpemFibGUgJiYgYS5hbGxvd092ZXJsYXAgPT09IGIuYWxsb3dPdmVybGFwICYmIGEucHJldmVudENvbGxpc2lvbiA9PT0gYi5wcmV2ZW50Q29sbGlzaW9uICYmIGEudXNlQ1NTVHJhbnNmb3JtcyA9PT0gYi51c2VDU1NUcmFuc2Zvcm1zICYmIGEudHJhbnNmb3JtU2NhbGUgPT09IGIudHJhbnNmb3JtU2NhbGUgJiYgYS5pc0Ryb3BwYWJsZSA9PT0gYi5pc0Ryb3BwYWJsZSAmJiBpc0VxdWFsSW1wbChhLnJlc2l6ZUhhbmRsZXMsIGIucmVzaXplSGFuZGxlcykgJiYgaXNFcXVhbEltcGwoYS5yZXNpemVIYW5kbGUsIGIucmVzaXplSGFuZGxlKSAmJiBhLm9uTGF5b3V0Q2hhbmdlID09PSBiLm9uTGF5b3V0Q2hhbmdlICYmIGEub25EcmFnU3RhcnQgPT09IGIub25EcmFnU3RhcnQgJiYgYS5vbkRyYWcgPT09IGIub25EcmFnICYmIGEub25EcmFnU3RvcCA9PT0gYi5vbkRyYWdTdG9wICYmIGEub25SZXNpemVTdGFydCA9PT0gYi5vblJlc2l6ZVN0YXJ0ICYmIGEub25SZXNpemUgPT09IGIub25SZXNpemUgJiYgYS5vblJlc2l6ZVN0b3AgPT09IGIub25SZXNpemVTdG9wICYmIGEub25Ecm9wID09PSBiLm9uRHJvcCAmJiBpc0VxdWFsSW1wbChhLmRyb3BwaW5nSXRlbSwgYi5kcm9wcGluZ0l0ZW0pICYmIGlzRXF1YWxJbXBsKGEuaW5uZXJSZWYsIGIuaW5uZXJSZWYpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/fastRGLPropsEqual.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/responsiveUtils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react-grid-layout/build/responsiveUtils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.findOrGenerateResponsiveLayout = findOrGenerateResponsiveLayout;\nexports.getBreakpointFromWidth = getBreakpointFromWidth;\nexports.getColsFromBreakpoint = getColsFromBreakpoint;\nexports.sortBreakpoints = sortBreakpoints;\nvar _utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/react-grid-layout/build/utils.js\");\n/*:: import type { CompactType, Layout } from \"./utils\";*/\n/*:: export type Breakpoint = string;*/\n/*:: export type DefaultBreakpoints = \"lg\" | \"md\" | \"sm\" | \"xs\" | \"xxs\";*/\n/*:: export type ResponsiveLayout<T: Breakpoint> = {\n  +[breakpoint: T]: Layout\n};*/\n// + indicates read-only\n/*:: export type Breakpoints<T: Breakpoint> = {\n  +[breakpoint: T]: number\n};*/\n/*:: export type OnLayoutChangeCallback = (\n  Layout,\n  { [key: Breakpoint]: Layout }\n) => void;*/\n/**\n * Given a width, find the highest breakpoint that matches is valid for it (width > breakpoint).\n *\n * @param  {Object} breakpoints Breakpoints object (e.g. {lg: 1200, md: 960, ...})\n * @param  {Number} width Screen width.\n * @return {String}       Highest breakpoint that is less than width.\n */\nfunction getBreakpointFromWidth(breakpoints /*: Breakpoints<Breakpoint>*/, width /*: number*/) /*: Breakpoint*/{\n  const sorted = sortBreakpoints(breakpoints);\n  let matching = sorted[0];\n  for (let i = 1, len = sorted.length; i < len; i++) {\n    const breakpointName = sorted[i];\n    if (width > breakpoints[breakpointName]) matching = breakpointName;\n  }\n  return matching;\n}\n\n/**\n * Given a breakpoint, get the # of cols set for it.\n * @param  {String} breakpoint Breakpoint name.\n * @param  {Object} cols       Map of breakpoints to cols.\n * @return {Number}            Number of cols.\n */\nfunction getColsFromBreakpoint(breakpoint /*: Breakpoint*/, cols /*: Breakpoints<Breakpoint>*/) /*: number*/{\n  if (!cols[breakpoint]) {\n    throw new Error(\"ResponsiveReactGridLayout: `cols` entry for breakpoint \" + breakpoint + \" is missing!\");\n  }\n  return cols[breakpoint];\n}\n\n/**\n * Given existing layouts and a new breakpoint, find or generate a new layout.\n *\n * This finds the layout above the new one and generates from it, if it exists.\n *\n * @param  {Object} layouts     Existing layouts.\n * @param  {Array} breakpoints All breakpoints.\n * @param  {String} breakpoint New breakpoint.\n * @param  {String} breakpoint Last breakpoint (for fallback).\n * @param  {Number} cols       Column count at new breakpoint.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}             New layout.\n */\nfunction findOrGenerateResponsiveLayout(layouts /*: ResponsiveLayout<Breakpoint>*/, breakpoints /*: Breakpoints<Breakpoint>*/, breakpoint /*: Breakpoint*/, lastBreakpoint /*: Breakpoint*/, cols /*: number*/, compactType /*: CompactType*/) /*: Layout*/{\n  // If it already exists, just return it.\n  if (layouts[breakpoint]) return (0, _utils.cloneLayout)(layouts[breakpoint]);\n  // Find or generate the next layout\n  let layout = layouts[lastBreakpoint];\n  const breakpointsSorted = sortBreakpoints(breakpoints);\n  const breakpointsAbove = breakpointsSorted.slice(breakpointsSorted.indexOf(breakpoint));\n  for (let i = 0, len = breakpointsAbove.length; i < len; i++) {\n    const b = breakpointsAbove[i];\n    if (layouts[b]) {\n      layout = layouts[b];\n      break;\n    }\n  }\n  layout = (0, _utils.cloneLayout)(layout || []); // clone layout so we don't modify existing items\n  return (0, _utils.compact)((0, _utils.correctBounds)(layout, {\n    cols: cols\n  }), compactType, cols);\n}\n\n/**\n * Given breakpoints, return an array of breakpoints sorted by width. This is usually\n * e.g. ['xxs', 'xs', 'sm', ...]\n *\n * @param  {Object} breakpoints Key/value pair of breakpoint names to widths.\n * @return {Array}              Sorted breakpoints.\n */\nfunction sortBreakpoints(breakpoints /*: Breakpoints<Breakpoint>*/) /*: Array<Breakpoint>*/{\n  const keys /*: Array<string>*/ = Object.keys(breakpoints);\n  return keys.sort(function (a, b) {\n    return breakpoints[a] - breakpoints[b];\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvcmVzcG9uc2l2ZVV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLHNDQUFzQztBQUN0Qyw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLHVCQUF1QjtBQUN2QixhQUFhLG1CQUFPLENBQUMsc0VBQVM7QUFDOUIsbUJBQW1CLHNCQUFzQixlQUFlO0FBQ3hELHFDQUFxQztBQUNyQyx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLElBQUk7QUFDSixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRLHNDQUFzQyx1QkFBdUI7QUFDakYsWUFBWSxRQUFRO0FBQ3BCLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLE9BQU87QUFDbkIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96MTB0cmlhZ2UtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2J1aWxkL3Jlc3BvbnNpdmVVdGlscy5qcz82OGRlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5maW5kT3JHZW5lcmF0ZVJlc3BvbnNpdmVMYXlvdXQgPSBmaW5kT3JHZW5lcmF0ZVJlc3BvbnNpdmVMYXlvdXQ7XG5leHBvcnRzLmdldEJyZWFrcG9pbnRGcm9tV2lkdGggPSBnZXRCcmVha3BvaW50RnJvbVdpZHRoO1xuZXhwb3J0cy5nZXRDb2xzRnJvbUJyZWFrcG9pbnQgPSBnZXRDb2xzRnJvbUJyZWFrcG9pbnQ7XG5leHBvcnRzLnNvcnRCcmVha3BvaW50cyA9IHNvcnRCcmVha3BvaW50cztcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qOjogaW1wb3J0IHR5cGUgeyBDb21wYWN0VHlwZSwgTGF5b3V0IH0gZnJvbSBcIi4vdXRpbHNcIjsqL1xuLyo6OiBleHBvcnQgdHlwZSBCcmVha3BvaW50ID0gc3RyaW5nOyovXG4vKjo6IGV4cG9ydCB0eXBlIERlZmF1bHRCcmVha3BvaW50cyA9IFwibGdcIiB8IFwibWRcIiB8IFwic21cIiB8IFwieHNcIiB8IFwieHhzXCI7Ki9cbi8qOjogZXhwb3J0IHR5cGUgUmVzcG9uc2l2ZUxheW91dDxUOiBCcmVha3BvaW50PiA9IHtcbiAgK1ticmVha3BvaW50OiBUXTogTGF5b3V0XG59OyovXG4vLyArIGluZGljYXRlcyByZWFkLW9ubHlcbi8qOjogZXhwb3J0IHR5cGUgQnJlYWtwb2ludHM8VDogQnJlYWtwb2ludD4gPSB7XG4gICtbYnJlYWtwb2ludDogVF06IG51bWJlclxufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBPbkxheW91dENoYW5nZUNhbGxiYWNrID0gKFxuICBMYXlvdXQsXG4gIHsgW2tleTogQnJlYWtwb2ludF06IExheW91dCB9XG4pID0+IHZvaWQ7Ki9cbi8qKlxuICogR2l2ZW4gYSB3aWR0aCwgZmluZCB0aGUgaGlnaGVzdCBicmVha3BvaW50IHRoYXQgbWF0Y2hlcyBpcyB2YWxpZCBmb3IgaXQgKHdpZHRoID4gYnJlYWtwb2ludCkuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBicmVha3BvaW50cyBCcmVha3BvaW50cyBvYmplY3QgKGUuZy4ge2xnOiAxMjAwLCBtZDogOTYwLCAuLi59KVxuICogQHBhcmFtICB7TnVtYmVyfSB3aWR0aCBTY3JlZW4gd2lkdGguXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgIEhpZ2hlc3QgYnJlYWtwb2ludCB0aGF0IGlzIGxlc3MgdGhhbiB3aWR0aC5cbiAqL1xuZnVuY3Rpb24gZ2V0QnJlYWtwb2ludEZyb21XaWR0aChicmVha3BvaW50cyAvKjogQnJlYWtwb2ludHM8QnJlYWtwb2ludD4qLywgd2lkdGggLyo6IG51bWJlciovKSAvKjogQnJlYWtwb2ludCove1xuICBjb25zdCBzb3J0ZWQgPSBzb3J0QnJlYWtwb2ludHMoYnJlYWtwb2ludHMpO1xuICBsZXQgbWF0Y2hpbmcgPSBzb3J0ZWRbMF07XG4gIGZvciAobGV0IGkgPSAxLCBsZW4gPSBzb3J0ZWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBicmVha3BvaW50TmFtZSA9IHNvcnRlZFtpXTtcbiAgICBpZiAod2lkdGggPiBicmVha3BvaW50c1ticmVha3BvaW50TmFtZV0pIG1hdGNoaW5nID0gYnJlYWtwb2ludE5hbWU7XG4gIH1cbiAgcmV0dXJuIG1hdGNoaW5nO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgYnJlYWtwb2ludCwgZ2V0IHRoZSAjIG9mIGNvbHMgc2V0IGZvciBpdC5cbiAqIEBwYXJhbSAge1N0cmluZ30gYnJlYWtwb2ludCBCcmVha3BvaW50IG5hbWUuXG4gKiBAcGFyYW0gIHtPYmplY3R9IGNvbHMgICAgICAgTWFwIG9mIGJyZWFrcG9pbnRzIHRvIGNvbHMuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgTnVtYmVyIG9mIGNvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldENvbHNGcm9tQnJlYWtwb2ludChicmVha3BvaW50IC8qOiBCcmVha3BvaW50Ki8sIGNvbHMgLyo6IEJyZWFrcG9pbnRzPEJyZWFrcG9pbnQ+Ki8pIC8qOiBudW1iZXIqL3tcbiAgaWYgKCFjb2xzW2JyZWFrcG9pbnRdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVzcG9uc2l2ZVJlYWN0R3JpZExheW91dDogYGNvbHNgIGVudHJ5IGZvciBicmVha3BvaW50IFwiICsgYnJlYWtwb2ludCArIFwiIGlzIG1pc3NpbmchXCIpO1xuICB9XG4gIHJldHVybiBjb2xzW2JyZWFrcG9pbnRdO1xufVxuXG4vKipcbiAqIEdpdmVuIGV4aXN0aW5nIGxheW91dHMgYW5kIGEgbmV3IGJyZWFrcG9pbnQsIGZpbmQgb3IgZ2VuZXJhdGUgYSBuZXcgbGF5b3V0LlxuICpcbiAqIFRoaXMgZmluZHMgdGhlIGxheW91dCBhYm92ZSB0aGUgbmV3IG9uZSBhbmQgZ2VuZXJhdGVzIGZyb20gaXQsIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGxheW91dHMgICAgIEV4aXN0aW5nIGxheW91dHMuXG4gKiBAcGFyYW0gIHtBcnJheX0gYnJlYWtwb2ludHMgQWxsIGJyZWFrcG9pbnRzLlxuICogQHBhcmFtICB7U3RyaW5nfSBicmVha3BvaW50IE5ldyBicmVha3BvaW50LlxuICogQHBhcmFtICB7U3RyaW5nfSBicmVha3BvaW50IExhc3QgYnJlYWtwb2ludCAoZm9yIGZhbGxiYWNrKS5cbiAqIEBwYXJhbSAge051bWJlcn0gY29scyAgICAgICBDb2x1bW4gY291bnQgYXQgbmV3IGJyZWFrcG9pbnQuXG4gKiBAcGFyYW0gIHtCb29sZWFufSB2ZXJ0aWNhbENvbXBhY3QgV2hldGhlciBvciBub3QgdG8gY29tcGFjdCB0aGUgbGF5b3V0XG4gKiAgIHZlcnRpY2FsbHkuXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgTmV3IGxheW91dC5cbiAqL1xuZnVuY3Rpb24gZmluZE9yR2VuZXJhdGVSZXNwb25zaXZlTGF5b3V0KGxheW91dHMgLyo6IFJlc3BvbnNpdmVMYXlvdXQ8QnJlYWtwb2ludD4qLywgYnJlYWtwb2ludHMgLyo6IEJyZWFrcG9pbnRzPEJyZWFrcG9pbnQ+Ki8sIGJyZWFrcG9pbnQgLyo6IEJyZWFrcG9pbnQqLywgbGFzdEJyZWFrcG9pbnQgLyo6IEJyZWFrcG9pbnQqLywgY29scyAvKjogbnVtYmVyKi8sIGNvbXBhY3RUeXBlIC8qOiBDb21wYWN0VHlwZSovKSAvKjogTGF5b3V0Ki97XG4gIC8vIElmIGl0IGFscmVhZHkgZXhpc3RzLCBqdXN0IHJldHVybiBpdC5cbiAgaWYgKGxheW91dHNbYnJlYWtwb2ludF0pIHJldHVybiAoMCwgX3V0aWxzLmNsb25lTGF5b3V0KShsYXlvdXRzW2JyZWFrcG9pbnRdKTtcbiAgLy8gRmluZCBvciBnZW5lcmF0ZSB0aGUgbmV4dCBsYXlvdXRcbiAgbGV0IGxheW91dCA9IGxheW91dHNbbGFzdEJyZWFrcG9pbnRdO1xuICBjb25zdCBicmVha3BvaW50c1NvcnRlZCA9IHNvcnRCcmVha3BvaW50cyhicmVha3BvaW50cyk7XG4gIGNvbnN0IGJyZWFrcG9pbnRzQWJvdmUgPSBicmVha3BvaW50c1NvcnRlZC5zbGljZShicmVha3BvaW50c1NvcnRlZC5pbmRleE9mKGJyZWFrcG9pbnQpKTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGJyZWFrcG9pbnRzQWJvdmUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBiID0gYnJlYWtwb2ludHNBYm92ZVtpXTtcbiAgICBpZiAobGF5b3V0c1tiXSkge1xuICAgICAgbGF5b3V0ID0gbGF5b3V0c1tiXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBsYXlvdXQgPSAoMCwgX3V0aWxzLmNsb25lTGF5b3V0KShsYXlvdXQgfHwgW10pOyAvLyBjbG9uZSBsYXlvdXQgc28gd2UgZG9uJ3QgbW9kaWZ5IGV4aXN0aW5nIGl0ZW1zXG4gIHJldHVybiAoMCwgX3V0aWxzLmNvbXBhY3QpKCgwLCBfdXRpbHMuY29ycmVjdEJvdW5kcykobGF5b3V0LCB7XG4gICAgY29sczogY29sc1xuICB9KSwgY29tcGFjdFR5cGUsIGNvbHMpO1xufVxuXG4vKipcbiAqIEdpdmVuIGJyZWFrcG9pbnRzLCByZXR1cm4gYW4gYXJyYXkgb2YgYnJlYWtwb2ludHMgc29ydGVkIGJ5IHdpZHRoLiBUaGlzIGlzIHVzdWFsbHlcbiAqIGUuZy4gWyd4eHMnLCAneHMnLCAnc20nLCAuLi5dXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBicmVha3BvaW50cyBLZXkvdmFsdWUgcGFpciBvZiBicmVha3BvaW50IG5hbWVzIHRvIHdpZHRocy5cbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgU29ydGVkIGJyZWFrcG9pbnRzLlxuICovXG5mdW5jdGlvbiBzb3J0QnJlYWtwb2ludHMoYnJlYWtwb2ludHMgLyo6IEJyZWFrcG9pbnRzPEJyZWFrcG9pbnQ+Ki8pIC8qOiBBcnJheTxCcmVha3BvaW50Piove1xuICBjb25zdCBrZXlzIC8qOiBBcnJheTxzdHJpbmc+Ki8gPSBPYmplY3Qua2V5cyhicmVha3BvaW50cyk7XG4gIHJldHVybiBrZXlzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYnJlYWtwb2ludHNbYV0gLSBicmVha3BvaW50c1tiXTtcbiAgfSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/responsiveUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/build/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-grid-layout/build/utils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.bottom = bottom;\nexports.childrenEqual = childrenEqual;\nexports.cloneLayout = cloneLayout;\nexports.cloneLayoutItem = cloneLayoutItem;\nexports.collides = collides;\nexports.compact = compact;\nexports.compactItem = compactItem;\nexports.compactType = compactType;\nexports.correctBounds = correctBounds;\nexports.fastPositionEqual = fastPositionEqual;\nexports.fastRGLPropsEqual = void 0;\nexports.getAllCollisions = getAllCollisions;\nexports.getFirstCollision = getFirstCollision;\nexports.getLayoutItem = getLayoutItem;\nexports.getStatics = getStatics;\nexports.modifyLayout = modifyLayout;\nexports.moveElement = moveElement;\nexports.moveElementAwayFromCollision = moveElementAwayFromCollision;\nexports.noop = void 0;\nexports.perc = perc;\nexports.resizeItemInDirection = resizeItemInDirection;\nexports.setTopLeft = setTopLeft;\nexports.setTransform = setTransform;\nexports.sortLayoutItems = sortLayoutItems;\nexports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;\nexports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\nexports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;\nexports.validateLayout = validateLayout;\nexports.withLayoutItem = withLayoutItem;\nvar _fastEquals = __webpack_require__(/*! fast-equals */ \"(ssr)/./node_modules/fast-equals/dist/fast-equals.esm.js\");\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\n/*:: import type {\n  ChildrenArray as ReactChildrenArray,\n  Element as ReactElement\n} from \"react\";*/\n/*:: export type ResizeHandleAxis =\n  | \"s\"\n  | \"w\"\n  | \"e\"\n  | \"n\"\n  | \"sw\"\n  | \"nw\"\n  | \"se\"\n  | \"ne\";*/\n/*:: export type LayoutItem = {\n  w: number,\n  h: number,\n  x: number,\n  y: number,\n  i: string,\n  minW?: number,\n  minH?: number,\n  maxW?: number,\n  maxH?: number,\n  moved?: boolean,\n  static?: boolean,\n  isDraggable?: ?boolean,\n  isResizable?: ?boolean,\n  resizeHandles?: Array<ResizeHandleAxis>,\n  isBounded?: ?boolean\n};*/\n/*:: export type Layout = $ReadOnlyArray<LayoutItem>;*/\n/*:: export type Position = {\n  left: number,\n  top: number,\n  width: number,\n  height: number\n};*/\n/*:: export type ReactDraggableCallbackData = {\n  node: HTMLElement,\n  x?: number,\n  y?: number,\n  deltaX: number,\n  deltaY: number,\n  lastX?: number,\n  lastY?: number\n};*/\n/*:: export type PartialPosition = { left: number, top: number };*/\n/*:: export type DroppingPosition = { left: number, top: number, e: Event };*/\n/*:: export type Size = { width: number, height: number };*/\n/*:: export type GridDragEvent = {\n  e: Event,\n  node: HTMLElement,\n  newPosition: PartialPosition\n};*/\n/*:: export type GridResizeEvent = {\n  e: Event,\n  node: HTMLElement,\n  size: Size,\n  handle: string\n};*/\n/*:: export type DragOverEvent = MouseEvent & {\n  nativeEvent: {\n    layerX: number,\n    layerY: number,\n    ...Event\n  }\n};*/\n/*:: export type Pick<FromType, Properties: { [string]: 0 }> = $Exact<\n  $ObjMapi<Properties, <K, V>(k: K, v: V) => $ElementType<FromType, K>>\n>;*/\n// Helpful port from TS\n/*:: type REl = ReactElement<any>;*/\n/*:: export type ReactChildren = ReactChildrenArray<REl>;*/\n/*:: export type EventCallback = (\n  Layout,\n  oldItem: ?LayoutItem,\n  newItem: ?LayoutItem,\n  placeholder: ?LayoutItem,\n  Event,\n  ?HTMLElement\n) => void;*/\n// All callbacks are of the signature (layout, oldItem, newItem, placeholder, e).\n/*:: export type CompactType = ?(\"horizontal\" | \"vertical\");*/\nconst isProduction = \"development\" === \"production\";\nconst DEBUG = false;\n\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\nfunction bottom(layout /*: Layout*/) /*: number*/{\n  let max = 0,\n    bottomY;\n  for (let i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n  return max;\n}\nfunction cloneLayout(layout /*: Layout*/) /*: Layout*/{\n  const newLayout = Array(layout.length);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n  return newLayout;\n}\n\n// Modify a layoutItem inside a layout. Returns a new Layout,\n// does not mutate. Carries over all other LayoutItems unmodified.\nfunction modifyLayout(layout /*: Layout*/, layoutItem /*: LayoutItem*/) /*: Layout*/{\n  const newLayout = Array(layout.length);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (layoutItem.i === layout[i].i) {\n      newLayout[i] = layoutItem;\n    } else {\n      newLayout[i] = layout[i];\n    }\n  }\n  return newLayout;\n}\n\n// Function to be called to modify a layout item.\n// Does defensive clones to ensure the layout is not modified.\nfunction withLayoutItem(layout /*: Layout*/, itemKey /*: string*/, cb /*: LayoutItem => LayoutItem*/) /*: [Layout, ?LayoutItem]*/{\n  let item = getLayoutItem(layout, itemKey);\n  if (!item) return [layout, null];\n  item = cb(cloneLayoutItem(item)); // defensive clone then modify\n  // FIXME could do this faster if we already knew the index\n  layout = modifyLayout(layout, item);\n  return [layout, item];\n}\n\n// Fast path to cloning, since this is monomorphic\nfunction cloneLayoutItem(layoutItem /*: LayoutItem*/) /*: LayoutItem*/{\n  return {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    i: layoutItem.i,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    // These can be null/undefined\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable,\n    resizeHandles: layoutItem.resizeHandles,\n    isBounded: layoutItem.isBounded\n  };\n}\n\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\nfunction childrenEqual(a /*: ReactChildren*/, b /*: ReactChildren*/) /*: boolean*/{\n  return (0, _fastEquals.deepEqual)(_react.default.Children.map(a, c => c?.key), _react.default.Children.map(b, c => c?.key)) && (0, _fastEquals.deepEqual)(_react.default.Children.map(a, c => c?.props[\"data-grid\"]), _react.default.Children.map(b, c => c?.props[\"data-grid\"]));\n}\n\n/**\n * See `fastRGLPropsEqual.js`.\n * We want this to run as fast as possible - it is called often - and to be\n * resilient to new props that we add. So rather than call lodash.isEqual,\n * which isn't suited to comparing props very well, we use this specialized\n * function in conjunction with preval to generate the fastest possible comparison\n * function, tuned for exactly our props.\n */\n/*:: type FastRGLPropsEqual = (Object, Object, Function) => boolean;*/\nconst fastRGLPropsEqual /*: FastRGLPropsEqual*/ = exports.fastRGLPropsEqual = __webpack_require__(/*! ./fastRGLPropsEqual */ \"(ssr)/./node_modules/react-grid-layout/build/fastRGLPropsEqual.js\");\n\n// Like the above, but a lot simpler.\nfunction fastPositionEqual(a /*: Position*/, b /*: Position*/) /*: boolean*/{\n  return a.left === b.left && a.top === b.top && a.width === b.width && a.height === b.height;\n}\n\n/**\n * Given two layoutitems, check if they collide.\n */\nfunction collides(l1 /*: LayoutItem*/, l2 /*: LayoutItem*/) /*: boolean*/{\n  if (l1.i === l2.i) return false; // same element\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n  return true; // boxes overlap\n}\n\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * Does not modify layout items (clones). Creates a new layout array.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @param  {Boolean} allowOverlap When `true`, allows overlapping grid items.\n * @return {Array}       Compacted Layout.\n */\nfunction compact(layout /*: Layout*/, compactType /*: CompactType*/, cols /*: number*/, allowOverlap /*: ?boolean*/) /*: Layout*/{\n  // Statics go in the compareWith array right away so items flow around them.\n  const compareWith = getStatics(layout);\n  // We go through the items by row and column.\n  const sorted = sortLayoutItems(layout, compactType);\n  // Holding for new items.\n  const out = Array(layout.length);\n  for (let i = 0, len = sorted.length; i < len; i++) {\n    let l = cloneLayoutItem(sorted[i]);\n\n    // Don't move static elements\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted, allowOverlap);\n\n      // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n      compareWith.push(l);\n    }\n\n    // Add to output array to make sure they still come out in the right order.\n    out[layout.indexOf(sorted[i])] = l;\n\n    // Clear moved flag, if it exists.\n    l.moved = false;\n  }\n  return out;\n}\nconst heightWidth = {\n  x: \"w\",\n  y: \"h\"\n};\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\nfunction resolveCompactionCollision(layout /*: Layout*/, item /*: LayoutItem*/, moveToCoord /*: number*/, axis /*: \"x\" | \"y\"*/) {\n  const sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  const itemIndex = layout.map(layoutItem => {\n    return layoutItem.i;\n  }).indexOf(item.i);\n\n  // Go through each item we collide with.\n  for (let i = itemIndex + 1; i < layout.length; i++) {\n    const otherItem = layout[i];\n    // Ignore static items\n    if (otherItem.static) continue;\n\n    // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n    if (otherItem.y > item.y + item.h) break;\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n    }\n  }\n  item[axis] = moveToCoord;\n}\n\n/**\n * Compact an item in the layout.\n *\n * Modifies item.\n *\n */\nfunction compactItem(compareWith /*: Layout*/, l /*: LayoutItem*/, compactType /*: CompactType*/, cols /*: number*/, fullLayout /*: Layout*/, allowOverlap /*: ?boolean*/) /*: LayoutItem*/{\n  const compactV = compactType === \"vertical\";\n  const compactH = compactType === \"horizontal\";\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y);\n    // Move the element up as far as it can go without colliding.\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    // Move the element left as far as it can go without colliding.\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  }\n\n  // Move it down, and keep moving it down if it's colliding.\n  let collides;\n  // Checking the compactType null value to avoid breaking the layout when overlapping is allowed.\n  while ((collides = getFirstCollision(compareWith, l)) && !(compactType === null && allowOverlap)) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \"x\");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \"y\");\n    }\n    // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n      // ALso move element as left as we can\n      while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n        l.x--;\n      }\n    }\n  }\n\n  // Ensure that there are no negative positions\n  l.y = Math.max(l.y, 0);\n  l.x = Math.max(l.x, 0);\n  return l;\n}\n\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * Modifies layout items.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\nfunction correctBounds(layout /*: Layout*/, bounds /*: { cols: number }*/) /*: Layout*/{\n  const collidesWith = getStatics(layout);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const l = layout[i];\n    // Overflows right\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w;\n    // Overflows left\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n  return layout;\n}\n\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\nfunction getLayoutItem(layout /*: Layout*/, id /*: string*/) /*: ?LayoutItem*/{\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\nfunction getFirstCollision(layout /*: Layout*/, layoutItem /*: LayoutItem*/) /*: ?LayoutItem*/{\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\nfunction getAllCollisions(layout /*: Layout*/, layoutItem /*: LayoutItem*/) /*: Array<LayoutItem>*/{\n  return layout.filter(l => collides(l, layoutItem));\n}\n\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\nfunction getStatics(layout /*: Layout*/) /*: Array<LayoutItem>*/{\n  return layout.filter(l => l.static);\n}\n\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * Modifies layout items.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\nfunction moveElement(layout /*: Layout*/, l /*: LayoutItem*/, x /*: ?number*/, y /*: ?number*/, isUserAction /*: ?boolean*/, preventCollision /*: ?boolean*/, compactType /*: CompactType*/, cols /*: number*/, allowOverlap /*: ?boolean*/) /*: Layout*/{\n  // If this is static and not explicitly enabled as draggable,\n  // no move is possible, so we can short-circuit this immediately.\n  if (l.static && l.isDraggable !== true) return layout;\n\n  // Short-circuit if nothing to do.\n  if (l.y === y && l.x === x) return layout;\n  log(`Moving element ${l.i} to [${String(x)},${String(y)}] from [${l.x},${l.y}]`);\n  const oldX = l.x;\n  const oldY = l.y;\n\n  // This is quite a bit faster than extending the object\n  if (typeof x === \"number\") l.x = x;\n  if (typeof y === \"number\") l.y = y;\n  l.moved = true;\n\n  // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n  let sorted = sortLayoutItems(layout, compactType);\n  const movingUp = compactType === \"vertical\" && typeof y === \"number\" ? oldY >= y : compactType === \"horizontal\" && typeof x === \"number\" ? oldX >= x : false;\n  // $FlowIgnore acceptable modification of read-only array as it was recently cloned\n  if (movingUp) sorted = sorted.reverse();\n  const collisions = getAllCollisions(sorted, l);\n  const hasCollisions = collisions.length > 0;\n\n  // We may have collisions. We can short-circuit if we've turned off collisions or\n  // allowed overlap.\n  if (hasCollisions && allowOverlap) {\n    // Easy, we don't need to resolve collisions. But we *did* change the layout,\n    // so clone it on the way out.\n    return cloneLayout(layout);\n  } else if (hasCollisions && preventCollision) {\n    // If we are preventing collision but not allowing overlap, we need to\n    // revert the position of this element so it goes to where it came from, rather\n    // than the user's desired location.\n    log(`Collision prevented on ${l.i}, reverting.`);\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout; // did not change so don't clone\n  }\n\n  // Move each item that collides away from this element.\n  for (let i = 0, len = collisions.length; i < len; i++) {\n    const collision = collisions[i];\n    log(`Resolving collision between ${l.i} at [${l.x},${l.y}] and ${collision.i} at [${collision.x},${collision.y}]`);\n\n    // Short circuit so we can't infinite loop\n    if (collision.moved) continue;\n\n    // Don't move static items - we have to move *this* element away\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\n    }\n  }\n  return layout;\n}\n\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\nfunction moveElementAwayFromCollision(layout /*: Layout*/, collidesWith /*: LayoutItem*/, itemToMove /*: LayoutItem*/, isUserAction /*: ?boolean*/, compactType /*: CompactType*/, cols /*: number*/) /*: Layout*/{\n  const compactH = compactType === \"horizontal\";\n  // Compact vertically if not set to horizontal\n  const compactV = compactType === \"vertical\";\n  const preventCollision = collidesWith.static; // we're already colliding (not for static items)\n\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false;\n\n    // Make a mock item so we don't modify the item here, only modify in moveElement.\n    const fakeItem /*: LayoutItem*/ = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    };\n    const firstCollision = getFirstCollision(layout, fakeItem);\n    const collisionNorth = firstCollision && firstCollision.y + firstCollision.h > collidesWith.y;\n    const collisionWest = firstCollision && collidesWith.x + collidesWith.w > firstCollision.x;\n\n    // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n    if (!firstCollision) {\n      log(`Doing reverse collision on ${itemToMove.i} up to [${fakeItem.x},${fakeItem.y}].`);\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\n    } else if (collisionNorth && compactV) {\n      return moveElement(layout, itemToMove, undefined, collidesWith.y + 1, isUserAction, preventCollision, compactType, cols);\n    } else if (collisionNorth && compactType == null) {\n      collidesWith.y = itemToMove.y;\n      itemToMove.y = itemToMove.y + itemToMove.h;\n      return layout;\n    } else if (collisionWest && compactH) {\n      return moveElement(layout, collidesWith, itemToMove.x, undefined, isUserAction, preventCollision, compactType, cols);\n    }\n  }\n  const newX = compactH ? itemToMove.x + 1 : undefined;\n  const newY = compactV ? itemToMove.y + 1 : undefined;\n  if (newX == null && newY == null) {\n    return layout;\n  }\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\n}\n\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\nfunction perc(num /*: number*/) /*: string*/{\n  return num * 100 + \"%\";\n}\n\n/**\n * Helper functions to constrain dimensions of a GridItem\n */\nconst constrainWidth = (left /*: number*/, currentWidth /*: number*/, newWidth /*: number*/, containerWidth /*: number*/) => {\n  return left + newWidth > containerWidth ? currentWidth : newWidth;\n};\nconst constrainHeight = (top /*: number*/, currentHeight /*: number*/, newHeight /*: number*/) => {\n  return top < 0 ? currentHeight : newHeight;\n};\nconst constrainLeft = (left /*: number*/) => Math.max(0, left);\nconst constrainTop = (top /*: number*/) => Math.max(0, top);\nconst resizeNorth = (currentSize, _ref, _containerWidth) => {\n  let {\n    left,\n    height,\n    width\n  } = _ref;\n  const top = currentSize.top - (height - currentSize.height);\n  return {\n    left,\n    width,\n    height: constrainHeight(top, currentSize.height, height),\n    top: constrainTop(top)\n  };\n};\nconst resizeEast = (currentSize, _ref2, containerWidth) => {\n  let {\n    top,\n    left,\n    height,\n    width\n  } = _ref2;\n  return {\n    top,\n    height,\n    width: constrainWidth(currentSize.left, currentSize.width, width, containerWidth),\n    left: constrainLeft(left)\n  };\n};\nconst resizeWest = (currentSize, _ref3, containerWidth) => {\n  let {\n    top,\n    height,\n    width\n  } = _ref3;\n  const left = currentSize.left - (width - currentSize.width);\n  return {\n    height,\n    width: left < 0 ? currentSize.width : constrainWidth(currentSize.left, currentSize.width, width, containerWidth),\n    top: constrainTop(top),\n    left: constrainLeft(left)\n  };\n};\nconst resizeSouth = (currentSize, _ref4, containerWidth) => {\n  let {\n    top,\n    left,\n    height,\n    width\n  } = _ref4;\n  return {\n    width,\n    left,\n    height: constrainHeight(top, currentSize.height, height),\n    top: constrainTop(top)\n  };\n};\nconst resizeNorthEast = function () {\n  return resizeNorth(arguments.length <= 0 ? undefined : arguments[0], resizeEast(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst resizeNorthWest = function () {\n  return resizeNorth(arguments.length <= 0 ? undefined : arguments[0], resizeWest(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst resizeSouthEast = function () {\n  return resizeSouth(arguments.length <= 0 ? undefined : arguments[0], resizeEast(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst resizeSouthWest = function () {\n  return resizeSouth(arguments.length <= 0 ? undefined : arguments[0], resizeWest(...arguments), arguments.length <= 2 ? undefined : arguments[2]);\n};\nconst ordinalResizeHandlerMap = {\n  n: resizeNorth,\n  ne: resizeNorthEast,\n  e: resizeEast,\n  se: resizeSouthEast,\n  s: resizeSouth,\n  sw: resizeSouthWest,\n  w: resizeWest,\n  nw: resizeNorthWest\n};\n\n/**\n * Helper for clamping width and position when resizing an item.\n */\nfunction resizeItemInDirection(direction /*: ResizeHandleAxis*/, currentSize /*: Position*/, newSize /*: Position*/, containerWidth /*: number*/) /*: Position*/{\n  const ordinalHandler = ordinalResizeHandlerMap[direction];\n  // Shouldn't be possible given types; that said, don't fail hard\n  if (!ordinalHandler) return newSize;\n  return ordinalHandler(currentSize, {\n    ...currentSize,\n    ...newSize\n  }, containerWidth);\n}\nfunction setTransform(_ref5 /*:: */) /*: Object*/{\n  let {\n    top,\n    left,\n    width,\n    height\n  } /*: Position*/ = _ref5 /*: Position*/;\n  // Replace unitless items with px\n  const translate = `translate(${left}px,${top}px)`;\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: \"absolute\"\n  };\n}\nfunction setTopLeft(_ref6 /*:: */) /*: Object*/{\n  let {\n    top,\n    left,\n    width,\n    height\n  } /*: Position*/ = _ref6 /*: Position*/;\n  return {\n    top: `${top}px`,\n    left: `${left}px`,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: \"absolute\"\n  };\n}\n\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\nfunction sortLayoutItems(layout /*: Layout*/, compactType /*: CompactType*/) /*: Layout*/{\n  if (compactType === \"horizontal\") return sortLayoutItemsByColRow(layout);\n  if (compactType === \"vertical\") return sortLayoutItemsByRowCol(layout);else return layout;\n}\n\n/**\n * Sort layout items by row ascending and column ascending.\n *\n * Does not modify Layout.\n */\nfunction sortLayoutItemsByRowCol(layout /*: Layout*/) /*: Layout*/{\n  // Slice to clone array as sort modifies\n  return layout.slice(0).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n    return -1;\n  });\n}\n\n/**\n * Sort layout items by column ascending then row ascending.\n *\n * Does not modify Layout.\n */\nfunction sortLayoutItemsByColRow(layout /*: Layout*/) /*: Layout*/{\n  return layout.slice(0).sort(function (a, b) {\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\n      return 1;\n    }\n    return -1;\n  });\n}\n\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * Does not modify initialLayout.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\nfunction synchronizeLayoutWithChildren(initialLayout /*: Layout*/, children /*: ReactChildren*/, cols /*: number*/, compactType /*: CompactType*/, allowOverlap /*: ?boolean*/) /*: Layout*/{\n  initialLayout = initialLayout || [];\n\n  // Generate one layout item per child.\n  const layout /*: LayoutItem[]*/ = [];\n  _react.default.Children.forEach(children, (child /*: ReactElement<any>*/) => {\n    // Child may not exist\n    if (child?.key == null) return;\n    const exists = getLayoutItem(initialLayout, String(child.key));\n    const g = child.props[\"data-grid\"];\n    // Don't overwrite the layout item if it's already in the initial layout.\n    // If it has a `data-grid` property, prefer that over what's in the layout.\n    if (exists && g == null) {\n      layout.push(cloneLayoutItem(exists));\n    } else {\n      // Hey, this item has a data-grid property, use it.\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], \"ReactGridLayout.children\");\n        }\n        // FIXME clone not really necessary here\n        layout.push(cloneLayoutItem({\n          ...g,\n          i: child.key\n        }));\n      } else {\n        // Nothing provided: ensure this is added to the bottom\n        // FIXME clone not really necessary here\n        layout.push(cloneLayoutItem({\n          w: 1,\n          h: 1,\n          x: 0,\n          y: bottom(layout),\n          i: String(child.key)\n        }));\n      }\n    }\n  });\n\n  // Correct the layout.\n  const correctedLayout = correctBounds(layout, {\n    cols: cols\n  });\n  return allowOverlap ? correctedLayout : compact(correctedLayout, compactType, cols);\n}\n\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\nfunction validateLayout(layout /*: Layout*/) /*: void*/{\n  let contextName /*: string*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Layout\";\n  const subProps = [\"x\", \"y\", \"w\", \"h\"];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const item = layout[i];\n    for (let j = 0; j < subProps.length; j++) {\n      const key = subProps[j];\n      const value = item[key];\n      if (typeof value !== \"number\" || Number.isNaN(value)) {\n        throw new Error(`ReactGridLayout: ${contextName}[${i}].${key} must be a number! Received: ${value} (${typeof value})`);\n      }\n    }\n    if (typeof item.i !== \"undefined\" && typeof item.i !== \"string\") {\n      throw new Error(`ReactGridLayout: ${contextName}[${i}].i must be a string! Received: ${item.i} (${typeof item.i})`);\n    }\n  }\n}\n\n// Legacy support for verticalCompact: false\nfunction compactType(props /*: ?{ verticalCompact: boolean, compactType: CompactType }*/) /*: CompactType*/{\n  const {\n    verticalCompact,\n    compactType\n  } = props || {};\n  return verticalCompact === false ? null : compactType;\n}\nfunction log() {\n  if (!DEBUG) return;\n  // eslint-disable-next-line no-console\n  console.log(...arguments);\n}\nconst noop = () => {};\nexports.noop = noop;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvYnVpbGQvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsY0FBYztBQUNkLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsdUJBQXVCO0FBQ3ZCLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2YsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixvQ0FBb0M7QUFDcEMsWUFBWTtBQUNaLFlBQVk7QUFDWiw2QkFBNkI7QUFDN0Isa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQix1QkFBdUI7QUFDdkIsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQixxQ0FBcUM7QUFDckMsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixrQkFBa0IsbUJBQU8sQ0FBQyw2RUFBYTtBQUN2QyxvQ0FBb0MsbUJBQU8sQ0FBQyx3R0FBTztBQUNuRCxxQ0FBcUMsaUNBQWlDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLEVBQUUsYUFBYTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixxQ0FBcUMsNEJBQTRCO0FBQ2pFLHNDQUFzQyxzQ0FBc0M7QUFDNUUsMEJBQTBCLGdDQUFnQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRiw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBLEVBQUU7QUFDRjtBQUNBLGtDQUFrQztBQUNsQyx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSw0REFBNEQ7QUFDNUQscUJBQXFCLGFBQW9CO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsa0RBQWtELCtJQUEwRDs7QUFFNUc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6Qyx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSw4QkFBOEIsbUJBQW1CO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQSx5REFBeUQsY0FBYztBQUN2RTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEIsWUFBWSxZQUFZO0FBQ3hCLFlBQVksWUFBWTtBQUN4QixZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUssTUFBTSxVQUFVLEdBQUcsVUFBVSxVQUFVLElBQUksR0FBRyxJQUFJO0FBQy9FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0EsdUNBQXVDLEtBQUssTUFBTSxJQUFJLEdBQUcsSUFBSSxRQUFRLGFBQWEsTUFBTSxZQUFZLEdBQUcsWUFBWTs7QUFFbkg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFlBQVk7QUFDeEIsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBLHdDQUF3QyxjQUFjLFNBQVMsV0FBVyxHQUFHLFdBQVc7QUFDeEY7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxpQ0FBaUMsS0FBSyxLQUFLLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxZQUFZLElBQUk7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCLGNBQWMsTUFBTTtBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFNBQVM7QUFDckIsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWSxHQUFHLEVBQUUsSUFBSSxLQUFLLDhCQUE4QixPQUFPLEdBQUcsYUFBYTtBQUMzSDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWSxHQUFHLEVBQUUsa0NBQWtDLFFBQVEsR0FBRyxjQUFjO0FBQ3RIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxvREFBb0Q7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vejEwdHJpYWdlLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1ncmlkLWxheW91dC9idWlsZC91dGlscy5qcz82NTJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5ib3R0b20gPSBib3R0b207XG5leHBvcnRzLmNoaWxkcmVuRXF1YWwgPSBjaGlsZHJlbkVxdWFsO1xuZXhwb3J0cy5jbG9uZUxheW91dCA9IGNsb25lTGF5b3V0O1xuZXhwb3J0cy5jbG9uZUxheW91dEl0ZW0gPSBjbG9uZUxheW91dEl0ZW07XG5leHBvcnRzLmNvbGxpZGVzID0gY29sbGlkZXM7XG5leHBvcnRzLmNvbXBhY3QgPSBjb21wYWN0O1xuZXhwb3J0cy5jb21wYWN0SXRlbSA9IGNvbXBhY3RJdGVtO1xuZXhwb3J0cy5jb21wYWN0VHlwZSA9IGNvbXBhY3RUeXBlO1xuZXhwb3J0cy5jb3JyZWN0Qm91bmRzID0gY29ycmVjdEJvdW5kcztcbmV4cG9ydHMuZmFzdFBvc2l0aW9uRXF1YWwgPSBmYXN0UG9zaXRpb25FcXVhbDtcbmV4cG9ydHMuZmFzdFJHTFByb3BzRXF1YWwgPSB2b2lkIDA7XG5leHBvcnRzLmdldEFsbENvbGxpc2lvbnMgPSBnZXRBbGxDb2xsaXNpb25zO1xuZXhwb3J0cy5nZXRGaXJzdENvbGxpc2lvbiA9IGdldEZpcnN0Q29sbGlzaW9uO1xuZXhwb3J0cy5nZXRMYXlvdXRJdGVtID0gZ2V0TGF5b3V0SXRlbTtcbmV4cG9ydHMuZ2V0U3RhdGljcyA9IGdldFN0YXRpY3M7XG5leHBvcnRzLm1vZGlmeUxheW91dCA9IG1vZGlmeUxheW91dDtcbmV4cG9ydHMubW92ZUVsZW1lbnQgPSBtb3ZlRWxlbWVudDtcbmV4cG9ydHMubW92ZUVsZW1lbnRBd2F5RnJvbUNvbGxpc2lvbiA9IG1vdmVFbGVtZW50QXdheUZyb21Db2xsaXNpb247XG5leHBvcnRzLm5vb3AgPSB2b2lkIDA7XG5leHBvcnRzLnBlcmMgPSBwZXJjO1xuZXhwb3J0cy5yZXNpemVJdGVtSW5EaXJlY3Rpb24gPSByZXNpemVJdGVtSW5EaXJlY3Rpb247XG5leHBvcnRzLnNldFRvcExlZnQgPSBzZXRUb3BMZWZ0O1xuZXhwb3J0cy5zZXRUcmFuc2Zvcm0gPSBzZXRUcmFuc2Zvcm07XG5leHBvcnRzLnNvcnRMYXlvdXRJdGVtcyA9IHNvcnRMYXlvdXRJdGVtcztcbmV4cG9ydHMuc29ydExheW91dEl0ZW1zQnlDb2xSb3cgPSBzb3J0TGF5b3V0SXRlbXNCeUNvbFJvdztcbmV4cG9ydHMuc29ydExheW91dEl0ZW1zQnlSb3dDb2wgPSBzb3J0TGF5b3V0SXRlbXNCeVJvd0NvbDtcbmV4cG9ydHMuc3luY2hyb25pemVMYXlvdXRXaXRoQ2hpbGRyZW4gPSBzeW5jaHJvbml6ZUxheW91dFdpdGhDaGlsZHJlbjtcbmV4cG9ydHMudmFsaWRhdGVMYXlvdXQgPSB2YWxpZGF0ZUxheW91dDtcbmV4cG9ydHMud2l0aExheW91dEl0ZW0gPSB3aXRoTGF5b3V0SXRlbTtcbnZhciBfZmFzdEVxdWFscyA9IHJlcXVpcmUoXCJmYXN0LWVxdWFsc1wiKTtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9OyB9XG4vKjo6IGltcG9ydCB0eXBlIHtcbiAgQ2hpbGRyZW5BcnJheSBhcyBSZWFjdENoaWxkcmVuQXJyYXksXG4gIEVsZW1lbnQgYXMgUmVhY3RFbGVtZW50XG59IGZyb20gXCJyZWFjdFwiOyovXG4vKjo6IGV4cG9ydCB0eXBlIFJlc2l6ZUhhbmRsZUF4aXMgPVxuICB8IFwic1wiXG4gIHwgXCJ3XCJcbiAgfCBcImVcIlxuICB8IFwiblwiXG4gIHwgXCJzd1wiXG4gIHwgXCJud1wiXG4gIHwgXCJzZVwiXG4gIHwgXCJuZVwiOyovXG4vKjo6IGV4cG9ydCB0eXBlIExheW91dEl0ZW0gPSB7XG4gIHc6IG51bWJlcixcbiAgaDogbnVtYmVyLFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlcixcbiAgaTogc3RyaW5nLFxuICBtaW5XPzogbnVtYmVyLFxuICBtaW5IPzogbnVtYmVyLFxuICBtYXhXPzogbnVtYmVyLFxuICBtYXhIPzogbnVtYmVyLFxuICBtb3ZlZD86IGJvb2xlYW4sXG4gIHN0YXRpYz86IGJvb2xlYW4sXG4gIGlzRHJhZ2dhYmxlPzogP2Jvb2xlYW4sXG4gIGlzUmVzaXphYmxlPzogP2Jvb2xlYW4sXG4gIHJlc2l6ZUhhbmRsZXM/OiBBcnJheTxSZXNpemVIYW5kbGVBeGlzPixcbiAgaXNCb3VuZGVkPzogP2Jvb2xlYW5cbn07Ki9cbi8qOjogZXhwb3J0IHR5cGUgTGF5b3V0ID0gJFJlYWRPbmx5QXJyYXk8TGF5b3V0SXRlbT47Ki9cbi8qOjogZXhwb3J0IHR5cGUgUG9zaXRpb24gPSB7XG4gIGxlZnQ6IG51bWJlcixcbiAgdG9wOiBudW1iZXIsXG4gIHdpZHRoOiBudW1iZXIsXG4gIGhlaWdodDogbnVtYmVyXG59OyovXG4vKjo6IGV4cG9ydCB0eXBlIFJlYWN0RHJhZ2dhYmxlQ2FsbGJhY2tEYXRhID0ge1xuICBub2RlOiBIVE1MRWxlbWVudCxcbiAgeD86IG51bWJlcixcbiAgeT86IG51bWJlcixcbiAgZGVsdGFYOiBudW1iZXIsXG4gIGRlbHRhWTogbnVtYmVyLFxuICBsYXN0WD86IG51bWJlcixcbiAgbGFzdFk/OiBudW1iZXJcbn07Ki9cbi8qOjogZXhwb3J0IHR5cGUgUGFydGlhbFBvc2l0aW9uID0geyBsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyIH07Ki9cbi8qOjogZXhwb3J0IHR5cGUgRHJvcHBpbmdQb3NpdGlvbiA9IHsgbGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgZTogRXZlbnQgfTsqL1xuLyo6OiBleHBvcnQgdHlwZSBTaXplID0geyB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9OyovXG4vKjo6IGV4cG9ydCB0eXBlIEdyaWREcmFnRXZlbnQgPSB7XG4gIGU6IEV2ZW50LFxuICBub2RlOiBIVE1MRWxlbWVudCxcbiAgbmV3UG9zaXRpb246IFBhcnRpYWxQb3NpdGlvblxufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBHcmlkUmVzaXplRXZlbnQgPSB7XG4gIGU6IEV2ZW50LFxuICBub2RlOiBIVE1MRWxlbWVudCxcbiAgc2l6ZTogU2l6ZSxcbiAgaGFuZGxlOiBzdHJpbmdcbn07Ki9cbi8qOjogZXhwb3J0IHR5cGUgRHJhZ092ZXJFdmVudCA9IE1vdXNlRXZlbnQgJiB7XG4gIG5hdGl2ZUV2ZW50OiB7XG4gICAgbGF5ZXJYOiBudW1iZXIsXG4gICAgbGF5ZXJZOiBudW1iZXIsXG4gICAgLi4uRXZlbnRcbiAgfVxufTsqL1xuLyo6OiBleHBvcnQgdHlwZSBQaWNrPEZyb21UeXBlLCBQcm9wZXJ0aWVzOiB7IFtzdHJpbmddOiAwIH0+ID0gJEV4YWN0PFxuICAkT2JqTWFwaTxQcm9wZXJ0aWVzLCA8SywgVj4oazogSywgdjogVikgPT4gJEVsZW1lbnRUeXBlPEZyb21UeXBlLCBLPj5cbj47Ki9cbi8vIEhlbHBmdWwgcG9ydCBmcm9tIFRTXG4vKjo6IHR5cGUgUkVsID0gUmVhY3RFbGVtZW50PGFueT47Ki9cbi8qOjogZXhwb3J0IHR5cGUgUmVhY3RDaGlsZHJlbiA9IFJlYWN0Q2hpbGRyZW5BcnJheTxSRWw+OyovXG4vKjo6IGV4cG9ydCB0eXBlIEV2ZW50Q2FsbGJhY2sgPSAoXG4gIExheW91dCxcbiAgb2xkSXRlbTogP0xheW91dEl0ZW0sXG4gIG5ld0l0ZW06ID9MYXlvdXRJdGVtLFxuICBwbGFjZWhvbGRlcjogP0xheW91dEl0ZW0sXG4gIEV2ZW50LFxuICA/SFRNTEVsZW1lbnRcbikgPT4gdm9pZDsqL1xuLy8gQWxsIGNhbGxiYWNrcyBhcmUgb2YgdGhlIHNpZ25hdHVyZSAobGF5b3V0LCBvbGRJdGVtLCBuZXdJdGVtLCBwbGFjZWhvbGRlciwgZSkuXG4vKjo6IGV4cG9ydCB0eXBlIENvbXBhY3RUeXBlID0gPyhcImhvcml6b250YWxcIiB8IFwidmVydGljYWxcIik7Ki9cbmNvbnN0IGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIjtcbmNvbnN0IERFQlVHID0gZmFsc2U7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBib3R0b20gY29vcmRpbmF0ZSBvZiB0aGUgbGF5b3V0LlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBsYXlvdXQgTGF5b3V0IGFycmF5LlxuICogQHJldHVybiB7TnVtYmVyfSAgICAgICBCb3R0b20gY29vcmRpbmF0ZS5cbiAqL1xuZnVuY3Rpb24gYm90dG9tKGxheW91dCAvKjogTGF5b3V0Ki8pIC8qOiBudW1iZXIqL3tcbiAgbGV0IG1heCA9IDAsXG4gICAgYm90dG9tWTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxheW91dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGJvdHRvbVkgPSBsYXlvdXRbaV0ueSArIGxheW91dFtpXS5oO1xuICAgIGlmIChib3R0b21ZID4gbWF4KSBtYXggPSBib3R0b21ZO1xuICB9XG4gIHJldHVybiBtYXg7XG59XG5mdW5jdGlvbiBjbG9uZUxheW91dChsYXlvdXQgLyo6IExheW91dCovKSAvKjogTGF5b3V0Ki97XG4gIGNvbnN0IG5ld0xheW91dCA9IEFycmF5KGxheW91dC5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGF5b3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmV3TGF5b3V0W2ldID0gY2xvbmVMYXlvdXRJdGVtKGxheW91dFtpXSk7XG4gIH1cbiAgcmV0dXJuIG5ld0xheW91dDtcbn1cblxuLy8gTW9kaWZ5IGEgbGF5b3V0SXRlbSBpbnNpZGUgYSBsYXlvdXQuIFJldHVybnMgYSBuZXcgTGF5b3V0LFxuLy8gZG9lcyBub3QgbXV0YXRlLiBDYXJyaWVzIG92ZXIgYWxsIG90aGVyIExheW91dEl0ZW1zIHVubW9kaWZpZWQuXG5mdW5jdGlvbiBtb2RpZnlMYXlvdXQobGF5b3V0IC8qOiBMYXlvdXQqLywgbGF5b3V0SXRlbSAvKjogTGF5b3V0SXRlbSovKSAvKjogTGF5b3V0Ki97XG4gIGNvbnN0IG5ld0xheW91dCA9IEFycmF5KGxheW91dC5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGF5b3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGxheW91dEl0ZW0uaSA9PT0gbGF5b3V0W2ldLmkpIHtcbiAgICAgIG5ld0xheW91dFtpXSA9IGxheW91dEl0ZW07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0xheW91dFtpXSA9IGxheW91dFtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld0xheW91dDtcbn1cblxuLy8gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHRvIG1vZGlmeSBhIGxheW91dCBpdGVtLlxuLy8gRG9lcyBkZWZlbnNpdmUgY2xvbmVzIHRvIGVuc3VyZSB0aGUgbGF5b3V0IGlzIG5vdCBtb2RpZmllZC5cbmZ1bmN0aW9uIHdpdGhMYXlvdXRJdGVtKGxheW91dCAvKjogTGF5b3V0Ki8sIGl0ZW1LZXkgLyo6IHN0cmluZyovLCBjYiAvKjogTGF5b3V0SXRlbSA9PiBMYXlvdXRJdGVtKi8pIC8qOiBbTGF5b3V0LCA/TGF5b3V0SXRlbV0qL3tcbiAgbGV0IGl0ZW0gPSBnZXRMYXlvdXRJdGVtKGxheW91dCwgaXRlbUtleSk7XG4gIGlmICghaXRlbSkgcmV0dXJuIFtsYXlvdXQsIG51bGxdO1xuICBpdGVtID0gY2IoY2xvbmVMYXlvdXRJdGVtKGl0ZW0pKTsgLy8gZGVmZW5zaXZlIGNsb25lIHRoZW4gbW9kaWZ5XG4gIC8vIEZJWE1FIGNvdWxkIGRvIHRoaXMgZmFzdGVyIGlmIHdlIGFscmVhZHkga25ldyB0aGUgaW5kZXhcbiAgbGF5b3V0ID0gbW9kaWZ5TGF5b3V0KGxheW91dCwgaXRlbSk7XG4gIHJldHVybiBbbGF5b3V0LCBpdGVtXTtcbn1cblxuLy8gRmFzdCBwYXRoIHRvIGNsb25pbmcsIHNpbmNlIHRoaXMgaXMgbW9ub21vcnBoaWNcbmZ1bmN0aW9uIGNsb25lTGF5b3V0SXRlbShsYXlvdXRJdGVtIC8qOiBMYXlvdXRJdGVtKi8pIC8qOiBMYXlvdXRJdGVtKi97XG4gIHJldHVybiB7XG4gICAgdzogbGF5b3V0SXRlbS53LFxuICAgIGg6IGxheW91dEl0ZW0uaCxcbiAgICB4OiBsYXlvdXRJdGVtLngsXG4gICAgeTogbGF5b3V0SXRlbS55LFxuICAgIGk6IGxheW91dEl0ZW0uaSxcbiAgICBtaW5XOiBsYXlvdXRJdGVtLm1pblcsXG4gICAgbWF4VzogbGF5b3V0SXRlbS5tYXhXLFxuICAgIG1pbkg6IGxheW91dEl0ZW0ubWluSCxcbiAgICBtYXhIOiBsYXlvdXRJdGVtLm1heEgsXG4gICAgbW92ZWQ6IEJvb2xlYW4obGF5b3V0SXRlbS5tb3ZlZCksXG4gICAgc3RhdGljOiBCb29sZWFuKGxheW91dEl0ZW0uc3RhdGljKSxcbiAgICAvLyBUaGVzZSBjYW4gYmUgbnVsbC91bmRlZmluZWRcbiAgICBpc0RyYWdnYWJsZTogbGF5b3V0SXRlbS5pc0RyYWdnYWJsZSxcbiAgICBpc1Jlc2l6YWJsZTogbGF5b3V0SXRlbS5pc1Jlc2l6YWJsZSxcbiAgICByZXNpemVIYW5kbGVzOiBsYXlvdXRJdGVtLnJlc2l6ZUhhbmRsZXMsXG4gICAgaXNCb3VuZGVkOiBsYXlvdXRJdGVtLmlzQm91bmRlZFxuICB9O1xufVxuXG4vKipcbiAqIENvbXBhcmluZyBSZWFjdCBgY2hpbGRyZW5gIGlzIGEgYml0IGRpZmZpY3VsdC4gVGhpcyBpcyBhIGdvb2Qgd2F5IHRvIGNvbXBhcmUgdGhlbS5cbiAqIFRoaXMgd2lsbCBjYXRjaCBkaWZmZXJlbmNlcyBpbiBrZXlzLCBvcmRlciwgYW5kIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gY2hpbGRyZW5FcXVhbChhIC8qOiBSZWFjdENoaWxkcmVuKi8sIGIgLyo6IFJlYWN0Q2hpbGRyZW4qLykgLyo6IGJvb2xlYW4qL3tcbiAgcmV0dXJuICgwLCBfZmFzdEVxdWFscy5kZWVwRXF1YWwpKF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLm1hcChhLCBjID0+IGM/LmtleSksIF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLm1hcChiLCBjID0+IGM/LmtleSkpICYmICgwLCBfZmFzdEVxdWFscy5kZWVwRXF1YWwpKF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLm1hcChhLCBjID0+IGM/LnByb3BzW1wiZGF0YS1ncmlkXCJdKSwgX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ubWFwKGIsIGMgPT4gYz8ucHJvcHNbXCJkYXRhLWdyaWRcIl0pKTtcbn1cblxuLyoqXG4gKiBTZWUgYGZhc3RSR0xQcm9wc0VxdWFsLmpzYC5cbiAqIFdlIHdhbnQgdGhpcyB0byBydW4gYXMgZmFzdCBhcyBwb3NzaWJsZSAtIGl0IGlzIGNhbGxlZCBvZnRlbiAtIGFuZCB0byBiZVxuICogcmVzaWxpZW50IHRvIG5ldyBwcm9wcyB0aGF0IHdlIGFkZC4gU28gcmF0aGVyIHRoYW4gY2FsbCBsb2Rhc2guaXNFcXVhbCxcbiAqIHdoaWNoIGlzbid0IHN1aXRlZCB0byBjb21wYXJpbmcgcHJvcHMgdmVyeSB3ZWxsLCB3ZSB1c2UgdGhpcyBzcGVjaWFsaXplZFxuICogZnVuY3Rpb24gaW4gY29uanVuY3Rpb24gd2l0aCBwcmV2YWwgdG8gZ2VuZXJhdGUgdGhlIGZhc3Rlc3QgcG9zc2libGUgY29tcGFyaXNvblxuICogZnVuY3Rpb24sIHR1bmVkIGZvciBleGFjdGx5IG91ciBwcm9wcy5cbiAqL1xuLyo6OiB0eXBlIEZhc3RSR0xQcm9wc0VxdWFsID0gKE9iamVjdCwgT2JqZWN0LCBGdW5jdGlvbikgPT4gYm9vbGVhbjsqL1xuY29uc3QgZmFzdFJHTFByb3BzRXF1YWwgLyo6IEZhc3RSR0xQcm9wc0VxdWFsKi8gPSBleHBvcnRzLmZhc3RSR0xQcm9wc0VxdWFsID0gcmVxdWlyZShcIi4vZmFzdFJHTFByb3BzRXF1YWxcIik7XG5cbi8vIExpa2UgdGhlIGFib3ZlLCBidXQgYSBsb3Qgc2ltcGxlci5cbmZ1bmN0aW9uIGZhc3RQb3NpdGlvbkVxdWFsKGEgLyo6IFBvc2l0aW9uKi8sIGIgLyo6IFBvc2l0aW9uKi8pIC8qOiBib29sZWFuKi97XG4gIHJldHVybiBhLmxlZnQgPT09IGIubGVmdCAmJiBhLnRvcCA9PT0gYi50b3AgJiYgYS53aWR0aCA9PT0gYi53aWR0aCAmJiBhLmhlaWdodCA9PT0gYi5oZWlnaHQ7XG59XG5cbi8qKlxuICogR2l2ZW4gdHdvIGxheW91dGl0ZW1zLCBjaGVjayBpZiB0aGV5IGNvbGxpZGUuXG4gKi9cbmZ1bmN0aW9uIGNvbGxpZGVzKGwxIC8qOiBMYXlvdXRJdGVtKi8sIGwyIC8qOiBMYXlvdXRJdGVtKi8pIC8qOiBib29sZWFuKi97XG4gIGlmIChsMS5pID09PSBsMi5pKSByZXR1cm4gZmFsc2U7IC8vIHNhbWUgZWxlbWVudFxuICBpZiAobDEueCArIGwxLncgPD0gbDIueCkgcmV0dXJuIGZhbHNlOyAvLyBsMSBpcyBsZWZ0IG9mIGwyXG4gIGlmIChsMS54ID49IGwyLnggKyBsMi53KSByZXR1cm4gZmFsc2U7IC8vIGwxIGlzIHJpZ2h0IG9mIGwyXG4gIGlmIChsMS55ICsgbDEuaCA8PSBsMi55KSByZXR1cm4gZmFsc2U7IC8vIGwxIGlzIGFib3ZlIGwyXG4gIGlmIChsMS55ID49IGwyLnkgKyBsMi5oKSByZXR1cm4gZmFsc2U7IC8vIGwxIGlzIGJlbG93IGwyXG4gIHJldHVybiB0cnVlOyAvLyBib3hlcyBvdmVybGFwXG59XG5cbi8qKlxuICogR2l2ZW4gYSBsYXlvdXQsIGNvbXBhY3QgaXQuIFRoaXMgaW52b2x2ZXMgZ29pbmcgZG93biBlYWNoIHkgY29vcmRpbmF0ZSBhbmQgcmVtb3ZpbmcgZ2Fwc1xuICogYmV0d2VlbiBpdGVtcy5cbiAqXG4gKiBEb2VzIG5vdCBtb2RpZnkgbGF5b3V0IGl0ZW1zIChjbG9uZXMpLiBDcmVhdGVzIGEgbmV3IGxheW91dCBhcnJheS5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gbGF5b3V0IExheW91dC5cbiAqIEBwYXJhbSAge0Jvb2xlYW59IHZlcnRpY2FsQ29tcGFjdCBXaGV0aGVyIG9yIG5vdCB0byBjb21wYWN0IHRoZSBsYXlvdXRcbiAqICAgdmVydGljYWxseS5cbiAqIEBwYXJhbSAge0Jvb2xlYW59IGFsbG93T3ZlcmxhcCBXaGVuIGB0cnVlYCwgYWxsb3dzIG92ZXJsYXBwaW5nIGdyaWQgaXRlbXMuXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgQ29tcGFjdGVkIExheW91dC5cbiAqL1xuZnVuY3Rpb24gY29tcGFjdChsYXlvdXQgLyo6IExheW91dCovLCBjb21wYWN0VHlwZSAvKjogQ29tcGFjdFR5cGUqLywgY29scyAvKjogbnVtYmVyKi8sIGFsbG93T3ZlcmxhcCAvKjogP2Jvb2xlYW4qLykgLyo6IExheW91dCove1xuICAvLyBTdGF0aWNzIGdvIGluIHRoZSBjb21wYXJlV2l0aCBhcnJheSByaWdodCBhd2F5IHNvIGl0ZW1zIGZsb3cgYXJvdW5kIHRoZW0uXG4gIGNvbnN0IGNvbXBhcmVXaXRoID0gZ2V0U3RhdGljcyhsYXlvdXQpO1xuICAvLyBXZSBnbyB0aHJvdWdoIHRoZSBpdGVtcyBieSByb3cgYW5kIGNvbHVtbi5cbiAgY29uc3Qgc29ydGVkID0gc29ydExheW91dEl0ZW1zKGxheW91dCwgY29tcGFjdFR5cGUpO1xuICAvLyBIb2xkaW5nIGZvciBuZXcgaXRlbXMuXG4gIGNvbnN0IG91dCA9IEFycmF5KGxheW91dC5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gc29ydGVkLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbGV0IGwgPSBjbG9uZUxheW91dEl0ZW0oc29ydGVkW2ldKTtcblxuICAgIC8vIERvbid0IG1vdmUgc3RhdGljIGVsZW1lbnRzXG4gICAgaWYgKCFsLnN0YXRpYykge1xuICAgICAgbCA9IGNvbXBhY3RJdGVtKGNvbXBhcmVXaXRoLCBsLCBjb21wYWN0VHlwZSwgY29scywgc29ydGVkLCBhbGxvd092ZXJsYXApO1xuXG4gICAgICAvLyBBZGQgdG8gY29tcGFyaXNvbiBhcnJheS4gV2Ugb25seSBjb2xsaWRlIHdpdGggaXRlbXMgYmVmb3JlIHRoaXMgb25lLlxuICAgICAgLy8gU3RhdGljcyBhcmUgYWxyZWFkeSBpbiB0aGlzIGFycmF5LlxuICAgICAgY29tcGFyZVdpdGgucHVzaChsKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdG8gb3V0cHV0IGFycmF5IHRvIG1ha2Ugc3VyZSB0aGV5IHN0aWxsIGNvbWUgb3V0IGluIHRoZSByaWdodCBvcmRlci5cbiAgICBvdXRbbGF5b3V0LmluZGV4T2Yoc29ydGVkW2ldKV0gPSBsO1xuXG4gICAgLy8gQ2xlYXIgbW92ZWQgZmxhZywgaWYgaXQgZXhpc3RzLlxuICAgIGwubW92ZWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuY29uc3QgaGVpZ2h0V2lkdGggPSB7XG4gIHg6IFwid1wiLFxuICB5OiBcImhcIlxufTtcbi8qKlxuICogQmVmb3JlIG1vdmluZyBpdGVtIGRvd24sIGl0IHdpbGwgY2hlY2sgaWYgdGhlIG1vdmVtZW50IHdpbGwgY2F1c2UgY29sbGlzaW9ucyBhbmQgbW92ZSB0aG9zZSBpdGVtcyBkb3duIGJlZm9yZS5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUNvbXBhY3Rpb25Db2xsaXNpb24obGF5b3V0IC8qOiBMYXlvdXQqLywgaXRlbSAvKjogTGF5b3V0SXRlbSovLCBtb3ZlVG9Db29yZCAvKjogbnVtYmVyKi8sIGF4aXMgLyo6IFwieFwiIHwgXCJ5XCIqLykge1xuICBjb25zdCBzaXplUHJvcCA9IGhlaWdodFdpZHRoW2F4aXNdO1xuICBpdGVtW2F4aXNdICs9IDE7XG4gIGNvbnN0IGl0ZW1JbmRleCA9IGxheW91dC5tYXAobGF5b3V0SXRlbSA9PiB7XG4gICAgcmV0dXJuIGxheW91dEl0ZW0uaTtcbiAgfSkuaW5kZXhPZihpdGVtLmkpO1xuXG4gIC8vIEdvIHRocm91Z2ggZWFjaCBpdGVtIHdlIGNvbGxpZGUgd2l0aC5cbiAgZm9yIChsZXQgaSA9IGl0ZW1JbmRleCArIDE7IGkgPCBsYXlvdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBvdGhlckl0ZW0gPSBsYXlvdXRbaV07XG4gICAgLy8gSWdub3JlIHN0YXRpYyBpdGVtc1xuICAgIGlmIChvdGhlckl0ZW0uc3RhdGljKSBjb250aW51ZTtcblxuICAgIC8vIE9wdGltaXphdGlvbjogd2UgY2FuIGJyZWFrIGVhcmx5IGlmIHdlIGtub3cgd2UncmUgcGFzdCB0aGlzIGVsXG4gICAgLy8gV2UgY2FuIGRvIHRoaXMgYi9jIGl0J3MgYSBzb3J0ZWQgbGF5b3V0XG4gICAgaWYgKG90aGVySXRlbS55ID4gaXRlbS55ICsgaXRlbS5oKSBicmVhaztcbiAgICBpZiAoY29sbGlkZXMoaXRlbSwgb3RoZXJJdGVtKSkge1xuICAgICAgcmVzb2x2ZUNvbXBhY3Rpb25Db2xsaXNpb24obGF5b3V0LCBvdGhlckl0ZW0sIG1vdmVUb0Nvb3JkICsgaXRlbVtzaXplUHJvcF0sIGF4aXMpO1xuICAgIH1cbiAgfVxuICBpdGVtW2F4aXNdID0gbW92ZVRvQ29vcmQ7XG59XG5cbi8qKlxuICogQ29tcGFjdCBhbiBpdGVtIGluIHRoZSBsYXlvdXQuXG4gKlxuICogTW9kaWZpZXMgaXRlbS5cbiAqXG4gKi9cbmZ1bmN0aW9uIGNvbXBhY3RJdGVtKGNvbXBhcmVXaXRoIC8qOiBMYXlvdXQqLywgbCAvKjogTGF5b3V0SXRlbSovLCBjb21wYWN0VHlwZSAvKjogQ29tcGFjdFR5cGUqLywgY29scyAvKjogbnVtYmVyKi8sIGZ1bGxMYXlvdXQgLyo6IExheW91dCovLCBhbGxvd092ZXJsYXAgLyo6ID9ib29sZWFuKi8pIC8qOiBMYXlvdXRJdGVtKi97XG4gIGNvbnN0IGNvbXBhY3RWID0gY29tcGFjdFR5cGUgPT09IFwidmVydGljYWxcIjtcbiAgY29uc3QgY29tcGFjdEggPSBjb21wYWN0VHlwZSA9PT0gXCJob3Jpem9udGFsXCI7XG4gIGlmIChjb21wYWN0Vikge1xuICAgIC8vIEJvdHRvbSAneScgcG9zc2libGUgaXMgdGhlIGJvdHRvbSBvZiB0aGUgbGF5b3V0LlxuICAgIC8vIFRoaXMgYWxsb3dzIHlvdSB0byBkbyBuaWNlIHN0dWZmIGxpa2Ugc3BlY2lmeSB7eTogSW5maW5pdHl9XG4gICAgLy8gVGhpcyBpcyBoZXJlIGJlY2F1c2UgdGhlIGxheW91dCBtdXN0IGJlIHNvcnRlZCBpbiBvcmRlciB0byBnZXQgdGhlIGNvcnJlY3QgYm90dG9tIGB5YC5cbiAgICBsLnkgPSBNYXRoLm1pbihib3R0b20oY29tcGFyZVdpdGgpLCBsLnkpO1xuICAgIC8vIE1vdmUgdGhlIGVsZW1lbnQgdXAgYXMgZmFyIGFzIGl0IGNhbiBnbyB3aXRob3V0IGNvbGxpZGluZy5cbiAgICB3aGlsZSAobC55ID4gMCAmJiAhZ2V0Rmlyc3RDb2xsaXNpb24oY29tcGFyZVdpdGgsIGwpKSB7XG4gICAgICBsLnktLTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY29tcGFjdEgpIHtcbiAgICAvLyBNb3ZlIHRoZSBlbGVtZW50IGxlZnQgYXMgZmFyIGFzIGl0IGNhbiBnbyB3aXRob3V0IGNvbGxpZGluZy5cbiAgICB3aGlsZSAobC54ID4gMCAmJiAhZ2V0Rmlyc3RDb2xsaXNpb24oY29tcGFyZVdpdGgsIGwpKSB7XG4gICAgICBsLngtLTtcbiAgICB9XG4gIH1cblxuICAvLyBNb3ZlIGl0IGRvd24sIGFuZCBrZWVwIG1vdmluZyBpdCBkb3duIGlmIGl0J3MgY29sbGlkaW5nLlxuICBsZXQgY29sbGlkZXM7XG4gIC8vIENoZWNraW5nIHRoZSBjb21wYWN0VHlwZSBudWxsIHZhbHVlIHRvIGF2b2lkIGJyZWFraW5nIHRoZSBsYXlvdXQgd2hlbiBvdmVybGFwcGluZyBpcyBhbGxvd2VkLlxuICB3aGlsZSAoKGNvbGxpZGVzID0gZ2V0Rmlyc3RDb2xsaXNpb24oY29tcGFyZVdpdGgsIGwpKSAmJiAhKGNvbXBhY3RUeXBlID09PSBudWxsICYmIGFsbG93T3ZlcmxhcCkpIHtcbiAgICBpZiAoY29tcGFjdEgpIHtcbiAgICAgIHJlc29sdmVDb21wYWN0aW9uQ29sbGlzaW9uKGZ1bGxMYXlvdXQsIGwsIGNvbGxpZGVzLnggKyBjb2xsaWRlcy53LCBcInhcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmVDb21wYWN0aW9uQ29sbGlzaW9uKGZ1bGxMYXlvdXQsIGwsIGNvbGxpZGVzLnkgKyBjb2xsaWRlcy5oLCBcInlcIik7XG4gICAgfVxuICAgIC8vIFNpbmNlIHdlIGNhbid0IGdyb3cgd2l0aG91dCBib3VuZHMgaG9yaXpvbnRhbGx5LCBpZiB3ZSd2ZSBvdmVyZmxvd24sIGxldCdzIG1vdmUgaXQgZG93biBhbmQgdHJ5IGFnYWluLlxuICAgIGlmIChjb21wYWN0SCAmJiBsLnggKyBsLncgPiBjb2xzKSB7XG4gICAgICBsLnggPSBjb2xzIC0gbC53O1xuICAgICAgbC55Kys7XG4gICAgICAvLyBBTHNvIG1vdmUgZWxlbWVudCBhcyBsZWZ0IGFzIHdlIGNhblxuICAgICAgd2hpbGUgKGwueCA+IDAgJiYgIWdldEZpcnN0Q29sbGlzaW9uKGNvbXBhcmVXaXRoLCBsKSkge1xuICAgICAgICBsLngtLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBFbnN1cmUgdGhhdCB0aGVyZSBhcmUgbm8gbmVnYXRpdmUgcG9zaXRpb25zXG4gIGwueSA9IE1hdGgubWF4KGwueSwgMCk7XG4gIGwueCA9IE1hdGgubWF4KGwueCwgMCk7XG4gIHJldHVybiBsO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgbGF5b3V0LCBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGZpdCB3aXRoaW4gaXRzIGJvdW5kcy5cbiAqXG4gKiBNb2RpZmllcyBsYXlvdXQgaXRlbXMuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGxheW91dCBMYXlvdXQgYXJyYXkuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGJvdW5kcyBOdW1iZXIgb2YgY29sdW1ucy5cbiAqL1xuZnVuY3Rpb24gY29ycmVjdEJvdW5kcyhsYXlvdXQgLyo6IExheW91dCovLCBib3VuZHMgLyo6IHsgY29sczogbnVtYmVyIH0qLykgLyo6IExheW91dCove1xuICBjb25zdCBjb2xsaWRlc1dpdGggPSBnZXRTdGF0aWNzKGxheW91dCk7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsYXlvdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBsID0gbGF5b3V0W2ldO1xuICAgIC8vIE92ZXJmbG93cyByaWdodFxuICAgIGlmIChsLnggKyBsLncgPiBib3VuZHMuY29scykgbC54ID0gYm91bmRzLmNvbHMgLSBsLnc7XG4gICAgLy8gT3ZlcmZsb3dzIGxlZnRcbiAgICBpZiAobC54IDwgMCkge1xuICAgICAgbC54ID0gMDtcbiAgICAgIGwudyA9IGJvdW5kcy5jb2xzO1xuICAgIH1cbiAgICBpZiAoIWwuc3RhdGljKSBjb2xsaWRlc1dpdGgucHVzaChsKTtlbHNlIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgc3RhdGljIGFuZCBjb2xsaWRlcyB3aXRoIG90aGVyIHN0YXRpY3MsIHdlIG11c3QgbW92ZSBpdCBkb3duLlxuICAgICAgLy8gV2UgaGF2ZSB0byBkbyBzb21ldGhpbmcgbmljZXIgdGhhbiBqdXN0IGxldHRpbmcgdGhlbSBvdmVybGFwLlxuICAgICAgd2hpbGUgKGdldEZpcnN0Q29sbGlzaW9uKGNvbGxpZGVzV2l0aCwgbCkpIHtcbiAgICAgICAgbC55Kys7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBsYXlvdXQ7XG59XG5cbi8qKlxuICogR2V0IGEgbGF5b3V0IGl0ZW0gYnkgSUQuIFVzZWQgc28gd2UgY2FuIG92ZXJyaWRlIGxhdGVyIG9uIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gIGxheW91dCBMYXlvdXQgYXJyYXkuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGlkICAgICBJRFxuICogQHJldHVybiB7TGF5b3V0SXRlbX0gICAgSXRlbSBhdCBJRC5cbiAqL1xuZnVuY3Rpb24gZ2V0TGF5b3V0SXRlbShsYXlvdXQgLyo6IExheW91dCovLCBpZCAvKjogc3RyaW5nKi8pIC8qOiA/TGF5b3V0SXRlbSove1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGF5b3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGxheW91dFtpXS5pID09PSBpZCkgcmV0dXJuIGxheW91dFtpXTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGl0ZW0gdGhpcyBsYXlvdXQgY29sbGlkZXMgd2l0aC5cbiAqIEl0IGRvZXNuJ3QgYXBwZWFyIHRvIG1hdHRlciB3aGljaCBvcmRlciB3ZSBhcHByb2FjaCB0aGlzIGZyb20sIGFsdGhvdWdoXG4gKiBwZXJoYXBzIHRoYXQgaXMgdGhlIHdyb25nIHRoaW5nIHRvIGRvLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gbGF5b3V0SXRlbSBMYXlvdXQgaXRlbS5cbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9ICBBIGNvbGxpZGluZyBsYXlvdXQgaXRlbSwgb3IgdW5kZWZpbmVkLlxuICovXG5mdW5jdGlvbiBnZXRGaXJzdENvbGxpc2lvbihsYXlvdXQgLyo6IExheW91dCovLCBsYXlvdXRJdGVtIC8qOiBMYXlvdXRJdGVtKi8pIC8qOiA/TGF5b3V0SXRlbSove1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gbGF5b3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGNvbGxpZGVzKGxheW91dFtpXSwgbGF5b3V0SXRlbSkpIHJldHVybiBsYXlvdXRbaV07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEFsbENvbGxpc2lvbnMobGF5b3V0IC8qOiBMYXlvdXQqLywgbGF5b3V0SXRlbSAvKjogTGF5b3V0SXRlbSovKSAvKjogQXJyYXk8TGF5b3V0SXRlbT4qL3tcbiAgcmV0dXJuIGxheW91dC5maWx0ZXIobCA9PiBjb2xsaWRlcyhsLCBsYXlvdXRJdGVtKSk7XG59XG5cbi8qKlxuICogR2V0IGFsbCBzdGF0aWMgZWxlbWVudHMuXG4gKiBAcGFyYW0gIHtBcnJheX0gbGF5b3V0IEFycmF5IG9mIGxheW91dCBvYmplY3RzLlxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICBBcnJheSBvZiBzdGF0aWMgbGF5b3V0IGl0ZW1zLi5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGljcyhsYXlvdXQgLyo6IExheW91dCovKSAvKjogQXJyYXk8TGF5b3V0SXRlbT4qL3tcbiAgcmV0dXJuIGxheW91dC5maWx0ZXIobCA9PiBsLnN0YXRpYyk7XG59XG5cbi8qKlxuICogTW92ZSBhbiBlbGVtZW50LiBSZXNwb25zaWJsZSBmb3IgZG9pbmcgY2FzY2FkaW5nIG1vdmVtZW50cyBvZiBvdGhlciBlbGVtZW50cy5cbiAqXG4gKiBNb2RpZmllcyBsYXlvdXQgaXRlbXMuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgbGF5b3V0ICAgICAgICAgICAgRnVsbCBsYXlvdXQgdG8gbW9kaWZ5LlxuICogQHBhcmFtICB7TGF5b3V0SXRlbX0gbCAgICAgICAgICAgICAgICAgZWxlbWVudCB0byBtb3ZlLlxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgW3hdICAgICAgICAgICAgICAgWCBwb3NpdGlvbiBpbiBncmlkIHVuaXRzLlxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgW3ldICAgICAgICAgICAgICAgWSBwb3NpdGlvbiBpbiBncmlkIHVuaXRzLlxuICovXG5mdW5jdGlvbiBtb3ZlRWxlbWVudChsYXlvdXQgLyo6IExheW91dCovLCBsIC8qOiBMYXlvdXRJdGVtKi8sIHggLyo6ID9udW1iZXIqLywgeSAvKjogP251bWJlciovLCBpc1VzZXJBY3Rpb24gLyo6ID9ib29sZWFuKi8sIHByZXZlbnRDb2xsaXNpb24gLyo6ID9ib29sZWFuKi8sIGNvbXBhY3RUeXBlIC8qOiBDb21wYWN0VHlwZSovLCBjb2xzIC8qOiBudW1iZXIqLywgYWxsb3dPdmVybGFwIC8qOiA/Ym9vbGVhbiovKSAvKjogTGF5b3V0Ki97XG4gIC8vIElmIHRoaXMgaXMgc3RhdGljIGFuZCBub3QgZXhwbGljaXRseSBlbmFibGVkIGFzIGRyYWdnYWJsZSxcbiAgLy8gbm8gbW92ZSBpcyBwb3NzaWJsZSwgc28gd2UgY2FuIHNob3J0LWNpcmN1aXQgdGhpcyBpbW1lZGlhdGVseS5cbiAgaWYgKGwuc3RhdGljICYmIGwuaXNEcmFnZ2FibGUgIT09IHRydWUpIHJldHVybiBsYXlvdXQ7XG5cbiAgLy8gU2hvcnQtY2lyY3VpdCBpZiBub3RoaW5nIHRvIGRvLlxuICBpZiAobC55ID09PSB5ICYmIGwueCA9PT0geCkgcmV0dXJuIGxheW91dDtcbiAgbG9nKGBNb3ZpbmcgZWxlbWVudCAke2wuaX0gdG8gWyR7U3RyaW5nKHgpfSwke1N0cmluZyh5KX1dIGZyb20gWyR7bC54fSwke2wueX1dYCk7XG4gIGNvbnN0IG9sZFggPSBsLng7XG4gIGNvbnN0IG9sZFkgPSBsLnk7XG5cbiAgLy8gVGhpcyBpcyBxdWl0ZSBhIGJpdCBmYXN0ZXIgdGhhbiBleHRlbmRpbmcgdGhlIG9iamVjdFxuICBpZiAodHlwZW9mIHggPT09IFwibnVtYmVyXCIpIGwueCA9IHg7XG4gIGlmICh0eXBlb2YgeSA9PT0gXCJudW1iZXJcIikgbC55ID0geTtcbiAgbC5tb3ZlZCA9IHRydWU7XG5cbiAgLy8gSWYgdGhpcyBjb2xsaWRlcyB3aXRoIGFueXRoaW5nLCBtb3ZlIGl0LlxuICAvLyBXaGVuIGRvaW5nIHRoaXMgY29tcGFyaXNvbiwgd2UgaGF2ZSB0byBzb3J0IHRoZSBpdGVtcyB3ZSBjb21wYXJlIHdpdGhcbiAgLy8gdG8gZW5zdXJlLCBpbiB0aGUgY2FzZSBvZiBtdWx0aXBsZSBjb2xsaXNpb25zLCB0aGF0IHdlJ3JlIGdldHRpbmcgdGhlXG4gIC8vIG5lYXJlc3QgY29sbGlzaW9uLlxuICBsZXQgc29ydGVkID0gc29ydExheW91dEl0ZW1zKGxheW91dCwgY29tcGFjdFR5cGUpO1xuICBjb25zdCBtb3ZpbmdVcCA9IGNvbXBhY3RUeXBlID09PSBcInZlcnRpY2FsXCIgJiYgdHlwZW9mIHkgPT09IFwibnVtYmVyXCIgPyBvbGRZID49IHkgOiBjb21wYWN0VHlwZSA9PT0gXCJob3Jpem9udGFsXCIgJiYgdHlwZW9mIHggPT09IFwibnVtYmVyXCIgPyBvbGRYID49IHggOiBmYWxzZTtcbiAgLy8gJEZsb3dJZ25vcmUgYWNjZXB0YWJsZSBtb2RpZmljYXRpb24gb2YgcmVhZC1vbmx5IGFycmF5IGFzIGl0IHdhcyByZWNlbnRseSBjbG9uZWRcbiAgaWYgKG1vdmluZ1VwKSBzb3J0ZWQgPSBzb3J0ZWQucmV2ZXJzZSgpO1xuICBjb25zdCBjb2xsaXNpb25zID0gZ2V0QWxsQ29sbGlzaW9ucyhzb3J0ZWQsIGwpO1xuICBjb25zdCBoYXNDb2xsaXNpb25zID0gY29sbGlzaW9ucy5sZW5ndGggPiAwO1xuXG4gIC8vIFdlIG1heSBoYXZlIGNvbGxpc2lvbnMuIFdlIGNhbiBzaG9ydC1jaXJjdWl0IGlmIHdlJ3ZlIHR1cm5lZCBvZmYgY29sbGlzaW9ucyBvclxuICAvLyBhbGxvd2VkIG92ZXJsYXAuXG4gIGlmIChoYXNDb2xsaXNpb25zICYmIGFsbG93T3ZlcmxhcCkge1xuICAgIC8vIEVhc3ksIHdlIGRvbid0IG5lZWQgdG8gcmVzb2x2ZSBjb2xsaXNpb25zLiBCdXQgd2UgKmRpZCogY2hhbmdlIHRoZSBsYXlvdXQsXG4gICAgLy8gc28gY2xvbmUgaXQgb24gdGhlIHdheSBvdXQuXG4gICAgcmV0dXJuIGNsb25lTGF5b3V0KGxheW91dCk7XG4gIH0gZWxzZSBpZiAoaGFzQ29sbGlzaW9ucyAmJiBwcmV2ZW50Q29sbGlzaW9uKSB7XG4gICAgLy8gSWYgd2UgYXJlIHByZXZlbnRpbmcgY29sbGlzaW9uIGJ1dCBub3QgYWxsb3dpbmcgb3ZlcmxhcCwgd2UgbmVlZCB0b1xuICAgIC8vIHJldmVydCB0aGUgcG9zaXRpb24gb2YgdGhpcyBlbGVtZW50IHNvIGl0IGdvZXMgdG8gd2hlcmUgaXQgY2FtZSBmcm9tLCByYXRoZXJcbiAgICAvLyB0aGFuIHRoZSB1c2VyJ3MgZGVzaXJlZCBsb2NhdGlvbi5cbiAgICBsb2coYENvbGxpc2lvbiBwcmV2ZW50ZWQgb24gJHtsLml9LCByZXZlcnRpbmcuYCk7XG4gICAgbC54ID0gb2xkWDtcbiAgICBsLnkgPSBvbGRZO1xuICAgIGwubW92ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gbGF5b3V0OyAvLyBkaWQgbm90IGNoYW5nZSBzbyBkb24ndCBjbG9uZVxuICB9XG5cbiAgLy8gTW92ZSBlYWNoIGl0ZW0gdGhhdCBjb2xsaWRlcyBhd2F5IGZyb20gdGhpcyBlbGVtZW50LlxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gY29sbGlzaW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGNvbGxpc2lvbiA9IGNvbGxpc2lvbnNbaV07XG4gICAgbG9nKGBSZXNvbHZpbmcgY29sbGlzaW9uIGJldHdlZW4gJHtsLml9IGF0IFske2wueH0sJHtsLnl9XSBhbmQgJHtjb2xsaXNpb24uaX0gYXQgWyR7Y29sbGlzaW9uLnh9LCR7Y29sbGlzaW9uLnl9XWApO1xuXG4gICAgLy8gU2hvcnQgY2lyY3VpdCBzbyB3ZSBjYW4ndCBpbmZpbml0ZSBsb29wXG4gICAgaWYgKGNvbGxpc2lvbi5tb3ZlZCkgY29udGludWU7XG5cbiAgICAvLyBEb24ndCBtb3ZlIHN0YXRpYyBpdGVtcyAtIHdlIGhhdmUgdG8gbW92ZSAqdGhpcyogZWxlbWVudCBhd2F5XG4gICAgaWYgKGNvbGxpc2lvbi5zdGF0aWMpIHtcbiAgICAgIGxheW91dCA9IG1vdmVFbGVtZW50QXdheUZyb21Db2xsaXNpb24obGF5b3V0LCBjb2xsaXNpb24sIGwsIGlzVXNlckFjdGlvbiwgY29tcGFjdFR5cGUsIGNvbHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXlvdXQgPSBtb3ZlRWxlbWVudEF3YXlGcm9tQ29sbGlzaW9uKGxheW91dCwgbCwgY29sbGlzaW9uLCBpc1VzZXJBY3Rpb24sIGNvbXBhY3RUeXBlLCBjb2xzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxheW91dDtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIHdoZXJlIHRoZSBtYWdpYyBuZWVkcyB0byBoYXBwZW4gLSBnaXZlbiBhIGNvbGxpc2lvbiwgbW92ZSBhbiBlbGVtZW50IGF3YXkgZnJvbSB0aGUgY29sbGlzaW9uLlxuICogV2UgYXR0ZW1wdCB0byBtb3ZlIGl0IHVwIGlmIHRoZXJlJ3Mgcm9vbSwgb3RoZXJ3aXNlIGl0IGdvZXMgYmVsb3cuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGxheW91dCAgICAgICAgICAgIEZ1bGwgbGF5b3V0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSAge0xheW91dEl0ZW19IGNvbGxpZGVzV2l0aCBMYXlvdXQgaXRlbSB3ZSdyZSBjb2xsaWRpbmcgd2l0aC5cbiAqIEBwYXJhbSAge0xheW91dEl0ZW19IGl0ZW1Ub01vdmUgICBMYXlvdXQgaXRlbSB3ZSdyZSBtb3ZpbmcuXG4gKi9cbmZ1bmN0aW9uIG1vdmVFbGVtZW50QXdheUZyb21Db2xsaXNpb24obGF5b3V0IC8qOiBMYXlvdXQqLywgY29sbGlkZXNXaXRoIC8qOiBMYXlvdXRJdGVtKi8sIGl0ZW1Ub01vdmUgLyo6IExheW91dEl0ZW0qLywgaXNVc2VyQWN0aW9uIC8qOiA/Ym9vbGVhbiovLCBjb21wYWN0VHlwZSAvKjogQ29tcGFjdFR5cGUqLywgY29scyAvKjogbnVtYmVyKi8pIC8qOiBMYXlvdXQqL3tcbiAgY29uc3QgY29tcGFjdEggPSBjb21wYWN0VHlwZSA9PT0gXCJob3Jpem9udGFsXCI7XG4gIC8vIENvbXBhY3QgdmVydGljYWxseSBpZiBub3Qgc2V0IHRvIGhvcml6b250YWxcbiAgY29uc3QgY29tcGFjdFYgPSBjb21wYWN0VHlwZSA9PT0gXCJ2ZXJ0aWNhbFwiO1xuICBjb25zdCBwcmV2ZW50Q29sbGlzaW9uID0gY29sbGlkZXNXaXRoLnN0YXRpYzsgLy8gd2UncmUgYWxyZWFkeSBjb2xsaWRpbmcgKG5vdCBmb3Igc3RhdGljIGl0ZW1zKVxuXG4gIC8vIElmIHRoZXJlIGlzIGVub3VnaCBzcGFjZSBhYm92ZSB0aGUgY29sbGlzaW9uIHRvIHB1dCB0aGlzIGVsZW1lbnQsIG1vdmUgaXQgdGhlcmUuXG4gIC8vIFdlIG9ubHkgZG8gdGhpcyBvbiB0aGUgbWFpbiBjb2xsaXNpb24gYXMgdGhpcyBjYW4gZ2V0IGZ1bmt5IGluIGNhc2NhZGVzIGFuZCBjYXVzZVxuICAvLyB1bndhbnRlZCBzd2FwcGluZyBiZWhhdmlvci5cbiAgaWYgKGlzVXNlckFjdGlvbikge1xuICAgIC8vIFJlc2V0IGlzVXNlckFjdGlvbiBmbGFnIGJlY2F1c2Ugd2UncmUgbm90IGluIHRoZSBtYWluIGNvbGxpc2lvbiBhbnltb3JlLlxuICAgIGlzVXNlckFjdGlvbiA9IGZhbHNlO1xuXG4gICAgLy8gTWFrZSBhIG1vY2sgaXRlbSBzbyB3ZSBkb24ndCBtb2RpZnkgdGhlIGl0ZW0gaGVyZSwgb25seSBtb2RpZnkgaW4gbW92ZUVsZW1lbnQuXG4gICAgY29uc3QgZmFrZUl0ZW0gLyo6IExheW91dEl0ZW0qLyA9IHtcbiAgICAgIHg6IGNvbXBhY3RIID8gTWF0aC5tYXgoY29sbGlkZXNXaXRoLnggLSBpdGVtVG9Nb3ZlLncsIDApIDogaXRlbVRvTW92ZS54LFxuICAgICAgeTogY29tcGFjdFYgPyBNYXRoLm1heChjb2xsaWRlc1dpdGgueSAtIGl0ZW1Ub01vdmUuaCwgMCkgOiBpdGVtVG9Nb3ZlLnksXG4gICAgICB3OiBpdGVtVG9Nb3ZlLncsXG4gICAgICBoOiBpdGVtVG9Nb3ZlLmgsXG4gICAgICBpOiBcIi0xXCJcbiAgICB9O1xuICAgIGNvbnN0IGZpcnN0Q29sbGlzaW9uID0gZ2V0Rmlyc3RDb2xsaXNpb24obGF5b3V0LCBmYWtlSXRlbSk7XG4gICAgY29uc3QgY29sbGlzaW9uTm9ydGggPSBmaXJzdENvbGxpc2lvbiAmJiBmaXJzdENvbGxpc2lvbi55ICsgZmlyc3RDb2xsaXNpb24uaCA+IGNvbGxpZGVzV2l0aC55O1xuICAgIGNvbnN0IGNvbGxpc2lvbldlc3QgPSBmaXJzdENvbGxpc2lvbiAmJiBjb2xsaWRlc1dpdGgueCArIGNvbGxpZGVzV2l0aC53ID4gZmlyc3RDb2xsaXNpb24ueDtcblxuICAgIC8vIE5vIGNvbGxpc2lvbj8gSWYgc28sIHdlIGNhbiBnbyB1cCB0aGVyZTsgb3RoZXJ3aXNlLCB3ZSdsbCBlbmQgdXAgbW92aW5nIGRvd24gYXMgbm9ybWFsXG4gICAgaWYgKCFmaXJzdENvbGxpc2lvbikge1xuICAgICAgbG9nKGBEb2luZyByZXZlcnNlIGNvbGxpc2lvbiBvbiAke2l0ZW1Ub01vdmUuaX0gdXAgdG8gWyR7ZmFrZUl0ZW0ueH0sJHtmYWtlSXRlbS55fV0uYCk7XG4gICAgICByZXR1cm4gbW92ZUVsZW1lbnQobGF5b3V0LCBpdGVtVG9Nb3ZlLCBjb21wYWN0SCA/IGZha2VJdGVtLnggOiB1bmRlZmluZWQsIGNvbXBhY3RWID8gZmFrZUl0ZW0ueSA6IHVuZGVmaW5lZCwgaXNVc2VyQWN0aW9uLCBwcmV2ZW50Q29sbGlzaW9uLCBjb21wYWN0VHlwZSwgY29scyk7XG4gICAgfSBlbHNlIGlmIChjb2xsaXNpb25Ob3J0aCAmJiBjb21wYWN0Vikge1xuICAgICAgcmV0dXJuIG1vdmVFbGVtZW50KGxheW91dCwgaXRlbVRvTW92ZSwgdW5kZWZpbmVkLCBjb2xsaWRlc1dpdGgueSArIDEsIGlzVXNlckFjdGlvbiwgcHJldmVudENvbGxpc2lvbiwgY29tcGFjdFR5cGUsIGNvbHMpO1xuICAgIH0gZWxzZSBpZiAoY29sbGlzaW9uTm9ydGggJiYgY29tcGFjdFR5cGUgPT0gbnVsbCkge1xuICAgICAgY29sbGlkZXNXaXRoLnkgPSBpdGVtVG9Nb3ZlLnk7XG4gICAgICBpdGVtVG9Nb3ZlLnkgPSBpdGVtVG9Nb3ZlLnkgKyBpdGVtVG9Nb3ZlLmg7XG4gICAgICByZXR1cm4gbGF5b3V0O1xuICAgIH0gZWxzZSBpZiAoY29sbGlzaW9uV2VzdCAmJiBjb21wYWN0SCkge1xuICAgICAgcmV0dXJuIG1vdmVFbGVtZW50KGxheW91dCwgY29sbGlkZXNXaXRoLCBpdGVtVG9Nb3ZlLngsIHVuZGVmaW5lZCwgaXNVc2VyQWN0aW9uLCBwcmV2ZW50Q29sbGlzaW9uLCBjb21wYWN0VHlwZSwgY29scyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG5ld1ggPSBjb21wYWN0SCA/IGl0ZW1Ub01vdmUueCArIDEgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IG5ld1kgPSBjb21wYWN0ViA/IGl0ZW1Ub01vdmUueSArIDEgOiB1bmRlZmluZWQ7XG4gIGlmIChuZXdYID09IG51bGwgJiYgbmV3WSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGxheW91dDtcbiAgfVxuICByZXR1cm4gbW92ZUVsZW1lbnQobGF5b3V0LCBpdGVtVG9Nb3ZlLCBjb21wYWN0SCA/IGl0ZW1Ub01vdmUueCArIDEgOiB1bmRlZmluZWQsIGNvbXBhY3RWID8gaXRlbVRvTW92ZS55ICsgMSA6IHVuZGVmaW5lZCwgaXNVc2VyQWN0aW9uLCBwcmV2ZW50Q29sbGlzaW9uLCBjb21wYWN0VHlwZSwgY29scyk7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGNvbnZlcnQgYSBudW1iZXIgdG8gYSBwZXJjZW50YWdlIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG51bSBBbnkgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICBUaGF0IG51bWJlciBhcyBhIHBlcmNlbnRhZ2UuXG4gKi9cbmZ1bmN0aW9uIHBlcmMobnVtIC8qOiBudW1iZXIqLykgLyo6IHN0cmluZyove1xuICByZXR1cm4gbnVtICogMTAwICsgXCIlXCI7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9ucyB0byBjb25zdHJhaW4gZGltZW5zaW9ucyBvZiBhIEdyaWRJdGVtXG4gKi9cbmNvbnN0IGNvbnN0cmFpbldpZHRoID0gKGxlZnQgLyo6IG51bWJlciovLCBjdXJyZW50V2lkdGggLyo6IG51bWJlciovLCBuZXdXaWR0aCAvKjogbnVtYmVyKi8sIGNvbnRhaW5lcldpZHRoIC8qOiBudW1iZXIqLykgPT4ge1xuICByZXR1cm4gbGVmdCArIG5ld1dpZHRoID4gY29udGFpbmVyV2lkdGggPyBjdXJyZW50V2lkdGggOiBuZXdXaWR0aDtcbn07XG5jb25zdCBjb25zdHJhaW5IZWlnaHQgPSAodG9wIC8qOiBudW1iZXIqLywgY3VycmVudEhlaWdodCAvKjogbnVtYmVyKi8sIG5ld0hlaWdodCAvKjogbnVtYmVyKi8pID0+IHtcbiAgcmV0dXJuIHRvcCA8IDAgPyBjdXJyZW50SGVpZ2h0IDogbmV3SGVpZ2h0O1xufTtcbmNvbnN0IGNvbnN0cmFpbkxlZnQgPSAobGVmdCAvKjogbnVtYmVyKi8pID0+IE1hdGgubWF4KDAsIGxlZnQpO1xuY29uc3QgY29uc3RyYWluVG9wID0gKHRvcCAvKjogbnVtYmVyKi8pID0+IE1hdGgubWF4KDAsIHRvcCk7XG5jb25zdCByZXNpemVOb3J0aCA9IChjdXJyZW50U2l6ZSwgX3JlZiwgX2NvbnRhaW5lcldpZHRoKSA9PiB7XG4gIGxldCB7XG4gICAgbGVmdCxcbiAgICBoZWlnaHQsXG4gICAgd2lkdGhcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHRvcCA9IGN1cnJlbnRTaXplLnRvcCAtIChoZWlnaHQgLSBjdXJyZW50U2l6ZS5oZWlnaHQpO1xuICByZXR1cm4ge1xuICAgIGxlZnQsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0OiBjb25zdHJhaW5IZWlnaHQodG9wLCBjdXJyZW50U2l6ZS5oZWlnaHQsIGhlaWdodCksXG4gICAgdG9wOiBjb25zdHJhaW5Ub3AodG9wKVxuICB9O1xufTtcbmNvbnN0IHJlc2l6ZUVhc3QgPSAoY3VycmVudFNpemUsIF9yZWYyLCBjb250YWluZXJXaWR0aCkgPT4ge1xuICBsZXQge1xuICAgIHRvcCxcbiAgICBsZWZ0LFxuICAgIGhlaWdodCxcbiAgICB3aWR0aFxuICB9ID0gX3JlZjI7XG4gIHJldHVybiB7XG4gICAgdG9wLFxuICAgIGhlaWdodCxcbiAgICB3aWR0aDogY29uc3RyYWluV2lkdGgoY3VycmVudFNpemUubGVmdCwgY3VycmVudFNpemUud2lkdGgsIHdpZHRoLCBjb250YWluZXJXaWR0aCksXG4gICAgbGVmdDogY29uc3RyYWluTGVmdChsZWZ0KVxuICB9O1xufTtcbmNvbnN0IHJlc2l6ZVdlc3QgPSAoY3VycmVudFNpemUsIF9yZWYzLCBjb250YWluZXJXaWR0aCkgPT4ge1xuICBsZXQge1xuICAgIHRvcCxcbiAgICBoZWlnaHQsXG4gICAgd2lkdGhcbiAgfSA9IF9yZWYzO1xuICBjb25zdCBsZWZ0ID0gY3VycmVudFNpemUubGVmdCAtICh3aWR0aCAtIGN1cnJlbnRTaXplLndpZHRoKTtcbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQsXG4gICAgd2lkdGg6IGxlZnQgPCAwID8gY3VycmVudFNpemUud2lkdGggOiBjb25zdHJhaW5XaWR0aChjdXJyZW50U2l6ZS5sZWZ0LCBjdXJyZW50U2l6ZS53aWR0aCwgd2lkdGgsIGNvbnRhaW5lcldpZHRoKSxcbiAgICB0b3A6IGNvbnN0cmFpblRvcCh0b3ApLFxuICAgIGxlZnQ6IGNvbnN0cmFpbkxlZnQobGVmdClcbiAgfTtcbn07XG5jb25zdCByZXNpemVTb3V0aCA9IChjdXJyZW50U2l6ZSwgX3JlZjQsIGNvbnRhaW5lcldpZHRoKSA9PiB7XG4gIGxldCB7XG4gICAgdG9wLFxuICAgIGxlZnQsXG4gICAgaGVpZ2h0LFxuICAgIHdpZHRoXG4gIH0gPSBfcmVmNDtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBsZWZ0LFxuICAgIGhlaWdodDogY29uc3RyYWluSGVpZ2h0KHRvcCwgY3VycmVudFNpemUuaGVpZ2h0LCBoZWlnaHQpLFxuICAgIHRvcDogY29uc3RyYWluVG9wKHRvcClcbiAgfTtcbn07XG5jb25zdCByZXNpemVOb3J0aEVhc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiByZXNpemVOb3J0aChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0sIHJlc2l6ZUVhc3QoLi4uYXJndW1lbnRzKSwgYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKTtcbn07XG5jb25zdCByZXNpemVOb3J0aFdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiByZXNpemVOb3J0aChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0sIHJlc2l6ZVdlc3QoLi4uYXJndW1lbnRzKSwgYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKTtcbn07XG5jb25zdCByZXNpemVTb3V0aEVhc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiByZXNpemVTb3V0aChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0sIHJlc2l6ZUVhc3QoLi4uYXJndW1lbnRzKSwgYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKTtcbn07XG5jb25zdCByZXNpemVTb3V0aFdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiByZXNpemVTb3V0aChhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF0sIHJlc2l6ZVdlc3QoLi4uYXJndW1lbnRzKSwgYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKTtcbn07XG5jb25zdCBvcmRpbmFsUmVzaXplSGFuZGxlck1hcCA9IHtcbiAgbjogcmVzaXplTm9ydGgsXG4gIG5lOiByZXNpemVOb3J0aEVhc3QsXG4gIGU6IHJlc2l6ZUVhc3QsXG4gIHNlOiByZXNpemVTb3V0aEVhc3QsXG4gIHM6IHJlc2l6ZVNvdXRoLFxuICBzdzogcmVzaXplU291dGhXZXN0LFxuICB3OiByZXNpemVXZXN0LFxuICBudzogcmVzaXplTm9ydGhXZXN0XG59O1xuXG4vKipcbiAqIEhlbHBlciBmb3IgY2xhbXBpbmcgd2lkdGggYW5kIHBvc2l0aW9uIHdoZW4gcmVzaXppbmcgYW4gaXRlbS5cbiAqL1xuZnVuY3Rpb24gcmVzaXplSXRlbUluRGlyZWN0aW9uKGRpcmVjdGlvbiAvKjogUmVzaXplSGFuZGxlQXhpcyovLCBjdXJyZW50U2l6ZSAvKjogUG9zaXRpb24qLywgbmV3U2l6ZSAvKjogUG9zaXRpb24qLywgY29udGFpbmVyV2lkdGggLyo6IG51bWJlciovKSAvKjogUG9zaXRpb24qL3tcbiAgY29uc3Qgb3JkaW5hbEhhbmRsZXIgPSBvcmRpbmFsUmVzaXplSGFuZGxlck1hcFtkaXJlY3Rpb25dO1xuICAvLyBTaG91bGRuJ3QgYmUgcG9zc2libGUgZ2l2ZW4gdHlwZXM7IHRoYXQgc2FpZCwgZG9uJ3QgZmFpbCBoYXJkXG4gIGlmICghb3JkaW5hbEhhbmRsZXIpIHJldHVybiBuZXdTaXplO1xuICByZXR1cm4gb3JkaW5hbEhhbmRsZXIoY3VycmVudFNpemUsIHtcbiAgICAuLi5jdXJyZW50U2l6ZSxcbiAgICAuLi5uZXdTaXplXG4gIH0sIGNvbnRhaW5lcldpZHRoKTtcbn1cbmZ1bmN0aW9uIHNldFRyYW5zZm9ybShfcmVmNSAvKjo6ICovKSAvKjogT2JqZWN0Ki97XG4gIGxldCB7XG4gICAgdG9wLFxuICAgIGxlZnQsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gLyo6IFBvc2l0aW9uKi8gPSBfcmVmNSAvKjogUG9zaXRpb24qLztcbiAgLy8gUmVwbGFjZSB1bml0bGVzcyBpdGVtcyB3aXRoIHB4XG4gIGNvbnN0IHRyYW5zbGF0ZSA9IGB0cmFuc2xhdGUoJHtsZWZ0fXB4LCR7dG9wfXB4KWA7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUsXG4gICAgV2Via2l0VHJhbnNmb3JtOiB0cmFuc2xhdGUsXG4gICAgTW96VHJhbnNmb3JtOiB0cmFuc2xhdGUsXG4gICAgbXNUcmFuc2Zvcm06IHRyYW5zbGF0ZSxcbiAgICBPVHJhbnNmb3JtOiB0cmFuc2xhdGUsXG4gICAgd2lkdGg6IGAke3dpZHRofXB4YCxcbiAgICBoZWlnaHQ6IGAke2hlaWdodH1weGAsXG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICB9O1xufVxuZnVuY3Rpb24gc2V0VG9wTGVmdChfcmVmNiAvKjo6ICovKSAvKjogT2JqZWN0Ki97XG4gIGxldCB7XG4gICAgdG9wLFxuICAgIGxlZnQsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gLyo6IFBvc2l0aW9uKi8gPSBfcmVmNiAvKjogUG9zaXRpb24qLztcbiAgcmV0dXJuIHtcbiAgICB0b3A6IGAke3RvcH1weGAsXG4gICAgbGVmdDogYCR7bGVmdH1weGAsXG4gICAgd2lkdGg6IGAke3dpZHRofXB4YCxcbiAgICBoZWlnaHQ6IGAke2hlaWdodH1weGAsXG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICB9O1xufVxuXG4vKipcbiAqIEdldCBsYXlvdXQgaXRlbXMgc29ydGVkIGZyb20gdG9wIGxlZnQgdG8gcmlnaHQgYW5kIGRvd24uXG4gKlxuICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIGxheW91dCBvYmplY3RzLlxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICBMYXlvdXQsIHNvcnRlZCBzdGF0aWMgaXRlbXMgZmlyc3QuXG4gKi9cbmZ1bmN0aW9uIHNvcnRMYXlvdXRJdGVtcyhsYXlvdXQgLyo6IExheW91dCovLCBjb21wYWN0VHlwZSAvKjogQ29tcGFjdFR5cGUqLykgLyo6IExheW91dCove1xuICBpZiAoY29tcGFjdFR5cGUgPT09IFwiaG9yaXpvbnRhbFwiKSByZXR1cm4gc29ydExheW91dEl0ZW1zQnlDb2xSb3cobGF5b3V0KTtcbiAgaWYgKGNvbXBhY3RUeXBlID09PSBcInZlcnRpY2FsXCIpIHJldHVybiBzb3J0TGF5b3V0SXRlbXNCeVJvd0NvbChsYXlvdXQpO2Vsc2UgcmV0dXJuIGxheW91dDtcbn1cblxuLyoqXG4gKiBTb3J0IGxheW91dCBpdGVtcyBieSByb3cgYXNjZW5kaW5nIGFuZCBjb2x1bW4gYXNjZW5kaW5nLlxuICpcbiAqIERvZXMgbm90IG1vZGlmeSBMYXlvdXQuXG4gKi9cbmZ1bmN0aW9uIHNvcnRMYXlvdXRJdGVtc0J5Um93Q29sKGxheW91dCAvKjogTGF5b3V0Ki8pIC8qOiBMYXlvdXQqL3tcbiAgLy8gU2xpY2UgdG8gY2xvbmUgYXJyYXkgYXMgc29ydCBtb2RpZmllc1xuICByZXR1cm4gbGF5b3V0LnNsaWNlKDApLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYS55ID4gYi55IHx8IGEueSA9PT0gYi55ICYmIGEueCA+IGIueCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChhLnkgPT09IGIueSAmJiBhLnggPT09IGIueCkge1xuICAgICAgLy8gV2l0aG91dCB0aGlzLCB3ZSBjYW4gZ2V0IGRpZmZlcmVudCBzb3J0IHJlc3VsdHMgaW4gSUUgdnMuIENocm9tZS9GRlxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfSk7XG59XG5cbi8qKlxuICogU29ydCBsYXlvdXQgaXRlbXMgYnkgY29sdW1uIGFzY2VuZGluZyB0aGVuIHJvdyBhc2NlbmRpbmcuXG4gKlxuICogRG9lcyBub3QgbW9kaWZ5IExheW91dC5cbiAqL1xuZnVuY3Rpb24gc29ydExheW91dEl0ZW1zQnlDb2xSb3cobGF5b3V0IC8qOiBMYXlvdXQqLykgLyo6IExheW91dCove1xuICByZXR1cm4gbGF5b3V0LnNsaWNlKDApLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYS54ID4gYi54IHx8IGEueCA9PT0gYi54ICYmIGEueSA+IGIueSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBsYXlvdXQgdXNpbmcgdGhlIGluaXRpYWxMYXlvdXQgYW5kIGNoaWxkcmVuIGFzIGEgdGVtcGxhdGUuXG4gKiBNaXNzaW5nIGVudHJpZXMgd2lsbCBiZSBhZGRlZCwgZXh0cmFuZW91cyBvbmVzIHdpbGwgYmUgdHJ1bmNhdGVkLlxuICpcbiAqIERvZXMgbm90IG1vZGlmeSBpbml0aWFsTGF5b3V0LlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSAgaW5pdGlhbExheW91dCBMYXlvdXQgcGFzc2VkIGluIHRocm91Z2ggcHJvcHMuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGJyZWFrcG9pbnQgICAgQ3VycmVudCByZXNwb25zaXZlIGJyZWFrcG9pbnQuXG4gKiBAcGFyYW0gIHs/U3RyaW5nfSBjb21wYWN0ICAgICAgQ29tcGFjdGlvbiBvcHRpb24uXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgICAgV29ya2luZyBsYXlvdXQuXG4gKi9cbmZ1bmN0aW9uIHN5bmNocm9uaXplTGF5b3V0V2l0aENoaWxkcmVuKGluaXRpYWxMYXlvdXQgLyo6IExheW91dCovLCBjaGlsZHJlbiAvKjogUmVhY3RDaGlsZHJlbiovLCBjb2xzIC8qOiBudW1iZXIqLywgY29tcGFjdFR5cGUgLyo6IENvbXBhY3RUeXBlKi8sIGFsbG93T3ZlcmxhcCAvKjogP2Jvb2xlYW4qLykgLyo6IExheW91dCove1xuICBpbml0aWFsTGF5b3V0ID0gaW5pdGlhbExheW91dCB8fCBbXTtcblxuICAvLyBHZW5lcmF0ZSBvbmUgbGF5b3V0IGl0ZW0gcGVyIGNoaWxkLlxuICBjb25zdCBsYXlvdXQgLyo6IExheW91dEl0ZW1bXSovID0gW107XG4gIF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChjaGlsZCAvKjogUmVhY3RFbGVtZW50PGFueT4qLykgPT4ge1xuICAgIC8vIENoaWxkIG1heSBub3QgZXhpc3RcbiAgICBpZiAoY2hpbGQ/LmtleSA9PSBudWxsKSByZXR1cm47XG4gICAgY29uc3QgZXhpc3RzID0gZ2V0TGF5b3V0SXRlbShpbml0aWFsTGF5b3V0LCBTdHJpbmcoY2hpbGQua2V5KSk7XG4gICAgY29uc3QgZyA9IGNoaWxkLnByb3BzW1wiZGF0YS1ncmlkXCJdO1xuICAgIC8vIERvbid0IG92ZXJ3cml0ZSB0aGUgbGF5b3V0IGl0ZW0gaWYgaXQncyBhbHJlYWR5IGluIHRoZSBpbml0aWFsIGxheW91dC5cbiAgICAvLyBJZiBpdCBoYXMgYSBgZGF0YS1ncmlkYCBwcm9wZXJ0eSwgcHJlZmVyIHRoYXQgb3ZlciB3aGF0J3MgaW4gdGhlIGxheW91dC5cbiAgICBpZiAoZXhpc3RzICYmIGcgPT0gbnVsbCkge1xuICAgICAgbGF5b3V0LnB1c2goY2xvbmVMYXlvdXRJdGVtKGV4aXN0cykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBIZXksIHRoaXMgaXRlbSBoYXMgYSBkYXRhLWdyaWQgcHJvcGVydHksIHVzZSBpdC5cbiAgICAgIGlmIChnKSB7XG4gICAgICAgIGlmICghaXNQcm9kdWN0aW9uKSB7XG4gICAgICAgICAgdmFsaWRhdGVMYXlvdXQoW2ddLCBcIlJlYWN0R3JpZExheW91dC5jaGlsZHJlblwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGSVhNRSBjbG9uZSBub3QgcmVhbGx5IG5lY2Vzc2FyeSBoZXJlXG4gICAgICAgIGxheW91dC5wdXNoKGNsb25lTGF5b3V0SXRlbSh7XG4gICAgICAgICAgLi4uZyxcbiAgICAgICAgICBpOiBjaGlsZC5rZXlcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm90aGluZyBwcm92aWRlZDogZW5zdXJlIHRoaXMgaXMgYWRkZWQgdG8gdGhlIGJvdHRvbVxuICAgICAgICAvLyBGSVhNRSBjbG9uZSBub3QgcmVhbGx5IG5lY2Vzc2FyeSBoZXJlXG4gICAgICAgIGxheW91dC5wdXNoKGNsb25lTGF5b3V0SXRlbSh7XG4gICAgICAgICAgdzogMSxcbiAgICAgICAgICBoOiAxLFxuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogYm90dG9tKGxheW91dCksXG4gICAgICAgICAgaTogU3RyaW5nKGNoaWxkLmtleSlcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gQ29ycmVjdCB0aGUgbGF5b3V0LlxuICBjb25zdCBjb3JyZWN0ZWRMYXlvdXQgPSBjb3JyZWN0Qm91bmRzKGxheW91dCwge1xuICAgIGNvbHM6IGNvbHNcbiAgfSk7XG4gIHJldHVybiBhbGxvd092ZXJsYXAgPyBjb3JyZWN0ZWRMYXlvdXQgOiBjb21wYWN0KGNvcnJlY3RlZExheW91dCwgY29tcGFjdFR5cGUsIGNvbHMpO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIGEgbGF5b3V0LiBUaHJvd3MgZXJyb3JzLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSAgbGF5b3V0ICAgICAgICBBcnJheSBvZiBsYXlvdXQgaXRlbXMuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IFtjb250ZXh0TmFtZV0gQ29udGV4dCBuYW1lIGZvciBlcnJvcnMuXG4gKiBAdGhyb3cgIHtFcnJvcn0gICAgICAgICAgICAgICAgVmFsaWRhdGlvbiBlcnJvci5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVMYXlvdXQobGF5b3V0IC8qOiBMYXlvdXQqLykgLyo6IHZvaWQqL3tcbiAgbGV0IGNvbnRleHROYW1lIC8qOiBzdHJpbmcqLyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJMYXlvdXRcIjtcbiAgY29uc3Qgc3ViUHJvcHMgPSBbXCJ4XCIsIFwieVwiLCBcIndcIiwgXCJoXCJdO1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGF5b3V0KSkgdGhyb3cgbmV3IEVycm9yKGNvbnRleHROYW1lICsgXCIgbXVzdCBiZSBhbiBhcnJheSFcIik7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsYXlvdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBpdGVtID0gbGF5b3V0W2ldO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3ViUHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IHN1YlByb3BzW2pdO1xuICAgICAgY29uc3QgdmFsdWUgPSBpdGVtW2tleV07XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiIHx8IE51bWJlci5pc05hTih2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWFjdEdyaWRMYXlvdXQ6ICR7Y29udGV4dE5hbWV9WyR7aX1dLiR7a2V5fSBtdXN0IGJlIGEgbnVtYmVyISBSZWNlaXZlZDogJHt2YWx1ZX0gKCR7dHlwZW9mIHZhbHVlfSlgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpdGVtLmkgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGl0ZW0uaSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWFjdEdyaWRMYXlvdXQ6ICR7Y29udGV4dE5hbWV9WyR7aX1dLmkgbXVzdCBiZSBhIHN0cmluZyEgUmVjZWl2ZWQ6ICR7aXRlbS5pfSAoJHt0eXBlb2YgaXRlbS5pfSlgKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gTGVnYWN5IHN1cHBvcnQgZm9yIHZlcnRpY2FsQ29tcGFjdDogZmFsc2VcbmZ1bmN0aW9uIGNvbXBhY3RUeXBlKHByb3BzIC8qOiA/eyB2ZXJ0aWNhbENvbXBhY3Q6IGJvb2xlYW4sIGNvbXBhY3RUeXBlOiBDb21wYWN0VHlwZSB9Ki8pIC8qOiBDb21wYWN0VHlwZSove1xuICBjb25zdCB7XG4gICAgdmVydGljYWxDb21wYWN0LFxuICAgIGNvbXBhY3RUeXBlXG4gIH0gPSBwcm9wcyB8fCB7fTtcbiAgcmV0dXJuIHZlcnRpY2FsQ29tcGFjdCA9PT0gZmFsc2UgPyBudWxsIDogY29tcGFjdFR5cGU7XG59XG5mdW5jdGlvbiBsb2coKSB7XG4gIGlmICghREVCVUcpIHJldHVybjtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgY29uc29sZS5sb2coLi4uYXJndW1lbnRzKTtcbn1cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcbmV4cG9ydHMubm9vcCA9IG5vb3A7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/build/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-grid-layout/index.js":
/*!*************************************************!*\
  !*** ./node_modules/react-grid-layout/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./build/ReactGridLayout */ \"(ssr)/./node_modules/react-grid-layout/build/ReactGridLayout.js\")[\"default\"];\nmodule.exports.utils = __webpack_require__(/*! ./build/utils */ \"(ssr)/./node_modules/react-grid-layout/build/utils.js\");\nmodule.exports.calculateUtils = __webpack_require__(/*! ./build/calculateUtils */ \"(ssr)/./node_modules/react-grid-layout/build/calculateUtils.js\");\nmodule.exports.Responsive = __webpack_require__(/*! ./build/ResponsiveReactGridLayout */ \"(ssr)/./node_modules/react-grid-layout/build/ResponsiveReactGridLayout.js\")[\"default\"];\nmodule.exports.Responsive.utils = __webpack_require__(/*! ./build/responsiveUtils */ \"(ssr)/./node_modules/react-grid-layout/build/responsiveUtils.js\");\nmodule.exports.WidthProvider = __webpack_require__(/*! ./build/components/WidthProvider */ \"(ssr)/./node_modules/react-grid-layout/build/components/WidthProvider.js\")[\"default\"];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZ3JpZC1sYXlvdXQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsaUpBQTJEO0FBQzNELHdIQUErQztBQUMvQyxtSkFBaUU7QUFDakUsZ0xBQ3NEO0FBQ3RELHVKQUFvRTtBQUNwRSxpTEFDcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96MTB0cmlhZ2UtZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWdyaWQtbGF5b3V0L2luZGV4LmpzPzZjZDkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9idWlsZC9SZWFjdEdyaWRMYXlvdXRcIikuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLnV0aWxzID0gcmVxdWlyZShcIi4vYnVpbGQvdXRpbHNcIik7XG5tb2R1bGUuZXhwb3J0cy5jYWxjdWxhdGVVdGlscyA9IHJlcXVpcmUoXCIuL2J1aWxkL2NhbGN1bGF0ZVV0aWxzXCIpO1xubW9kdWxlLmV4cG9ydHMuUmVzcG9uc2l2ZSA9XG4gIHJlcXVpcmUoXCIuL2J1aWxkL1Jlc3BvbnNpdmVSZWFjdEdyaWRMYXlvdXRcIikuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLlJlc3BvbnNpdmUudXRpbHMgPSByZXF1aXJlKFwiLi9idWlsZC9yZXNwb25zaXZlVXRpbHNcIik7XG5tb2R1bGUuZXhwb3J0cy5XaWR0aFByb3ZpZGVyID1cbiAgcmVxdWlyZShcIi4vYnVpbGQvY29tcG9uZW50cy9XaWR0aFByb3ZpZGVyXCIpLmRlZmF1bHQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-grid-layout/index.js\n");

/***/ })

};
;