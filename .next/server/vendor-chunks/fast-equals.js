"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fast-equals";
exports.ids = ["vendor-chunks/fast-equals"];
exports.modules = {

/***/ "(ssr)/./node_modules/fast-equals/dist/fast-equals.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-equals/dist/fast-equals.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   circularDeepEqual: () => (/* binding */ circularDeepEqual),\n/* harmony export */   circularShallowEqual: () => (/* binding */ circularShallowEqual),\n/* harmony export */   createCustomCircularEqual: () => (/* binding */ createCustomCircularEqual),\n/* harmony export */   createCustomEqual: () => (/* binding */ createCustomEqual),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   sameValueZeroEqual: () => (/* binding */ sameValueZeroEqual),\n/* harmony export */   shallowEqual: () => (/* binding */ shallowEqual)\n/* harmony export */ });\n/**\r\n * Default equality comparator pass-through, used as the standard `isEqual` creator for\r\n * use inside the built comparator.\r\n */\r\nfunction createDefaultIsNestedEqual(comparator) {\r\n    return function isEqual(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, meta) {\r\n        return comparator(a, b, meta);\r\n    };\r\n}\r\n/**\r\n * Wrap the provided `areItemsEqual` method to manage the circular cache, allowing\r\n * for circular references to be safely included in the comparison without creating\r\n * stack overflows.\r\n */\r\nfunction createIsCircular(areItemsEqual) {\r\n    return function isCircular(a, b, isEqual, cache) {\r\n        if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\r\n            return areItemsEqual(a, b, isEqual, cache);\r\n        }\r\n        var cachedA = cache.get(a);\r\n        var cachedB = cache.get(b);\r\n        if (cachedA && cachedB) {\r\n            return cachedA === b && cachedB === a;\r\n        }\r\n        cache.set(a, b);\r\n        cache.set(b, a);\r\n        var result = areItemsEqual(a, b, isEqual, cache);\r\n        cache.delete(a);\r\n        cache.delete(b);\r\n        return result;\r\n    };\r\n}\r\n/**\r\n * Targeted shallow merge of two objects.\r\n *\r\n * @NOTE\r\n * This exists as a tinier compiled version of the `__assign` helper that\r\n * `tsc` injects in case of `Object.assign` not being present.\r\n */\r\nfunction merge(a, b) {\r\n    var merged = {};\r\n    for (var key in a) {\r\n        merged[key] = a[key];\r\n    }\r\n    for (var key in b) {\r\n        merged[key] = b[key];\r\n    }\r\n    return merged;\r\n}\r\n/**\r\n * Whether the value is a plain object.\r\n *\r\n * @NOTE\r\n * This is a same-realm compariosn only.\r\n */\r\nfunction isPlainObject(value) {\r\n    return value.constructor === Object || value.constructor == null;\r\n}\r\n/**\r\n * When the value is `Promise`-like, aka \"then-able\".\r\n */\r\nfunction isPromiseLike(value) {\r\n    return typeof value.then === 'function';\r\n}\r\n/**\r\n * Whether the values passed are strictly equal or both NaN.\r\n */\r\nfunction sameValueZeroEqual(a, b) {\r\n    return a === b || (a !== a && b !== b);\r\n}\n\nvar ARGUMENTS_TAG = '[object Arguments]';\r\nvar BOOLEAN_TAG = '[object Boolean]';\r\nvar DATE_TAG = '[object Date]';\r\nvar REG_EXP_TAG = '[object RegExp]';\r\nvar MAP_TAG = '[object Map]';\r\nvar NUMBER_TAG = '[object Number]';\r\nvar OBJECT_TAG = '[object Object]';\r\nvar SET_TAG = '[object Set]';\r\nvar STRING_TAG = '[object String]';\r\nvar toString = Object.prototype.toString;\r\nfunction createComparator(_a) {\r\n    var areArraysEqual = _a.areArraysEqual, areDatesEqual = _a.areDatesEqual, areMapsEqual = _a.areMapsEqual, areObjectsEqual = _a.areObjectsEqual, areRegExpsEqual = _a.areRegExpsEqual, areSetsEqual = _a.areSetsEqual, createIsNestedEqual = _a.createIsNestedEqual;\r\n    var isEqual = createIsNestedEqual(comparator);\r\n    /**\r\n     * compare the value of the two objects and return true if they are equivalent in values\r\n     */\r\n    function comparator(a, b, meta) {\r\n        // If the items are strictly equal, no need to do a value comparison.\r\n        if (a === b) {\r\n            return true;\r\n        }\r\n        // If the items are not non-nullish objects, then the only possibility\r\n        // of them being equal but not strictly is if they are both `NaN`. Since\r\n        // `NaN` is uniquely not equal to itself, we can use self-comparison of\r\n        // both objects, which is faster than `isNaN()`.\r\n        if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\r\n            return a !== a && b !== b;\r\n        }\r\n        // Checks are listed in order of commonality of use-case:\r\n        //   1. Common complex object types (plain object, array)\r\n        //   2. Common data values (date, regexp)\r\n        //   3. Less-common complex object types (map, set)\r\n        //   4. Less-common data values (promise, primitive wrappers)\r\n        // Inherently this is both subjective and assumptive, however\r\n        // when reviewing comparable libraries in the wild this order\r\n        // appears to be generally consistent.\r\n        // `isPlainObject` only checks against the object's own realm. Cross-realm\r\n        // comparisons are rare, and will be handled in the ultimate fallback, so\r\n        // we can avoid the `toString.call()` cost unless necessary.\r\n        if (isPlainObject(a) && isPlainObject(b)) {\r\n            return areObjectsEqual(a, b, isEqual, meta);\r\n        }\r\n        // `isArray()` works on subclasses and is cross-realm, so we can again avoid\r\n        // the `toString.call()` cost unless necessary by just checking if either\r\n        // and then both are arrays.\r\n        var aArray = Array.isArray(a);\r\n        var bArray = Array.isArray(b);\r\n        if (aArray || bArray) {\r\n            return aArray === bArray && areArraysEqual(a, b, isEqual, meta);\r\n        }\r\n        // Since this is a custom object, use the classic `toString.call()` to get its\r\n        // type. This is reasonably performant in modern environments like v8 and\r\n        // SpiderMonkey, and allows for cross-realm comparison when other checks like\r\n        // `instanceof` do not.\r\n        var aTag = toString.call(a);\r\n        if (aTag !== toString.call(b)) {\r\n            return false;\r\n        }\r\n        if (aTag === DATE_TAG) {\r\n            // `getTime()` showed better results compared to alternatives like `valueOf()`\r\n            // or the unary `+` operator.\r\n            return areDatesEqual(a, b, isEqual, meta);\r\n        }\r\n        if (aTag === REG_EXP_TAG) {\r\n            return areRegExpsEqual(a, b, isEqual, meta);\r\n        }\r\n        if (aTag === MAP_TAG) {\r\n            return areMapsEqual(a, b, isEqual, meta);\r\n        }\r\n        if (aTag === SET_TAG) {\r\n            return areSetsEqual(a, b, isEqual, meta);\r\n        }\r\n        // If a simple object tag, then we can prioritize a simple object comparison because\r\n        // it is likely a custom class. If an arguments tag, it should be treated as a standard\r\n        // object.\r\n        if (aTag === OBJECT_TAG || aTag === ARGUMENTS_TAG) {\r\n            // The exception for value comparison is `Promise`-like contracts. These should be\r\n            // treated the same as standard `Promise` objects, which means strict equality.\r\n            return isPromiseLike(a) || isPromiseLike(b)\r\n                ? false\r\n                : areObjectsEqual(a, b, isEqual, meta);\r\n        }\r\n        // As the penultimate fallback, check if the values passed are primitive wrappers. This\r\n        // is very rare in modern JS, which is why it is deprioritized compared to all other object\r\n        // types.\r\n        if (aTag === BOOLEAN_TAG || aTag === NUMBER_TAG || aTag === STRING_TAG) {\r\n            return sameValueZeroEqual(a.valueOf(), b.valueOf());\r\n        }\r\n        // If not matching any tags that require a specific type of comparison, then we hard-code false because\r\n        // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\r\n        //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\r\n        //     comparison that can be made.\r\n        //   - For types that can be introspected, but rarely have requirements to be compared\r\n        //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\r\n        //     use-cases (may be included in a future release, if requested enough).\r\n        //   - For types that can be introspected but do not have an objective definition of what\r\n        //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\r\n        // In all cases, these decisions should be reevaluated based on changes to the language and\r\n        // common development practices.\r\n        return false;\r\n    }\r\n    return comparator;\r\n}\n\n/**\r\n * Whether the arrays are equal in value.\r\n */\r\nfunction areArraysEqual(a, b, isEqual, meta) {\r\n    var index = a.length;\r\n    if (b.length !== index) {\r\n        return false;\r\n    }\r\n    // Decrementing `while` showed faster results than either incrementing or\r\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\r\n    // methods like `some` / `every` were not used to avoid incurring the garbage\r\n    // cost of anonymous callbacks.\r\n    while (index-- > 0) {\r\n        if (!isEqual(a[index], b[index], index, index, a, b, meta)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Whether the arrays are equal in value, including circular references.\r\n */\r\nvar areArraysEqualCircular = createIsCircular(areArraysEqual);\n\n/**\r\n * Whether the dates passed are equal in value.\r\n *\r\n * @NOTE\r\n * This is a standalone function instead of done inline in the comparator\r\n * to allow for overrides.\r\n */\r\nfunction areDatesEqual(a, b) {\r\n    return sameValueZeroEqual(a.valueOf(), b.valueOf());\r\n}\n\n/**\r\n * Whether the `Map`s are equal in value.\r\n */\r\nfunction areMapsEqual(a, b, isEqual, meta) {\r\n    var isValueEqual = a.size === b.size;\r\n    if (!isValueEqual) {\r\n        return false;\r\n    }\r\n    if (!a.size) {\r\n        return true;\r\n    }\r\n    // The use of `forEach()` is to avoid the transpilation cost of `for...of` comparisons, and\r\n    // the inability to control the performance of the resulting code. It also avoids excessive\r\n    // iteration compared to doing comparisons of `keys()` and `values()`. As a result, though,\r\n    // we cannot short-circuit the iterations; bookkeeping must be done to short-circuit the\r\n    // equality checks themselves.\r\n    var matchedIndices = {};\r\n    var indexA = 0;\r\n    a.forEach(function (aValue, aKey) {\r\n        if (!isValueEqual) {\r\n            return;\r\n        }\r\n        var hasMatch = false;\r\n        var matchIndexB = 0;\r\n        b.forEach(function (bValue, bKey) {\r\n            if (!hasMatch &&\r\n                !matchedIndices[matchIndexB] &&\r\n                (hasMatch =\r\n                    isEqual(aKey, bKey, indexA, matchIndexB, a, b, meta) &&\r\n                        isEqual(aValue, bValue, aKey, bKey, a, b, meta))) {\r\n                matchedIndices[matchIndexB] = true;\r\n            }\r\n            matchIndexB++;\r\n        });\r\n        indexA++;\r\n        isValueEqual = hasMatch;\r\n    });\r\n    return isValueEqual;\r\n}\r\n/**\r\n * Whether the `Map`s are equal in value, including circular references.\r\n */\r\nvar areMapsEqualCircular = createIsCircular(areMapsEqual);\n\nvar OWNER = '_owner';\r\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\r\n/**\r\n * Whether the objects are equal in value.\r\n */\r\nfunction areObjectsEqual(a, b, isEqual, meta) {\r\n    var keysA = Object.keys(a);\r\n    var index = keysA.length;\r\n    if (Object.keys(b).length !== index) {\r\n        return false;\r\n    }\r\n    var key;\r\n    // Decrementing `while` showed faster results than either incrementing or\r\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\r\n    // methods like `some` / `every` were not used to avoid incurring the garbage\r\n    // cost of anonymous callbacks.\r\n    while (index-- > 0) {\r\n        key = keysA[index];\r\n        if (key === OWNER) {\r\n            var reactElementA = !!a.$$typeof;\r\n            var reactElementB = !!b.$$typeof;\r\n            if ((reactElementA || reactElementB) && reactElementA !== reactElementB) {\r\n                return false;\r\n            }\r\n        }\r\n        if (!hasOwnProperty.call(b, key) ||\r\n            !isEqual(a[key], b[key], key, key, a, b, meta)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Whether the objects are equal in value, including circular references.\r\n */\r\nvar areObjectsEqualCircular = createIsCircular(areObjectsEqual);\n\n/**\r\n * Whether the regexps passed are equal in value.\r\n *\r\n * @NOTE\r\n * This is a standalone function instead of done inline in the comparator\r\n * to allow for overrides. An example of this would be supporting a\r\n * pre-ES2015 environment where the `flags` property is not available.\r\n */\r\nfunction areRegExpsEqual(a, b) {\r\n    return a.source === b.source && a.flags === b.flags;\r\n}\n\n/**\r\n * Whether the `Set`s are equal in value.\r\n */\r\nfunction areSetsEqual(a, b, isEqual, meta) {\r\n    var isValueEqual = a.size === b.size;\r\n    if (!isValueEqual) {\r\n        return false;\r\n    }\r\n    if (!a.size) {\r\n        return true;\r\n    }\r\n    // The use of `forEach()` is to avoid the transpilation cost of `for...of` comparisons, and\r\n    // the inability to control the performance of the resulting code. It also avoids excessive\r\n    // iteration compared to doing comparisons of `keys()` and `values()`. As a result, though,\r\n    // we cannot short-circuit the iterations; bookkeeping must be done to short-circuit the\r\n    // equality checks themselves.\r\n    var matchedIndices = {};\r\n    a.forEach(function (aValue, aKey) {\r\n        if (!isValueEqual) {\r\n            return;\r\n        }\r\n        var hasMatch = false;\r\n        var matchIndex = 0;\r\n        b.forEach(function (bValue, bKey) {\r\n            if (!hasMatch &&\r\n                !matchedIndices[matchIndex] &&\r\n                (hasMatch = isEqual(aValue, bValue, aKey, bKey, a, b, meta))) {\r\n                matchedIndices[matchIndex] = true;\r\n            }\r\n            matchIndex++;\r\n        });\r\n        isValueEqual = hasMatch;\r\n    });\r\n    return isValueEqual;\r\n}\r\n/**\r\n * Whether the `Set`s are equal in value, including circular references.\r\n */\r\nvar areSetsEqualCircular = createIsCircular(areSetsEqual);\n\nvar DEFAULT_CONFIG = Object.freeze({\r\n    areArraysEqual: areArraysEqual,\r\n    areDatesEqual: areDatesEqual,\r\n    areMapsEqual: areMapsEqual,\r\n    areObjectsEqual: areObjectsEqual,\r\n    areRegExpsEqual: areRegExpsEqual,\r\n    areSetsEqual: areSetsEqual,\r\n    createIsNestedEqual: createDefaultIsNestedEqual,\r\n});\r\nvar DEFAULT_CIRCULAR_CONFIG = Object.freeze({\r\n    areArraysEqual: areArraysEqualCircular,\r\n    areDatesEqual: areDatesEqual,\r\n    areMapsEqual: areMapsEqualCircular,\r\n    areObjectsEqual: areObjectsEqualCircular,\r\n    areRegExpsEqual: areRegExpsEqual,\r\n    areSetsEqual: areSetsEqualCircular,\r\n    createIsNestedEqual: createDefaultIsNestedEqual,\r\n});\r\nvar isDeepEqual = createComparator(DEFAULT_CONFIG);\r\n/**\r\n * Whether the items passed are deeply-equal in value.\r\n */\r\nfunction deepEqual(a, b) {\r\n    return isDeepEqual(a, b, undefined);\r\n}\r\nvar isShallowEqual = createComparator(merge(DEFAULT_CONFIG, { createIsNestedEqual: function () { return sameValueZeroEqual; } }));\r\n/**\r\n * Whether the items passed are shallowly-equal in value.\r\n */\r\nfunction shallowEqual(a, b) {\r\n    return isShallowEqual(a, b, undefined);\r\n}\r\nvar isCircularDeepEqual = createComparator(DEFAULT_CIRCULAR_CONFIG);\r\n/**\r\n * Whether the items passed are deeply-equal in value, including circular references.\r\n */\r\nfunction circularDeepEqual(a, b) {\r\n    return isCircularDeepEqual(a, b, new WeakMap());\r\n}\r\nvar isCircularShallowEqual = createComparator(merge(DEFAULT_CIRCULAR_CONFIG, {\r\n    createIsNestedEqual: function () { return sameValueZeroEqual; },\r\n}));\r\n/**\r\n * Whether the items passed are shallowly-equal in value, including circular references.\r\n */\r\nfunction circularShallowEqual(a, b) {\r\n    return isCircularShallowEqual(a, b, new WeakMap());\r\n}\r\n/**\r\n * Create a custom equality comparison method.\r\n *\r\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\r\n * where the standard methods are not performant enough, but can also be used to provide\r\n * support for legacy environments that do not support expected features like\r\n * `RegExp.prototype.flags` out of the box.\r\n */\r\nfunction createCustomEqual(getComparatorOptions) {\r\n    return createComparator(merge(DEFAULT_CONFIG, getComparatorOptions(DEFAULT_CONFIG)));\r\n}\r\n/**\r\n * Create a custom equality comparison method that handles circular references. This is very\r\n * similar to `createCustomEqual`, with the only difference being that `meta` expects to be\r\n * populated with a `WeakMap`-like contract.\r\n *\r\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\r\n * where the standard methods are not performant enough, but can also be used to provide\r\n * support for legacy environments that do not support expected features like\r\n * `WeakMap` out of the box.\r\n */\r\nfunction createCustomCircularEqual(getComparatorOptions) {\r\n    var comparator = createComparator(merge(DEFAULT_CIRCULAR_CONFIG, getComparatorOptions(DEFAULT_CIRCULAR_CONFIG)));\r\n    return (function (a, b, meta) {\r\n        if (meta === void 0) { meta = new WeakMap(); }\r\n        return comparator(a, b, meta);\r\n    });\r\n}\n\n\n//# sourceMappingURL=fast-equals.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC1lcXVhbHMvZGlzdC9mYXN0LWVxdWFscy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxtQ0FBbUMsOEJBQThCO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNEJBQTRCO0FBQ25FLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxLQUFLO0FBQ0w7O0FBRThJO0FBQzlJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vejEwdHJpYWdlLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9mYXN0LWVxdWFscy9kaXN0L2Zhc3QtZXF1YWxzLmVzbS5qcz8wOGFiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBEZWZhdWx0IGVxdWFsaXR5IGNvbXBhcmF0b3IgcGFzcy10aHJvdWdoLCB1c2VkIGFzIHRoZSBzdGFuZGFyZCBgaXNFcXVhbGAgY3JlYXRvciBmb3JcclxuICogdXNlIGluc2lkZSB0aGUgYnVpbHQgY29tcGFyYXRvci5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRJc05lc3RlZEVxdWFsKGNvbXBhcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBpc0VxdWFsKGEsIGIsIF9pbmRleE9yS2V5QSwgX2luZGV4T3JLZXlCLCBfcGFyZW50QSwgX3BhcmVudEIsIG1ldGEpIHtcclxuICAgICAgICByZXR1cm4gY29tcGFyYXRvcihhLCBiLCBtZXRhKTtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIFdyYXAgdGhlIHByb3ZpZGVkIGBhcmVJdGVtc0VxdWFsYCBtZXRob2QgdG8gbWFuYWdlIHRoZSBjaXJjdWxhciBjYWNoZSwgYWxsb3dpbmdcclxuICogZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgdG8gYmUgc2FmZWx5IGluY2x1ZGVkIGluIHRoZSBjb21wYXJpc29uIHdpdGhvdXQgY3JlYXRpbmdcclxuICogc3RhY2sgb3ZlcmZsb3dzLlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlSXNDaXJjdWxhcihhcmVJdGVtc0VxdWFsKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gaXNDaXJjdWxhcihhLCBiLCBpc0VxdWFsLCBjYWNoZSkge1xyXG4gICAgICAgIGlmICghYSB8fCAhYiB8fCB0eXBlb2YgYSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcmVJdGVtc0VxdWFsKGEsIGIsIGlzRXF1YWwsIGNhY2hlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNhY2hlZEEgPSBjYWNoZS5nZXQoYSk7XHJcbiAgICAgICAgdmFyIGNhY2hlZEIgPSBjYWNoZS5nZXQoYik7XHJcbiAgICAgICAgaWYgKGNhY2hlZEEgJiYgY2FjaGVkQikge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQSA9PT0gYiAmJiBjYWNoZWRCID09PSBhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYWNoZS5zZXQoYSwgYik7XHJcbiAgICAgICAgY2FjaGUuc2V0KGIsIGEpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBhcmVJdGVtc0VxdWFsKGEsIGIsIGlzRXF1YWwsIGNhY2hlKTtcclxuICAgICAgICBjYWNoZS5kZWxldGUoYSk7XHJcbiAgICAgICAgY2FjaGUuZGVsZXRlKGIpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBUYXJnZXRlZCBzaGFsbG93IG1lcmdlIG9mIHR3byBvYmplY3RzLlxyXG4gKlxyXG4gKiBATk9URVxyXG4gKiBUaGlzIGV4aXN0cyBhcyBhIHRpbmllciBjb21waWxlZCB2ZXJzaW9uIG9mIHRoZSBgX19hc3NpZ25gIGhlbHBlciB0aGF0XHJcbiAqIGB0c2NgIGluamVjdHMgaW4gY2FzZSBvZiBgT2JqZWN0LmFzc2lnbmAgbm90IGJlaW5nIHByZXNlbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZShhLCBiKSB7XHJcbiAgICB2YXIgbWVyZ2VkID0ge307XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gYSkge1xyXG4gICAgICAgIG1lcmdlZFtrZXldID0gYVtrZXldO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIga2V5IGluIGIpIHtcclxuICAgICAgICBtZXJnZWRba2V5XSA9IGJba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiBtZXJnZWQ7XHJcbn1cclxuLyoqXHJcbiAqIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxyXG4gKlxyXG4gKiBATk9URVxyXG4gKiBUaGlzIGlzIGEgc2FtZS1yZWFsbSBjb21wYXJpb3NuIG9ubHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCB8fCB2YWx1ZS5jb25zdHJ1Y3RvciA9PSBudWxsO1xyXG59XHJcbi8qKlxyXG4gKiBXaGVuIHRoZSB2YWx1ZSBpcyBgUHJvbWlzZWAtbGlrZSwgYWthIFwidGhlbi1hYmxlXCIuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1Byb21pc2VMaWtlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbic7XHJcbn1cclxuLyoqXHJcbiAqIFdoZXRoZXIgdGhlIHZhbHVlcyBwYXNzZWQgYXJlIHN0cmljdGx5IGVxdWFsIG9yIGJvdGggTmFOLlxyXG4gKi9cclxuZnVuY3Rpb24gc2FtZVZhbHVlWmVyb0VxdWFsKGEsIGIpIHtcclxuICAgIHJldHVybiBhID09PSBiIHx8IChhICE9PSBhICYmIGIgIT09IGIpO1xyXG59XG5cbnZhciBBUkdVTUVOVFNfVEFHID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XHJcbnZhciBCT09MRUFOX1RBRyA9ICdbb2JqZWN0IEJvb2xlYW5dJztcclxudmFyIERBVEVfVEFHID0gJ1tvYmplY3QgRGF0ZV0nO1xyXG52YXIgUkVHX0VYUF9UQUcgPSAnW29iamVjdCBSZWdFeHBdJztcclxudmFyIE1BUF9UQUcgPSAnW29iamVjdCBNYXBdJztcclxudmFyIE5VTUJFUl9UQUcgPSAnW29iamVjdCBOdW1iZXJdJztcclxudmFyIE9CSkVDVF9UQUcgPSAnW29iamVjdCBPYmplY3RdJztcclxudmFyIFNFVF9UQUcgPSAnW29iamVjdCBTZXRdJztcclxudmFyIFNUUklOR19UQUcgPSAnW29iamVjdCBTdHJpbmddJztcclxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxuZnVuY3Rpb24gY3JlYXRlQ29tcGFyYXRvcihfYSkge1xyXG4gICAgdmFyIGFyZUFycmF5c0VxdWFsID0gX2EuYXJlQXJyYXlzRXF1YWwsIGFyZURhdGVzRXF1YWwgPSBfYS5hcmVEYXRlc0VxdWFsLCBhcmVNYXBzRXF1YWwgPSBfYS5hcmVNYXBzRXF1YWwsIGFyZU9iamVjdHNFcXVhbCA9IF9hLmFyZU9iamVjdHNFcXVhbCwgYXJlUmVnRXhwc0VxdWFsID0gX2EuYXJlUmVnRXhwc0VxdWFsLCBhcmVTZXRzRXF1YWwgPSBfYS5hcmVTZXRzRXF1YWwsIGNyZWF0ZUlzTmVzdGVkRXF1YWwgPSBfYS5jcmVhdGVJc05lc3RlZEVxdWFsO1xyXG4gICAgdmFyIGlzRXF1YWwgPSBjcmVhdGVJc05lc3RlZEVxdWFsKGNvbXBhcmF0b3IpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBjb21wYXJlIHRoZSB2YWx1ZSBvZiB0aGUgdHdvIG9iamVjdHMgYW5kIHJldHVybiB0cnVlIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQgaW4gdmFsdWVzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvbXBhcmF0b3IoYSwgYiwgbWV0YSkge1xyXG4gICAgICAgIC8vIElmIHRoZSBpdGVtcyBhcmUgc3RyaWN0bHkgZXF1YWwsIG5vIG5lZWQgdG8gZG8gYSB2YWx1ZSBjb21wYXJpc29uLlxyXG4gICAgICAgIGlmIChhID09PSBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB0aGUgaXRlbXMgYXJlIG5vdCBub24tbnVsbGlzaCBvYmplY3RzLCB0aGVuIHRoZSBvbmx5IHBvc3NpYmlsaXR5XHJcbiAgICAgICAgLy8gb2YgdGhlbSBiZWluZyBlcXVhbCBidXQgbm90IHN0cmljdGx5IGlzIGlmIHRoZXkgYXJlIGJvdGggYE5hTmAuIFNpbmNlXHJcbiAgICAgICAgLy8gYE5hTmAgaXMgdW5pcXVlbHkgbm90IGVxdWFsIHRvIGl0c2VsZiwgd2UgY2FuIHVzZSBzZWxmLWNvbXBhcmlzb24gb2ZcclxuICAgICAgICAvLyBib3RoIG9iamVjdHMsIHdoaWNoIGlzIGZhc3RlciB0aGFuIGBpc05hTigpYC5cclxuICAgICAgICBpZiAoIWEgfHwgIWIgfHwgdHlwZW9mIGEgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gYSAhPT0gYSAmJiBiICE9PSBiO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVja3MgYXJlIGxpc3RlZCBpbiBvcmRlciBvZiBjb21tb25hbGl0eSBvZiB1c2UtY2FzZTpcclxuICAgICAgICAvLyAgIDEuIENvbW1vbiBjb21wbGV4IG9iamVjdCB0eXBlcyAocGxhaW4gb2JqZWN0LCBhcnJheSlcclxuICAgICAgICAvLyAgIDIuIENvbW1vbiBkYXRhIHZhbHVlcyAoZGF0ZSwgcmVnZXhwKVxyXG4gICAgICAgIC8vICAgMy4gTGVzcy1jb21tb24gY29tcGxleCBvYmplY3QgdHlwZXMgKG1hcCwgc2V0KVxyXG4gICAgICAgIC8vICAgNC4gTGVzcy1jb21tb24gZGF0YSB2YWx1ZXMgKHByb21pc2UsIHByaW1pdGl2ZSB3cmFwcGVycylcclxuICAgICAgICAvLyBJbmhlcmVudGx5IHRoaXMgaXMgYm90aCBzdWJqZWN0aXZlIGFuZCBhc3N1bXB0aXZlLCBob3dldmVyXHJcbiAgICAgICAgLy8gd2hlbiByZXZpZXdpbmcgY29tcGFyYWJsZSBsaWJyYXJpZXMgaW4gdGhlIHdpbGQgdGhpcyBvcmRlclxyXG4gICAgICAgIC8vIGFwcGVhcnMgdG8gYmUgZ2VuZXJhbGx5IGNvbnNpc3RlbnQuXHJcbiAgICAgICAgLy8gYGlzUGxhaW5PYmplY3RgIG9ubHkgY2hlY2tzIGFnYWluc3QgdGhlIG9iamVjdCdzIG93biByZWFsbS4gQ3Jvc3MtcmVhbG1cclxuICAgICAgICAvLyBjb21wYXJpc29ucyBhcmUgcmFyZSwgYW5kIHdpbGwgYmUgaGFuZGxlZCBpbiB0aGUgdWx0aW1hdGUgZmFsbGJhY2ssIHNvXHJcbiAgICAgICAgLy8gd2UgY2FuIGF2b2lkIHRoZSBgdG9TdHJpbmcuY2FsbCgpYCBjb3N0IHVubGVzcyBuZWNlc3NhcnkuXHJcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QoYSkgJiYgaXNQbGFpbk9iamVjdChiKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJlT2JqZWN0c0VxdWFsKGEsIGIsIGlzRXF1YWwsIG1ldGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBgaXNBcnJheSgpYCB3b3JrcyBvbiBzdWJjbGFzc2VzIGFuZCBpcyBjcm9zcy1yZWFsbSwgc28gd2UgY2FuIGFnYWluIGF2b2lkXHJcbiAgICAgICAgLy8gdGhlIGB0b1N0cmluZy5jYWxsKClgIGNvc3QgdW5sZXNzIG5lY2Vzc2FyeSBieSBqdXN0IGNoZWNraW5nIGlmIGVpdGhlclxyXG4gICAgICAgIC8vIGFuZCB0aGVuIGJvdGggYXJlIGFycmF5cy5cclxuICAgICAgICB2YXIgYUFycmF5ID0gQXJyYXkuaXNBcnJheShhKTtcclxuICAgICAgICB2YXIgYkFycmF5ID0gQXJyYXkuaXNBcnJheShiKTtcclxuICAgICAgICBpZiAoYUFycmF5IHx8IGJBcnJheSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYUFycmF5ID09PSBiQXJyYXkgJiYgYXJlQXJyYXlzRXF1YWwoYSwgYiwgaXNFcXVhbCwgbWV0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYSBjdXN0b20gb2JqZWN0LCB1c2UgdGhlIGNsYXNzaWMgYHRvU3RyaW5nLmNhbGwoKWAgdG8gZ2V0IGl0c1xyXG4gICAgICAgIC8vIHR5cGUuIFRoaXMgaXMgcmVhc29uYWJseSBwZXJmb3JtYW50IGluIG1vZGVybiBlbnZpcm9ubWVudHMgbGlrZSB2OCBhbmRcclxuICAgICAgICAvLyBTcGlkZXJNb25rZXksIGFuZCBhbGxvd3MgZm9yIGNyb3NzLXJlYWxtIGNvbXBhcmlzb24gd2hlbiBvdGhlciBjaGVja3MgbGlrZVxyXG4gICAgICAgIC8vIGBpbnN0YW5jZW9mYCBkbyBub3QuXHJcbiAgICAgICAgdmFyIGFUYWcgPSB0b1N0cmluZy5jYWxsKGEpO1xyXG4gICAgICAgIGlmIChhVGFnICE9PSB0b1N0cmluZy5jYWxsKGIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFUYWcgPT09IERBVEVfVEFHKSB7XHJcbiAgICAgICAgICAgIC8vIGBnZXRUaW1lKClgIHNob3dlZCBiZXR0ZXIgcmVzdWx0cyBjb21wYXJlZCB0byBhbHRlcm5hdGl2ZXMgbGlrZSBgdmFsdWVPZigpYFxyXG4gICAgICAgICAgICAvLyBvciB0aGUgdW5hcnkgYCtgIG9wZXJhdG9yLlxyXG4gICAgICAgICAgICByZXR1cm4gYXJlRGF0ZXNFcXVhbChhLCBiLCBpc0VxdWFsLCBtZXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFUYWcgPT09IFJFR19FWFBfVEFHKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcmVSZWdFeHBzRXF1YWwoYSwgYiwgaXNFcXVhbCwgbWV0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhVGFnID09PSBNQVBfVEFHKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcmVNYXBzRXF1YWwoYSwgYiwgaXNFcXVhbCwgbWV0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhVGFnID09PSBTRVRfVEFHKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcmVTZXRzRXF1YWwoYSwgYiwgaXNFcXVhbCwgbWV0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIGEgc2ltcGxlIG9iamVjdCB0YWcsIHRoZW4gd2UgY2FuIHByaW9yaXRpemUgYSBzaW1wbGUgb2JqZWN0IGNvbXBhcmlzb24gYmVjYXVzZVxyXG4gICAgICAgIC8vIGl0IGlzIGxpa2VseSBhIGN1c3RvbSBjbGFzcy4gSWYgYW4gYXJndW1lbnRzIHRhZywgaXQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSBzdGFuZGFyZFxyXG4gICAgICAgIC8vIG9iamVjdC5cclxuICAgICAgICBpZiAoYVRhZyA9PT0gT0JKRUNUX1RBRyB8fCBhVGFnID09PSBBUkdVTUVOVFNfVEFHKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBleGNlcHRpb24gZm9yIHZhbHVlIGNvbXBhcmlzb24gaXMgYFByb21pc2VgLWxpa2UgY29udHJhY3RzLiBUaGVzZSBzaG91bGQgYmVcclxuICAgICAgICAgICAgLy8gdHJlYXRlZCB0aGUgc2FtZSBhcyBzdGFuZGFyZCBgUHJvbWlzZWAgb2JqZWN0cywgd2hpY2ggbWVhbnMgc3RyaWN0IGVxdWFsaXR5LlxyXG4gICAgICAgICAgICByZXR1cm4gaXNQcm9taXNlTGlrZShhKSB8fCBpc1Byb21pc2VMaWtlKGIpXHJcbiAgICAgICAgICAgICAgICA/IGZhbHNlXHJcbiAgICAgICAgICAgICAgICA6IGFyZU9iamVjdHNFcXVhbChhLCBiLCBpc0VxdWFsLCBtZXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQXMgdGhlIHBlbnVsdGltYXRlIGZhbGxiYWNrLCBjaGVjayBpZiB0aGUgdmFsdWVzIHBhc3NlZCBhcmUgcHJpbWl0aXZlIHdyYXBwZXJzLiBUaGlzXHJcbiAgICAgICAgLy8gaXMgdmVyeSByYXJlIGluIG1vZGVybiBKUywgd2hpY2ggaXMgd2h5IGl0IGlzIGRlcHJpb3JpdGl6ZWQgY29tcGFyZWQgdG8gYWxsIG90aGVyIG9iamVjdFxyXG4gICAgICAgIC8vIHR5cGVzLlxyXG4gICAgICAgIGlmIChhVGFnID09PSBCT09MRUFOX1RBRyB8fCBhVGFnID09PSBOVU1CRVJfVEFHIHx8IGFUYWcgPT09IFNUUklOR19UQUcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNhbWVWYWx1ZVplcm9FcXVhbChhLnZhbHVlT2YoKSwgYi52YWx1ZU9mKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBub3QgbWF0Y2hpbmcgYW55IHRhZ3MgdGhhdCByZXF1aXJlIGEgc3BlY2lmaWMgdHlwZSBvZiBjb21wYXJpc29uLCB0aGVuIHdlIGhhcmQtY29kZSBmYWxzZSBiZWNhdXNlXHJcbiAgICAgICAgLy8gdGhlIG9ubHkgdGhpbmcgcmVtYWluaW5nIGlzIHN0cmljdCBlcXVhbGl0eSwgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBjb21wYXJlZC4gVGhpcyBpcyBmb3IgYSBmZXcgcmVhc29uczpcclxuICAgICAgICAvLyAgIC0gQ2VydGFpbiB0eXBlcyB0aGF0IGNhbm5vdCBiZSBpbnRyb3NwZWN0ZWQgKGUuZy4sIGBXZWFrTWFwYCkuIEZvciB0aGVzZSB0eXBlcywgdGhpcyBpcyB0aGUgb25seVxyXG4gICAgICAgIC8vICAgICBjb21wYXJpc29uIHRoYXQgY2FuIGJlIG1hZGUuXHJcbiAgICAgICAgLy8gICAtIEZvciB0eXBlcyB0aGF0IGNhbiBiZSBpbnRyb3NwZWN0ZWQsIGJ1dCByYXJlbHkgaGF2ZSByZXF1aXJlbWVudHMgdG8gYmUgY29tcGFyZWRcclxuICAgICAgICAvLyAgICAgKGBBcnJheUJ1ZmZlcmAsIGBEYXRhVmlld2AsIGV0Yy4pLCB0aGUgY29zdCBpcyBhdm9pZGVkIHRvIHByaW9yaXRpemUgdGhlIGNvbW1vblxyXG4gICAgICAgIC8vICAgICB1c2UtY2FzZXMgKG1heSBiZSBpbmNsdWRlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLCBpZiByZXF1ZXN0ZWQgZW5vdWdoKS5cclxuICAgICAgICAvLyAgIC0gRm9yIHR5cGVzIHRoYXQgY2FuIGJlIGludHJvc3BlY3RlZCBidXQgZG8gbm90IGhhdmUgYW4gb2JqZWN0aXZlIGRlZmluaXRpb24gb2Ygd2hhdFxyXG4gICAgICAgIC8vICAgICBlcXVhbGl0eSBpcyAoYEVycm9yYCwgZXRjLiksIHRoZSBzdWJqZWN0aXZlIGRlY2lzaW9uIGlzIHRvIGJlIGNvbnNlcnZhdGl2ZSBhbmQgc3RyaWN0bHkgY29tcGFyZS5cclxuICAgICAgICAvLyBJbiBhbGwgY2FzZXMsIHRoZXNlIGRlY2lzaW9ucyBzaG91bGQgYmUgcmVldmFsdWF0ZWQgYmFzZWQgb24gY2hhbmdlcyB0byB0aGUgbGFuZ3VhZ2UgYW5kXHJcbiAgICAgICAgLy8gY29tbW9uIGRldmVsb3BtZW50IHByYWN0aWNlcy5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29tcGFyYXRvcjtcclxufVxuXG4vKipcclxuICogV2hldGhlciB0aGUgYXJyYXlzIGFyZSBlcXVhbCBpbiB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGFyZUFycmF5c0VxdWFsKGEsIGIsIGlzRXF1YWwsIG1ldGEpIHtcclxuICAgIHZhciBpbmRleCA9IGEubGVuZ3RoO1xyXG4gICAgaWYgKGIubGVuZ3RoICE9PSBpbmRleCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIERlY3JlbWVudGluZyBgd2hpbGVgIHNob3dlZCBmYXN0ZXIgcmVzdWx0cyB0aGFuIGVpdGhlciBpbmNyZW1lbnRpbmcgb3JcclxuICAgIC8vIGRlY3JlbWVudGluZyBgZm9yYCBsb29wIGFuZCB0aGFuIGFuIGluY3JlbWVudGluZyBgd2hpbGVgIGxvb3AuIERlY2xhcmF0aXZlXHJcbiAgICAvLyBtZXRob2RzIGxpa2UgYHNvbWVgIC8gYGV2ZXJ5YCB3ZXJlIG5vdCB1c2VkIHRvIGF2b2lkIGluY3VycmluZyB0aGUgZ2FyYmFnZVxyXG4gICAgLy8gY29zdCBvZiBhbm9ueW1vdXMgY2FsbGJhY2tzLlxyXG4gICAgd2hpbGUgKGluZGV4LS0gPiAwKSB7XHJcbiAgICAgICAgaWYgKCFpc0VxdWFsKGFbaW5kZXhdLCBiW2luZGV4XSwgaW5kZXgsIGluZGV4LCBhLCBiLCBtZXRhKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIFdoZXRoZXIgdGhlIGFycmF5cyBhcmUgZXF1YWwgaW4gdmFsdWUsIGluY2x1ZGluZyBjaXJjdWxhciByZWZlcmVuY2VzLlxyXG4gKi9cclxudmFyIGFyZUFycmF5c0VxdWFsQ2lyY3VsYXIgPSBjcmVhdGVJc0NpcmN1bGFyKGFyZUFycmF5c0VxdWFsKTtcblxuLyoqXHJcbiAqIFdoZXRoZXIgdGhlIGRhdGVzIHBhc3NlZCBhcmUgZXF1YWwgaW4gdmFsdWUuXHJcbiAqXHJcbiAqIEBOT1RFXHJcbiAqIFRoaXMgaXMgYSBzdGFuZGFsb25lIGZ1bmN0aW9uIGluc3RlYWQgb2YgZG9uZSBpbmxpbmUgaW4gdGhlIGNvbXBhcmF0b3JcclxuICogdG8gYWxsb3cgZm9yIG92ZXJyaWRlcy5cclxuICovXHJcbmZ1bmN0aW9uIGFyZURhdGVzRXF1YWwoYSwgYikge1xyXG4gICAgcmV0dXJuIHNhbWVWYWx1ZVplcm9FcXVhbChhLnZhbHVlT2YoKSwgYi52YWx1ZU9mKCkpO1xyXG59XG5cbi8qKlxyXG4gKiBXaGV0aGVyIHRoZSBgTWFwYHMgYXJlIGVxdWFsIGluIHZhbHVlLlxyXG4gKi9cclxuZnVuY3Rpb24gYXJlTWFwc0VxdWFsKGEsIGIsIGlzRXF1YWwsIG1ldGEpIHtcclxuICAgIHZhciBpc1ZhbHVlRXF1YWwgPSBhLnNpemUgPT09IGIuc2l6ZTtcclxuICAgIGlmICghaXNWYWx1ZUVxdWFsKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKCFhLnNpemUpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIFRoZSB1c2Ugb2YgYGZvckVhY2goKWAgaXMgdG8gYXZvaWQgdGhlIHRyYW5zcGlsYXRpb24gY29zdCBvZiBgZm9yLi4ub2ZgIGNvbXBhcmlzb25zLCBhbmRcclxuICAgIC8vIHRoZSBpbmFiaWxpdHkgdG8gY29udHJvbCB0aGUgcGVyZm9ybWFuY2Ugb2YgdGhlIHJlc3VsdGluZyBjb2RlLiBJdCBhbHNvIGF2b2lkcyBleGNlc3NpdmVcclxuICAgIC8vIGl0ZXJhdGlvbiBjb21wYXJlZCB0byBkb2luZyBjb21wYXJpc29ucyBvZiBga2V5cygpYCBhbmQgYHZhbHVlcygpYC4gQXMgYSByZXN1bHQsIHRob3VnaCxcclxuICAgIC8vIHdlIGNhbm5vdCBzaG9ydC1jaXJjdWl0IHRoZSBpdGVyYXRpb25zOyBib29ra2VlcGluZyBtdXN0IGJlIGRvbmUgdG8gc2hvcnQtY2lyY3VpdCB0aGVcclxuICAgIC8vIGVxdWFsaXR5IGNoZWNrcyB0aGVtc2VsdmVzLlxyXG4gICAgdmFyIG1hdGNoZWRJbmRpY2VzID0ge307XHJcbiAgICB2YXIgaW5kZXhBID0gMDtcclxuICAgIGEuZm9yRWFjaChmdW5jdGlvbiAoYVZhbHVlLCBhS2V5KSB7XHJcbiAgICAgICAgaWYgKCFpc1ZhbHVlRXF1YWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaGFzTWF0Y2ggPSBmYWxzZTtcclxuICAgICAgICB2YXIgbWF0Y2hJbmRleEIgPSAwO1xyXG4gICAgICAgIGIuZm9yRWFjaChmdW5jdGlvbiAoYlZhbHVlLCBiS2V5KSB7XHJcbiAgICAgICAgICAgIGlmICghaGFzTWF0Y2ggJiZcclxuICAgICAgICAgICAgICAgICFtYXRjaGVkSW5kaWNlc1ttYXRjaEluZGV4Ql0gJiZcclxuICAgICAgICAgICAgICAgIChoYXNNYXRjaCA9XHJcbiAgICAgICAgICAgICAgICAgICAgaXNFcXVhbChhS2V5LCBiS2V5LCBpbmRleEEsIG1hdGNoSW5kZXhCLCBhLCBiLCBtZXRhKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VxdWFsKGFWYWx1ZSwgYlZhbHVlLCBhS2V5LCBiS2V5LCBhLCBiLCBtZXRhKSkpIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoZWRJbmRpY2VzW21hdGNoSW5kZXhCXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWF0Y2hJbmRleEIrKztcclxuICAgICAgICB9KTtcclxuICAgICAgICBpbmRleEErKztcclxuICAgICAgICBpc1ZhbHVlRXF1YWwgPSBoYXNNYXRjaDtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGlzVmFsdWVFcXVhbDtcclxufVxyXG4vKipcclxuICogV2hldGhlciB0aGUgYE1hcGBzIGFyZSBlcXVhbCBpbiB2YWx1ZSwgaW5jbHVkaW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMuXHJcbiAqL1xyXG52YXIgYXJlTWFwc0VxdWFsQ2lyY3VsYXIgPSBjcmVhdGVJc0NpcmN1bGFyKGFyZU1hcHNFcXVhbCk7XG5cbnZhciBPV05FUiA9ICdfb3duZXInO1xyXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG4vKipcclxuICogV2hldGhlciB0aGUgb2JqZWN0cyBhcmUgZXF1YWwgaW4gdmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcmVPYmplY3RzRXF1YWwoYSwgYiwgaXNFcXVhbCwgbWV0YSkge1xyXG4gICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XHJcbiAgICB2YXIgaW5kZXggPSBrZXlzQS5sZW5ndGg7XHJcbiAgICBpZiAoT2JqZWN0LmtleXMoYikubGVuZ3RoICE9PSBpbmRleCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHZhciBrZXk7XHJcbiAgICAvLyBEZWNyZW1lbnRpbmcgYHdoaWxlYCBzaG93ZWQgZmFzdGVyIHJlc3VsdHMgdGhhbiBlaXRoZXIgaW5jcmVtZW50aW5nIG9yXHJcbiAgICAvLyBkZWNyZW1lbnRpbmcgYGZvcmAgbG9vcCBhbmQgdGhhbiBhbiBpbmNyZW1lbnRpbmcgYHdoaWxlYCBsb29wLiBEZWNsYXJhdGl2ZVxyXG4gICAgLy8gbWV0aG9kcyBsaWtlIGBzb21lYCAvIGBldmVyeWAgd2VyZSBub3QgdXNlZCB0byBhdm9pZCBpbmN1cnJpbmcgdGhlIGdhcmJhZ2VcclxuICAgIC8vIGNvc3Qgb2YgYW5vbnltb3VzIGNhbGxiYWNrcy5cclxuICAgIHdoaWxlIChpbmRleC0tID4gMCkge1xyXG4gICAgICAgIGtleSA9IGtleXNBW2luZGV4XTtcclxuICAgICAgICBpZiAoa2V5ID09PSBPV05FUikge1xyXG4gICAgICAgICAgICB2YXIgcmVhY3RFbGVtZW50QSA9ICEhYS4kJHR5cGVvZjtcclxuICAgICAgICAgICAgdmFyIHJlYWN0RWxlbWVudEIgPSAhIWIuJCR0eXBlb2Y7XHJcbiAgICAgICAgICAgIGlmICgocmVhY3RFbGVtZW50QSB8fCByZWFjdEVsZW1lbnRCKSAmJiByZWFjdEVsZW1lbnRBICE9PSByZWFjdEVsZW1lbnRCKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleSkgfHxcclxuICAgICAgICAgICAgIWlzRXF1YWwoYVtrZXldLCBiW2tleV0sIGtleSwga2V5LCBhLCBiLCBtZXRhKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIFdoZXRoZXIgdGhlIG9iamVjdHMgYXJlIGVxdWFsIGluIHZhbHVlLCBpbmNsdWRpbmcgY2lyY3VsYXIgcmVmZXJlbmNlcy5cclxuICovXHJcbnZhciBhcmVPYmplY3RzRXF1YWxDaXJjdWxhciA9IGNyZWF0ZUlzQ2lyY3VsYXIoYXJlT2JqZWN0c0VxdWFsKTtcblxuLyoqXHJcbiAqIFdoZXRoZXIgdGhlIHJlZ2V4cHMgcGFzc2VkIGFyZSBlcXVhbCBpbiB2YWx1ZS5cclxuICpcclxuICogQE5PVEVcclxuICogVGhpcyBpcyBhIHN0YW5kYWxvbmUgZnVuY3Rpb24gaW5zdGVhZCBvZiBkb25lIGlubGluZSBpbiB0aGUgY29tcGFyYXRvclxyXG4gKiB0byBhbGxvdyBmb3Igb3ZlcnJpZGVzLiBBbiBleGFtcGxlIG9mIHRoaXMgd291bGQgYmUgc3VwcG9ydGluZyBhXHJcbiAqIHByZS1FUzIwMTUgZW52aXJvbm1lbnQgd2hlcmUgdGhlIGBmbGFnc2AgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZS5cclxuICovXHJcbmZ1bmN0aW9uIGFyZVJlZ0V4cHNFcXVhbChhLCBiKSB7XHJcbiAgICByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XHJcbn1cblxuLyoqXHJcbiAqIFdoZXRoZXIgdGhlIGBTZXRgcyBhcmUgZXF1YWwgaW4gdmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcmVTZXRzRXF1YWwoYSwgYiwgaXNFcXVhbCwgbWV0YSkge1xyXG4gICAgdmFyIGlzVmFsdWVFcXVhbCA9IGEuc2l6ZSA9PT0gYi5zaXplO1xyXG4gICAgaWYgKCFpc1ZhbHVlRXF1YWwpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoIWEuc2l6ZSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gVGhlIHVzZSBvZiBgZm9yRWFjaCgpYCBpcyB0byBhdm9pZCB0aGUgdHJhbnNwaWxhdGlvbiBjb3N0IG9mIGBmb3IuLi5vZmAgY29tcGFyaXNvbnMsIGFuZFxyXG4gICAgLy8gdGhlIGluYWJpbGl0eSB0byBjb250cm9sIHRoZSBwZXJmb3JtYW5jZSBvZiB0aGUgcmVzdWx0aW5nIGNvZGUuIEl0IGFsc28gYXZvaWRzIGV4Y2Vzc2l2ZVxyXG4gICAgLy8gaXRlcmF0aW9uIGNvbXBhcmVkIHRvIGRvaW5nIGNvbXBhcmlzb25zIG9mIGBrZXlzKClgIGFuZCBgdmFsdWVzKClgLiBBcyBhIHJlc3VsdCwgdGhvdWdoLFxyXG4gICAgLy8gd2UgY2Fubm90IHNob3J0LWNpcmN1aXQgdGhlIGl0ZXJhdGlvbnM7IGJvb2trZWVwaW5nIG11c3QgYmUgZG9uZSB0byBzaG9ydC1jaXJjdWl0IHRoZVxyXG4gICAgLy8gZXF1YWxpdHkgY2hlY2tzIHRoZW1zZWx2ZXMuXHJcbiAgICB2YXIgbWF0Y2hlZEluZGljZXMgPSB7fTtcclxuICAgIGEuZm9yRWFjaChmdW5jdGlvbiAoYVZhbHVlLCBhS2V5KSB7XHJcbiAgICAgICAgaWYgKCFpc1ZhbHVlRXF1YWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaGFzTWF0Y2ggPSBmYWxzZTtcclxuICAgICAgICB2YXIgbWF0Y2hJbmRleCA9IDA7XHJcbiAgICAgICAgYi5mb3JFYWNoKGZ1bmN0aW9uIChiVmFsdWUsIGJLZXkpIHtcclxuICAgICAgICAgICAgaWYgKCFoYXNNYXRjaCAmJlxyXG4gICAgICAgICAgICAgICAgIW1hdGNoZWRJbmRpY2VzW21hdGNoSW5kZXhdICYmXHJcbiAgICAgICAgICAgICAgICAoaGFzTWF0Y2ggPSBpc0VxdWFsKGFWYWx1ZSwgYlZhbHVlLCBhS2V5LCBiS2V5LCBhLCBiLCBtZXRhKSkpIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoZWRJbmRpY2VzW21hdGNoSW5kZXhdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtYXRjaEluZGV4Kys7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaXNWYWx1ZUVxdWFsID0gaGFzTWF0Y2g7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBpc1ZhbHVlRXF1YWw7XHJcbn1cclxuLyoqXHJcbiAqIFdoZXRoZXIgdGhlIGBTZXRgcyBhcmUgZXF1YWwgaW4gdmFsdWUsIGluY2x1ZGluZyBjaXJjdWxhciByZWZlcmVuY2VzLlxyXG4gKi9cclxudmFyIGFyZVNldHNFcXVhbENpcmN1bGFyID0gY3JlYXRlSXNDaXJjdWxhcihhcmVTZXRzRXF1YWwpO1xuXG52YXIgREVGQVVMVF9DT05GSUcgPSBPYmplY3QuZnJlZXplKHtcclxuICAgIGFyZUFycmF5c0VxdWFsOiBhcmVBcnJheXNFcXVhbCxcclxuICAgIGFyZURhdGVzRXF1YWw6IGFyZURhdGVzRXF1YWwsXHJcbiAgICBhcmVNYXBzRXF1YWw6IGFyZU1hcHNFcXVhbCxcclxuICAgIGFyZU9iamVjdHNFcXVhbDogYXJlT2JqZWN0c0VxdWFsLFxyXG4gICAgYXJlUmVnRXhwc0VxdWFsOiBhcmVSZWdFeHBzRXF1YWwsXHJcbiAgICBhcmVTZXRzRXF1YWw6IGFyZVNldHNFcXVhbCxcclxuICAgIGNyZWF0ZUlzTmVzdGVkRXF1YWw6IGNyZWF0ZURlZmF1bHRJc05lc3RlZEVxdWFsLFxyXG59KTtcclxudmFyIERFRkFVTFRfQ0lSQ1VMQVJfQ09ORklHID0gT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICBhcmVBcnJheXNFcXVhbDogYXJlQXJyYXlzRXF1YWxDaXJjdWxhcixcclxuICAgIGFyZURhdGVzRXF1YWw6IGFyZURhdGVzRXF1YWwsXHJcbiAgICBhcmVNYXBzRXF1YWw6IGFyZU1hcHNFcXVhbENpcmN1bGFyLFxyXG4gICAgYXJlT2JqZWN0c0VxdWFsOiBhcmVPYmplY3RzRXF1YWxDaXJjdWxhcixcclxuICAgIGFyZVJlZ0V4cHNFcXVhbDogYXJlUmVnRXhwc0VxdWFsLFxyXG4gICAgYXJlU2V0c0VxdWFsOiBhcmVTZXRzRXF1YWxDaXJjdWxhcixcclxuICAgIGNyZWF0ZUlzTmVzdGVkRXF1YWw6IGNyZWF0ZURlZmF1bHRJc05lc3RlZEVxdWFsLFxyXG59KTtcclxudmFyIGlzRGVlcEVxdWFsID0gY3JlYXRlQ29tcGFyYXRvcihERUZBVUxUX0NPTkZJRyk7XHJcbi8qKlxyXG4gKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIGRlZXBseS1lcXVhbCBpbiB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7XHJcbiAgICByZXR1cm4gaXNEZWVwRXF1YWwoYSwgYiwgdW5kZWZpbmVkKTtcclxufVxyXG52YXIgaXNTaGFsbG93RXF1YWwgPSBjcmVhdGVDb21wYXJhdG9yKG1lcmdlKERFRkFVTFRfQ09ORklHLCB7IGNyZWF0ZUlzTmVzdGVkRXF1YWw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNhbWVWYWx1ZVplcm9FcXVhbDsgfSB9KSk7XHJcbi8qKlxyXG4gKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIHNoYWxsb3dseS1lcXVhbCBpbiB2YWx1ZS5cclxuICovXHJcbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChhLCBiKSB7XHJcbiAgICByZXR1cm4gaXNTaGFsbG93RXF1YWwoYSwgYiwgdW5kZWZpbmVkKTtcclxufVxyXG52YXIgaXNDaXJjdWxhckRlZXBFcXVhbCA9IGNyZWF0ZUNvbXBhcmF0b3IoREVGQVVMVF9DSVJDVUxBUl9DT05GSUcpO1xyXG4vKipcclxuICogV2hldGhlciB0aGUgaXRlbXMgcGFzc2VkIGFyZSBkZWVwbHktZXF1YWwgaW4gdmFsdWUsIGluY2x1ZGluZyBjaXJjdWxhciByZWZlcmVuY2VzLlxyXG4gKi9cclxuZnVuY3Rpb24gY2lyY3VsYXJEZWVwRXF1YWwoYSwgYikge1xyXG4gICAgcmV0dXJuIGlzQ2lyY3VsYXJEZWVwRXF1YWwoYSwgYiwgbmV3IFdlYWtNYXAoKSk7XHJcbn1cclxudmFyIGlzQ2lyY3VsYXJTaGFsbG93RXF1YWwgPSBjcmVhdGVDb21wYXJhdG9yKG1lcmdlKERFRkFVTFRfQ0lSQ1VMQVJfQ09ORklHLCB7XHJcbiAgICBjcmVhdGVJc05lc3RlZEVxdWFsOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzYW1lVmFsdWVaZXJvRXF1YWw7IH0sXHJcbn0pKTtcclxuLyoqXHJcbiAqIFdoZXRoZXIgdGhlIGl0ZW1zIHBhc3NlZCBhcmUgc2hhbGxvd2x5LWVxdWFsIGluIHZhbHVlLCBpbmNsdWRpbmcgY2lyY3VsYXIgcmVmZXJlbmNlcy5cclxuICovXHJcbmZ1bmN0aW9uIGNpcmN1bGFyU2hhbGxvd0VxdWFsKGEsIGIpIHtcclxuICAgIHJldHVybiBpc0NpcmN1bGFyU2hhbGxvd0VxdWFsKGEsIGIsIG5ldyBXZWFrTWFwKCkpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBjdXN0b20gZXF1YWxpdHkgY29tcGFyaXNvbiBtZXRob2QuXHJcbiAqXHJcbiAqIFRoaXMgY2FuIGJlIGRvbmUgdG8gY3JlYXRlIHZlcnkgdGFyZ2V0ZWQgY29tcGFyaXNvbnMgaW4gZXh0cmVtZSBob3QtcGF0aCBzY2VuYXJpb3NcclxuICogd2hlcmUgdGhlIHN0YW5kYXJkIG1ldGhvZHMgYXJlIG5vdCBwZXJmb3JtYW50IGVub3VnaCwgYnV0IGNhbiBhbHNvIGJlIHVzZWQgdG8gcHJvdmlkZVxyXG4gKiBzdXBwb3J0IGZvciBsZWdhY3kgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHN1cHBvcnQgZXhwZWN0ZWQgZmVhdHVyZXMgbGlrZVxyXG4gKiBgUmVnRXhwLnByb3RvdHlwZS5mbGFnc2Agb3V0IG9mIHRoZSBib3guXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVDdXN0b21FcXVhbChnZXRDb21wYXJhdG9yT3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGNyZWF0ZUNvbXBhcmF0b3IobWVyZ2UoREVGQVVMVF9DT05GSUcsIGdldENvbXBhcmF0b3JPcHRpb25zKERFRkFVTFRfQ09ORklHKSkpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBjdXN0b20gZXF1YWxpdHkgY29tcGFyaXNvbiBtZXRob2QgdGhhdCBoYW5kbGVzIGNpcmN1bGFyIHJlZmVyZW5jZXMuIFRoaXMgaXMgdmVyeVxyXG4gKiBzaW1pbGFyIHRvIGBjcmVhdGVDdXN0b21FcXVhbGAsIHdpdGggdGhlIG9ubHkgZGlmZmVyZW5jZSBiZWluZyB0aGF0IGBtZXRhYCBleHBlY3RzIHRvIGJlXHJcbiAqIHBvcHVsYXRlZCB3aXRoIGEgYFdlYWtNYXBgLWxpa2UgY29udHJhY3QuXHJcbiAqXHJcbiAqIFRoaXMgY2FuIGJlIGRvbmUgdG8gY3JlYXRlIHZlcnkgdGFyZ2V0ZWQgY29tcGFyaXNvbnMgaW4gZXh0cmVtZSBob3QtcGF0aCBzY2VuYXJpb3NcclxuICogd2hlcmUgdGhlIHN0YW5kYXJkIG1ldGhvZHMgYXJlIG5vdCBwZXJmb3JtYW50IGVub3VnaCwgYnV0IGNhbiBhbHNvIGJlIHVzZWQgdG8gcHJvdmlkZVxyXG4gKiBzdXBwb3J0IGZvciBsZWdhY3kgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHN1cHBvcnQgZXhwZWN0ZWQgZmVhdHVyZXMgbGlrZVxyXG4gKiBgV2Vha01hcGAgb3V0IG9mIHRoZSBib3guXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVDdXN0b21DaXJjdWxhckVxdWFsKGdldENvbXBhcmF0b3JPcHRpb25zKSB7XHJcbiAgICB2YXIgY29tcGFyYXRvciA9IGNyZWF0ZUNvbXBhcmF0b3IobWVyZ2UoREVGQVVMVF9DSVJDVUxBUl9DT05GSUcsIGdldENvbXBhcmF0b3JPcHRpb25zKERFRkFVTFRfQ0lSQ1VMQVJfQ09ORklHKSkpO1xyXG4gICAgcmV0dXJuIChmdW5jdGlvbiAoYSwgYiwgbWV0YSkge1xyXG4gICAgICAgIGlmIChtZXRhID09PSB2b2lkIDApIHsgbWV0YSA9IG5ldyBXZWFrTWFwKCk7IH1cclxuICAgICAgICByZXR1cm4gY29tcGFyYXRvcihhLCBiLCBtZXRhKTtcclxuICAgIH0pO1xyXG59XG5cbmV4cG9ydCB7IGNpcmN1bGFyRGVlcEVxdWFsLCBjaXJjdWxhclNoYWxsb3dFcXVhbCwgY3JlYXRlQ3VzdG9tQ2lyY3VsYXJFcXVhbCwgY3JlYXRlQ3VzdG9tRXF1YWwsIGRlZXBFcXVhbCwgc2FtZVZhbHVlWmVyb0VxdWFsLCBzaGFsbG93RXF1YWwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZhc3QtZXF1YWxzLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-equals/dist/fast-equals.esm.js\n");

/***/ })

};
;